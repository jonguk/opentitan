# Copyright lowRISC contributors (OpenTitan project).
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0
"""Generate SystemC DV skeleton mirroring UVM env structure.

This creates sc/ directories under the env_outdir (ip root) with
tb/env/tests sources that use the SystemC reg_model generated by regtool.
"""

from pathlib import Path


def _write(p: Path, content: str) -> None:
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(content, encoding='utf-8')


def gen_sc(name: str, env_outdir: str, vendor: str, *,
           is_cip: bool, has_ral: bool, has_interrupts: bool,
           has_alerts: bool, env_agents: list[str]) -> None:
    ip_root = Path(env_outdir)
    sc_root = ip_root / 'scdv'
    # (legacy tb/tb.cpp emission removed)

    readme = f"""# SystemC DV Skeleton for {name}

- Mirrors UVM env structure (tb/env/tests) with SystemC/TLM.
- Expects {name}_reg_model generated by regtool --systemc.
"""
    _write(sc_root / 'README.md', readme)

    # UVM SystemC skeleton: env and smoke test mirroring SV names
    env_hpp = f"""
#pragma once
#include <uvm>
#include "../../../dv/sc/tl_agent/tl_monitor.hpp"
#include "../../../dv/sc/scoreboard/scoreboard.hpp"

class {name}_env : public uvm::uvm_env {{
 public:
  UVM_COMPONENT_UTILS({name}_env);
  simple_scoreboard *scb {{nullptr}};
  tl_monitor *mon {{nullptr}};

  explicit {name}_env(uvm::uvm_component_name name) : uvm::uvm_env(name) {{}}

  void build_phase(uvm::uvm_phase &phase) override {{
    uvm::uvm_env::build_phase(phase);
    scb = simple_scoreboard::type_id::create("scb", this);
    mon = tl_monitor::type_id::create("mon", this);
  }}

  void connect_phase(uvm::uvm_phase &phase) override {{
    uvm::uvm_env::connect_phase(phase);
    if (mon && scb) mon->connect_scoreboard(scb);
  }}
}};
"""
    _write(sc_root / 'env' / f'{name}_env.hpp', env_hpp)
    # emit compatibility header
    compat_hpp = """#pragma once
#include <uvm>
namespace uvm_sc_compat_detail {
  template <typename T>
  inline ::uvm::uvm_component_registry<T>* ensure_component_registered() { return ::uvm::uvm_component_registry<T>::get(); }
  template <typename T>
  inline ::uvm::uvm_object_registry<T>* ensure_object_registered() { return ::uvm::uvm_object_registry<T>::get(); }
}
#define UVM_COMPONENT_REGISTER(TYPE) \
  namespace { auto TYPE##_uvm_sc_reg = ::uvm_sc_compat_detail::ensure_component_registered<TYPE>(); }
#define UVM_OBJECT_REGISTER(TYPE) \
  namespace { auto TYPE##_uvm_sc_obj_reg = ::uvm_sc_compat_detail::ensure_object_registered<TYPE>(); }
"""
    _write(sc_root / 'env' / 'uvm_sc_compat.hpp', compat_hpp)

    main_cpp = f"""#include <uvm>
#include <string>
#include <systemc>
#include <ctime>
#include <cstdlib>
#include <tlm_utils/simple_initiator_socket.h>
#include "../../../dv/sc/tl_agent/tl_bind.hpp"
#include "../../tlm/{name}_reg_pkg.hpp"
using namespace uvm;

static const char *get_testname_from_argv(int argc, char **argv) {{
  for (int i = 1; i < argc; ++i) {{
    std::string arg(argv[i] ? argv[i] : "");
    const std::string k1 = "+UVM_TESTNAME=";
    const std::string k2 = "UVM_TESTNAME=";
    if (arg.rfind(k1, 0) == 0) return argv[i] + k1.size();
    if (arg.rfind(k2, 0) == 0) return argv[i] + k2.size();
  }}
  return nullptr;
}}

static std::string get_plusarg_str(int argc, char **argv, const std::string &key) {{
  for (int i = 1; i < argc; ++i) {{
    std::string arg(argv[i] ? argv[i] : "");
    if (arg.rfind(key, 0) == 0) return arg.substr(key.size());
  }}
  return "";
}}

static bool has_plusarg(int argc, char **argv, const std::string &flag) {{
  for (int i = 1; i < argc; ++i) {{
    std::string arg(argv[i] ? argv[i] : "");
    if (arg == flag) return true;
  }}
  return false;
}}

static sc_core::sc_time parse_time_arg(const std::string &s) {{
  if (s.empty()) return sc_core::SC_ZERO_TIME;
  char *endp = nullptr;
  double val = std::strtod(s.c_str(), &endp);
  std::string unit = endp ? std::string(endp) : std::string();
  if (unit == "s" || unit == "S") return sc_core::sc_time(val, sc_core::SC_SEC);
  if (unit == "ms" || unit == "MS") return sc_core::sc_time(val, sc_core::SC_MS);
  if (unit == "us" || unit == "US") return sc_core::sc_time(val, sc_core::SC_US);
  if (unit == "ns" || unit == "NS") return sc_core::sc_time(val, sc_core::SC_NS);
  if (unit == "ps" || unit == "PS") return sc_core::sc_time(val, sc_core::SC_PS);
  return sc_core::sc_time(val, sc_core::SC_NS);
}}

static void apply_uvm_flags(int argc, char **argv) {{
  std::string verb = get_plusarg_str(argc, argv, "+UVM_VERBOSITY=");
  if (!verb.empty()) {{
    uvm::uvm_verbosity v = uvm::UVM_MEDIUM;
    if (verb == "UVM_NONE") v = uvm::UVM_NONE;
    else if (verb == "UVM_LOW") v = uvm::UVM_LOW;
    else if (verb == "UVM_MEDIUM") v = uvm::UVM_MEDIUM;
    else if (verb == "UVM_HIGH") v = uvm::UVM_HIGH;
    else if (verb == "UVM_FULL") v = uvm::UVM_FULL;
    uvm::uvm_root::get()->set_report_verbosity_level_hier(v);
  }}
  std::string mqc = get_plusarg_str(argc, argv, "+UVM_MAX_QUIT_COUNT=");
  if (!mqc.empty()) {{ int n = std::atoi(mqc.c_str()); (void)n; }}
  std::string to = get_plusarg_str(argc, argv, "+UVM_TIMEOUT=");
  if (!to.empty()) {{ sc_core::sc_time t = parse_time_arg(to);
    sc_core::sc_spawn([t]{{ sc_core::wait(t); uvm::uvm_report_fatal("UVM_TIMEOUT", "Simulation timed out", uvm::UVM_NONE); }}); }}
  std::string seed = get_plusarg_str(argc, argv, "+ntb_random_seed=");
  if (!seed.empty()) {{ unsigned s = 1u; if (seed == "random") s = static_cast<unsigned>(std::time(nullptr));
    else s = static_cast<unsigned>(std::strtoul(seed.c_str(), nullptr, 10)); std::srand(s);
    uvm::uvm_report_info("SEED", std::string("ntb_random_seed=") + std::to_string(s), uvm::UVM_LOW); }}
  if (has_plusarg(argc, argv, "+UVM_PHASE_TRACE")) uvm::uvm_report_info("UVM", "Phase trace requested", uvm::UVM_LOW);
  if (has_plusarg(argc, argv, "+UVM_OBJECTION_TRACE")) uvm::uvm_report_info("UVM", "Objection trace requested", uvm::UVM_LOW);
  if (has_plusarg(argc, argv, "+UVM_CONFIG_DB_TRACE")) uvm::uvm_report_info("UVM", "Config DB trace requested", uvm::UVM_LOW);
  if (has_plusarg(argc, argv, "+UVM_RESOURCE_DB_TRACE")) uvm::uvm_report_info("UVM", "Resource DB trace requested", uvm::UVM_LOW);
  if (has_plusarg(argc, argv, "+UVM_NO_RELNOTES")) uvm::uvm_report_info("UVM", "Suppress release notes", uvm::UVM_LOW);
}}

int sc_main(int argc, char **argv) {{
  struct top : sc_core::sc_module {{
    tlm_utils::simple_initiator_socket<top> init;
    opentitan::{name}::{name}_reg_top dut;
    SC_HAS_PROCESS(top);
    top(sc_core::sc_module_name n) : sc_core::sc_module(n), init("init"), dut("dut") {{ init.bind(dut.tlm_target); }}
  }} top_i("top");
  tl_bind::b_transport = [&](tlm::tlm_generic_payload &t, sc_core::sc_time &d){{ top_i.init->b_transport(t, d); }};
  tl_bind::reset = [&](){{ top_i.dut.reset(); }};
  tl_bind::set_racl_enable = [&](bool e){{ top_i.dut.set_racl_enable(e); }};
  tl_bind::set_racl_error_response = [&](bool e){{ top_i.dut.set_racl_error_response(e); }};
  tl_bind::set_reg_policy = [&](std::size_t idx, bool rd, bool wr){{ top_i.dut.set_reg_policy(idx, rd, wr); }};

  apply_uvm_flags(argc, argv);
  if (const char *tn = get_testname_from_argv(argc, argv)) {{ uvm::run_test(tn); }} else {{ uvm::run_test(); }}
  return 0;
}}
"""
    _write(sc_root / 'tests' / 'main.cpp', main_cpp)

    # Base smoke test stub
    test_cpp = f"""
#include <uvm>
#include "{name}_env.hpp"
#include "uvm_sc_compat.hpp"
using namespace uvm;

class {name}_smoke_test : public uvm_test {{
 public:
  UVM_COMPONENT_UTILS({name}_smoke_test);
  {name}_env* m_env {{}};
  explicit {name}_smoke_test(uvm_component_name name) : uvm_test(name) {{}}
  void build_phase(uvm_phase &phase) override {{
    uvm_test::build_phase(phase);
    m_env = {name}_env::type_id::create("env", this);
  }}
  void run_phase(uvm_phase &phase) override {{
    phase.raise_objection(this);
    phase.drop_objection(this);
  }}
}};

UVM_COMPONENT_REGISTER({name}_smoke_test);
"""
    _write(sc_root / 'tests' / f'{name}_smoke_test.cpp', test_cpp)

    # Tests Makefile
    tests_mk = f"""CXX ?= g++
CXXFLAGS ?= -O2 -g -std=c++17 -DSC_ALLOW_DEPRECATED_IEEE_API
ifndef SYSTEMC_HOME
$(error Please set SYSTEMC_HOME to your SystemC installation path)
endif
UVM_SYSTEMC_HOME ?= /opt/homebrew/uvm-systemc
UVM_SC_INCDIRS := $(UVM_SYSTEMC_HOME)/include /opt/homebrew/include
UVM_SC_LIBDIRS := $(UVM_SYSTEMC_HOME)/lib $(UVM_SYSTEMC_HOME)/lib-macosarm64 /opt/homebrew/uvm-systemc/lib-macosarm64 /opt/homebrew/lib
UVM_SC_INC := $(firstword $(foreach d,$(UVM_SC_INCDIRS),$(if $(wildcard $(d)),$(d),)))
UVM_SC_LIBDIR := $(firstword $(foreach d,$(UVM_SC_LIBDIRS),$(if $(wildcard $(d)),$(d),)))
LATEST_UVM_DYLIB := $(shell ls -1t $(addsuffix /libuvm-systemc*.dylib,$(UVM_SC_LIBDIRS)) 2>/dev/null | head -n1)
INC := -I$(SYSTEMC_HOME)/include -I$(UVM_SC_INC) -I../../tlm -I../env \
       -I../../../dv/sc/csr_utils -I../../../dv/sc/tl_agent \
       -I../../../dv/sc/dv_utils -I../../../dv/sc/bus_params_pkg -I../../../dv/sc/scoreboard
ifdef FC4SC_HOME
INC += -I$(FC4SC_HOME)/include
endif
ifdef FC4SC_READY
CXXFLAGS += -DENABLE_FC4SC -DFC4SC_READY
endif
LIBS := -L$(SYSTEMC_HOME)/lib -lsystemc
ifeq ($(strip $(LATEST_UVM_DYLIB)),)
  LIBS += -L$(UVM_SC_LIBDIR) -luvm-systemc
else
  LIBS += $(LATEST_UVM_DYLIB)
endif
SRCS := main.cpp
TEST_SRCS := $(wildcard {name}_*_test.cpp)
TESTS := $(patsubst %.cpp,%,$(TEST_SRCS))
all: $(TESTS)

# Link DUT implementation
DUT_SRC := ../../tlm/{name}_reg_top.cpp

%: %.cpp main.cpp $(DUT_SRC)
	$(CXX) $(CXXFLAGS) $(INC) $^ -o $@ $(LIBS)
clean:
	rm -f $(TESTS)
.PHONY: all clean
"""
    _write(sc_root / 'tests' / 'Makefile', tests_mk)

    # Tests README with usage and flags
    tests_readme = f"""# {name} SystemC UVM Tests

Build and run:

1) Ensure env vars:
   - SYSTEMC_HOME: your SystemC install prefix
   - UVM_SYSTEMC_HOME: your UVM-SystemC install prefix

2) Build all tests:

   make -C hw/ip/{name}/scdv/tests all

3) Run a specific test (UVM style):

   cd hw/ip/{name}/scdv/tests
   ./${name}_csr_rw_test +UVM_TESTNAME=${name}_csr_rw_test +UVM_VERBOSITY=UVM_MEDIUM +ntb_random_seed=random

Supported flags:
 - +UVM_TESTNAME=<test_class>
 - +UVM_VERBOSITY=UVM_NONE|UVM_LOW|UVM_MEDIUM|UVM_HIGH|UVM_FULL
 - +UVM_TIMEOUT=<value>[ns|us|ms|s]
 - +ntb_random_seed=<N>|random

Template verification:
 - To verify generated TLM matches checked-in sources, use:

   util/sc_tlm_diff.py --ip {name}  # add --update to sync
"""
    _write(sc_root / 'tests' / 'README.md', tests_readme)


