// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package soc_dbg_ctrl_jtag_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_category;
  typedef class soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_valid_relocked;
  typedef class soc_dbg_ctrl_jtag_reg_jtag_control;
  typedef class soc_dbg_ctrl_jtag_reg_jtag_status;
  typedef class soc_dbg_ctrl_jtag_reg_jtag_boot_status;
  typedef class soc_dbg_ctrl_jtag_reg_jtag_trace_soc_dbg_state;
  typedef class soc_dbg_ctrl_jtag_reg_block;

  class soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_category extends dv_base_reg;
    // fields
    rand dv_base_reg_field category;

    `uvm_object_utils(soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_category)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      category =
          (dv_base_reg_field::
           type_id::create("category"));
      category.configure(
        .parent(this),
        .size(7),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h50),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      category.set_original_access("RO");
    endfunction : build
  endclass : soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_category

  class soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_valid_relocked extends dv_base_reg;
    // fields
    rand dv_base_reg_field valid;
    rand dv_base_reg_field relocked;

    `uvm_object_utils(soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_valid_relocked)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      valid =
          (dv_base_reg_field::
           type_id::create("valid"));
      valid.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("RO"),
        .volatile(1),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      valid.set_original_access("RO");
      valid.set_mubi_width(4);
      relocked =
          (dv_base_reg_field::
           type_id::create("relocked"));
      relocked.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("RO"),
        .volatile(1),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      relocked.set_original_access("RO");
      relocked.set_mubi_width(4);
    endfunction : build
  endclass : soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_valid_relocked

  class soc_dbg_ctrl_jtag_reg_jtag_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field boot_continue;

    `uvm_object_utils(soc_dbg_ctrl_jtag_reg_jtag_control)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      boot_continue =
          (dv_base_reg_field::
           type_id::create("boot_continue"));
      boot_continue.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      boot_continue.set_original_access("RW");
    endfunction : build
  endclass : soc_dbg_ctrl_jtag_reg_jtag_control

  class soc_dbg_ctrl_jtag_reg_jtag_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field auth_debug_intent_set;
    rand dv_base_reg_field auth_window_open;
    rand dv_base_reg_field auth_window_closed;
    rand dv_base_reg_field auth_unlock_success;
    rand dv_base_reg_field auth_unlock_failed;

    `uvm_object_utils(soc_dbg_ctrl_jtag_reg_jtag_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      auth_debug_intent_set =
          (dv_base_reg_field::
           type_id::create("auth_debug_intent_set"));
      auth_debug_intent_set.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auth_debug_intent_set.set_original_access("RO");
      auth_window_open =
          (dv_base_reg_field::
           type_id::create("auth_window_open"));
      auth_window_open.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auth_window_open.set_original_access("RO");
      auth_window_closed =
          (dv_base_reg_field::
           type_id::create("auth_window_closed"));
      auth_window_closed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auth_window_closed.set_original_access("RO");
      auth_unlock_success =
          (dv_base_reg_field::
           type_id::create("auth_unlock_success"));
      auth_unlock_success.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auth_unlock_success.set_original_access("RO");
      auth_unlock_failed =
          (dv_base_reg_field::
           type_id::create("auth_unlock_failed"));
      auth_unlock_failed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auth_unlock_failed.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : soc_dbg_ctrl_jtag_reg_jtag_status

  class soc_dbg_ctrl_jtag_reg_jtag_boot_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field main_clk_status;
    rand dv_base_reg_field io_clk_status;
    rand dv_base_reg_field otp_done;
    rand dv_base_reg_field lc_done;
    rand dv_base_reg_field cpu_fetch_en;
    rand dv_base_reg_field halt_fsm_state;
    rand dv_base_reg_field boot_greenlight_done;
    rand dv_base_reg_field boot_greenlight_good;

    `uvm_object_utils(soc_dbg_ctrl_jtag_reg_jtag_boot_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      main_clk_status =
          (dv_base_reg_field::
           type_id::create("main_clk_status"));
      main_clk_status.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      main_clk_status.set_original_access("RO");
      io_clk_status =
          (dv_base_reg_field::
           type_id::create("io_clk_status"));
      io_clk_status.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      io_clk_status.set_original_access("RO");
      otp_done =
          (dv_base_reg_field::
           type_id::create("otp_done"));
      otp_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      otp_done.set_original_access("RO");
      lc_done =
          (dv_base_reg_field::
           type_id::create("lc_done"));
      lc_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      lc_done.set_original_access("RO");
      cpu_fetch_en =
          (dv_base_reg_field::
           type_id::create("cpu_fetch_en"));
      cpu_fetch_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cpu_fetch_en.set_original_access("RO");
      halt_fsm_state =
          (dv_base_reg_field::
           type_id::create("halt_fsm_state"));
      halt_fsm_state.configure(
        .parent(this),
        .size(6),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      halt_fsm_state.set_original_access("RO");
      boot_greenlight_done =
          (dv_base_reg_field::
           type_id::create("boot_greenlight_done"));
      boot_greenlight_done.configure(
        .parent(this),
        .size(3),
        .lsb_pos(11),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      boot_greenlight_done.set_original_access("RO");
      boot_greenlight_good =
          (dv_base_reg_field::
           type_id::create("boot_greenlight_good"));
      boot_greenlight_good.configure(
        .parent(this),
        .size(3),
        .lsb_pos(14),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      boot_greenlight_good.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : soc_dbg_ctrl_jtag_reg_jtag_boot_status

  class soc_dbg_ctrl_jtag_reg_jtag_trace_soc_dbg_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field soc_dbg_state;

    `uvm_object_utils(soc_dbg_ctrl_jtag_reg_jtag_trace_soc_dbg_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      soc_dbg_state =
          (dv_base_reg_field::
           type_id::create("soc_dbg_state"));
      soc_dbg_state.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      soc_dbg_state.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : soc_dbg_ctrl_jtag_reg_jtag_trace_soc_dbg_state

  class soc_dbg_ctrl_jtag_reg_block extends dv_base_reg_block;
    // registers
    rand soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_category jtag_trace_debug_policy_category;
    rand soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_valid_relocked jtag_trace_debug_policy_valid_relocked;
    rand soc_dbg_ctrl_jtag_reg_jtag_control jtag_control;
    rand soc_dbg_ctrl_jtag_reg_jtag_status jtag_status;
    rand soc_dbg_ctrl_jtag_reg_jtag_boot_status jtag_boot_status;
    rand soc_dbg_ctrl_jtag_reg_jtag_trace_soc_dbg_state jtag_trace_soc_dbg_state;

    `uvm_object_utils(soc_dbg_ctrl_jtag_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      jtag_trace_debug_policy_category =
          (soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_category::
           type_id::create("jtag_trace_debug_policy_category"));
      jtag_trace_debug_policy_category.configure(.blk_parent(this));
      jtag_trace_debug_policy_category.build(csr_excl);
      default_map.add_reg(.rg(jtag_trace_debug_policy_category),
                          .offset(32'h0));
      jtag_trace_debug_policy_category.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_trace_debug_policy_category.q",
          0, 7, 0, "BkdrRegPathRtl");

      jtag_trace_debug_policy_valid_relocked =
          (soc_dbg_ctrl_jtag_reg_jtag_trace_debug_policy_valid_relocked::
           type_id::create("jtag_trace_debug_policy_valid_relocked"));
      jtag_trace_debug_policy_valid_relocked.configure(.blk_parent(this));
      jtag_trace_debug_policy_valid_relocked.build(csr_excl);
      default_map.add_reg(.rg(jtag_trace_debug_policy_valid_relocked),
                          .offset(32'h4));
      jtag_trace_debug_policy_valid_relocked.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_trace_debug_policy_valid_relocked_valid.q",
          0, 4, 0, "BkdrRegPathRtl");
      jtag_trace_debug_policy_valid_relocked.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_trace_debug_policy_valid_relocked_relocked.q",
          4, 4, 0, "BkdrRegPathRtl");

      jtag_control =
          (soc_dbg_ctrl_jtag_reg_jtag_control::
           type_id::create("jtag_control"));
      jtag_control.configure(.blk_parent(this));
      jtag_control.build(csr_excl);
      default_map.add_reg(.rg(jtag_control),
                          .offset(32'h8));
      jtag_control.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_control.q",
          0, 1, 0, "BkdrRegPathRtl");

      jtag_status =
          (soc_dbg_ctrl_jtag_reg_jtag_status::
           type_id::create("jtag_status"));
      jtag_status.configure(.blk_parent(this));
      jtag_status.build(csr_excl);
      default_map.add_reg(.rg(jtag_status),
                          .offset(32'hc));
      jtag_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_status_auth_debug_intent_set.qs",
          0, 1, 0, "BkdrRegPathRtl");
      jtag_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_status_auth_window_open.qs",
          4, 1, 0, "BkdrRegPathRtl");
      jtag_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_status_auth_window_closed.qs",
          5, 1, 0, "BkdrRegPathRtl");
      jtag_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_status_auth_unlock_success.qs",
          6, 1, 0, "BkdrRegPathRtl");
      jtag_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_status_auth_unlock_failed.qs",
          7, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(jtag_status.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      jtag_boot_status =
          (soc_dbg_ctrl_jtag_reg_jtag_boot_status::
           type_id::create("jtag_boot_status"));
      jtag_boot_status.configure(.blk_parent(this));
      jtag_boot_status.build(csr_excl);
      default_map.add_reg(.rg(jtag_boot_status),
                          .offset(32'h10));
      jtag_boot_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_boot_status_main_clk_status.qs",
          0, 1, 0, "BkdrRegPathRtl");
      jtag_boot_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_boot_status_io_clk_status.qs",
          1, 1, 0, "BkdrRegPathRtl");
      jtag_boot_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_boot_status_otp_done.qs",
          2, 1, 0, "BkdrRegPathRtl");
      jtag_boot_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_boot_status_lc_done.qs",
          3, 1, 0, "BkdrRegPathRtl");
      jtag_boot_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_boot_status_cpu_fetch_en.qs",
          4, 1, 0, "BkdrRegPathRtl");
      jtag_boot_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_boot_status_halt_fsm_state.qs",
          5, 6, 0, "BkdrRegPathRtl");
      jtag_boot_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_boot_status_boot_greenlight_done.qs",
          11, 3, 0, "BkdrRegPathRtl");
      jtag_boot_status.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_boot_status_boot_greenlight_good.qs",
          14, 3, 0, "BkdrRegPathRtl");

      jtag_trace_soc_dbg_state =
          (soc_dbg_ctrl_jtag_reg_jtag_trace_soc_dbg_state::
           type_id::create("jtag_trace_soc_dbg_state"));
      jtag_trace_soc_dbg_state.configure(.blk_parent(this));
      jtag_trace_soc_dbg_state.build(csr_excl);
      default_map.add_reg(.rg(jtag_trace_soc_dbg_state),
                          .offset(32'h14));
      jtag_trace_soc_dbg_state.add_hdl_path_slice(
          "u_reg_jtag.u_jtag_trace_soc_dbg_state.qs",
          0, 32, 0, "BkdrRegPathRtl");



      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : soc_dbg_ctrl_jtag_reg_block

endpackage

