// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package otp_macro_prim_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class otp_macro_prim_reg_csr0;
  typedef class otp_macro_prim_reg_csr1;
  typedef class otp_macro_prim_reg_csr2;
  typedef class otp_macro_prim_reg_csr3;
  typedef class otp_macro_prim_reg_csr4;
  typedef class otp_macro_prim_reg_csr5;
  typedef class otp_macro_prim_reg_csr6;
  typedef class otp_macro_prim_reg_csr7;
  typedef class otp_macro_prim_reg_block;

  class otp_macro_prim_reg_csr0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field field0;
    rand dv_base_reg_field field1;
    rand dv_base_reg_field field2;
    rand dv_base_reg_field field3;
    rand dv_base_reg_field field4;

    `uvm_object_utils(otp_macro_prim_reg_csr0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      field0 =
          (dv_base_reg_field::
           type_id::create("field0"));
      field0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field0.set_original_access("RW");
      field1 =
          (dv_base_reg_field::
           type_id::create("field1"));
      field1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field1.set_original_access("RW");
      field2 =
          (dv_base_reg_field::
           type_id::create("field2"));
      field2.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field2.set_original_access("RW");
      field3 =
          (dv_base_reg_field::
           type_id::create("field3"));
      field3.configure(
        .parent(this),
        .size(10),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field3.set_original_access("RW");
      field4 =
          (dv_base_reg_field::
           type_id::create("field4"));
      field4.configure(
        .parent(this),
        .size(11),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field4.set_original_access("RW");
    endfunction : build
  endclass : otp_macro_prim_reg_csr0

  class otp_macro_prim_reg_csr1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field field0;
    rand dv_base_reg_field field1;
    rand dv_base_reg_field field2;
    rand dv_base_reg_field field3;
    rand dv_base_reg_field field4;

    `uvm_object_utils(otp_macro_prim_reg_csr1)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      field0 =
          (dv_base_reg_field::
           type_id::create("field0"));
      field0.configure(
        .parent(this),
        .size(7),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field0.set_original_access("RW");
      field1 =
          (dv_base_reg_field::
           type_id::create("field1"));
      field1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field1.set_original_access("RW");
      field2 =
          (dv_base_reg_field::
           type_id::create("field2"));
      field2.configure(
        .parent(this),
        .size(7),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field2.set_original_access("RW");
      field3 =
          (dv_base_reg_field::
           type_id::create("field3"));
      field3.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field3.set_original_access("RW");
      field4 =
          (dv_base_reg_field::
           type_id::create("field4"));
      field4.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field4.set_original_access("RW");
    endfunction : build
  endclass : otp_macro_prim_reg_csr1

  class otp_macro_prim_reg_csr2 extends dv_base_reg;
    // fields
    rand dv_base_reg_field field0;

    `uvm_object_utils(otp_macro_prim_reg_csr2)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      field0 =
          (dv_base_reg_field::
           type_id::create("field0"));
      field0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field0.set_original_access("RW");
    endfunction : build
  endclass : otp_macro_prim_reg_csr2

  class otp_macro_prim_reg_csr3 extends dv_base_reg;
    // fields
    rand dv_base_reg_field field0;
    rand dv_base_reg_field field1;
    rand dv_base_reg_field field2;
    rand dv_base_reg_field field3;
    rand dv_base_reg_field field4;
    rand dv_base_reg_field field5;
    rand dv_base_reg_field field6;
    rand dv_base_reg_field field7;
    rand dv_base_reg_field field8;

    `uvm_object_utils(otp_macro_prim_reg_csr3)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      field0 =
          (dv_base_reg_field::
           type_id::create("field0"));
      field0.configure(
        .parent(this),
        .size(3),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field0.set_original_access("W1C");
      field1 =
          (dv_base_reg_field::
           type_id::create("field1"));
      field1.configure(
        .parent(this),
        .size(10),
        .lsb_pos(4),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field1.set_original_access("W1C");
      field2 =
          (dv_base_reg_field::
           type_id::create("field2"));
      field2.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field2.set_original_access("W1C");
      field3 =
          (dv_base_reg_field::
           type_id::create("field3"));
      field3.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field3.set_original_access("RO");
      field4 =
          (dv_base_reg_field::
           type_id::create("field4"));
      field4.configure(
        .parent(this),
        .size(1),
        .lsb_pos(18),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field4.set_original_access("RO");
      field5 =
          (dv_base_reg_field::
           type_id::create("field5"));
      field5.configure(
        .parent(this),
        .size(1),
        .lsb_pos(19),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field5.set_original_access("RO");
      field6 =
          (dv_base_reg_field::
           type_id::create("field6"));
      field6.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field6.set_original_access("RO");
      field7 =
          (dv_base_reg_field::
           type_id::create("field7"));
      field7.configure(
        .parent(this),
        .size(1),
        .lsb_pos(21),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field7.set_original_access("RO");
      field8 =
          (dv_base_reg_field::
           type_id::create("field8"));
      field8.configure(
        .parent(this),
        .size(1),
        .lsb_pos(22),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field8.set_original_access("RO");
    endfunction : build
  endclass : otp_macro_prim_reg_csr3

  class otp_macro_prim_reg_csr4 extends dv_base_reg;
    // fields
    rand dv_base_reg_field field0;
    rand dv_base_reg_field field1;
    rand dv_base_reg_field field2;
    rand dv_base_reg_field field3;

    `uvm_object_utils(otp_macro_prim_reg_csr4)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      field0 =
          (dv_base_reg_field::
           type_id::create("field0"));
      field0.configure(
        .parent(this),
        .size(10),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field0.set_original_access("RW");
      field1 =
          (dv_base_reg_field::
           type_id::create("field1"));
      field1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field1.set_original_access("RW");
      field2 =
          (dv_base_reg_field::
           type_id::create("field2"));
      field2.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field2.set_original_access("RW");
      field3 =
          (dv_base_reg_field::
           type_id::create("field3"));
      field3.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field3.set_original_access("RW");
    endfunction : build
  endclass : otp_macro_prim_reg_csr4

  class otp_macro_prim_reg_csr5 extends dv_base_reg;
    // fields
    rand dv_base_reg_field field0;
    rand dv_base_reg_field field1;
    rand dv_base_reg_field field2;
    rand dv_base_reg_field field3;
    rand dv_base_reg_field field4;
    rand dv_base_reg_field field5;
    rand dv_base_reg_field field6;

    `uvm_object_utils(otp_macro_prim_reg_csr5)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      field0 =
          (dv_base_reg_field::
           type_id::create("field0"));
      field0.configure(
        .parent(this),
        .size(6),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field0.set_original_access("RW");
      field1 =
          (dv_base_reg_field::
           type_id::create("field1"));
      field1.configure(
        .parent(this),
        .size(2),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field1.set_original_access("RW");
      field2 =
          (dv_base_reg_field::
           type_id::create("field2"));
      field2.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field2.set_original_access("RO");
      field3 =
          (dv_base_reg_field::
           type_id::create("field3"));
      field3.configure(
        .parent(this),
        .size(3),
        .lsb_pos(9),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field3.set_original_access("RO");
      field4 =
          (dv_base_reg_field::
           type_id::create("field4"));
      field4.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field4.set_original_access("RO");
      field5 =
          (dv_base_reg_field::
           type_id::create("field5"));
      field5.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field5.set_original_access("RO");
      field6 =
          (dv_base_reg_field::
           type_id::create("field6"));
      field6.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field6.set_original_access("RW");
    endfunction : build
  endclass : otp_macro_prim_reg_csr5

  class otp_macro_prim_reg_csr6 extends dv_base_reg;
    // fields
    rand dv_base_reg_field field0;
    rand dv_base_reg_field field1;
    rand dv_base_reg_field field2;
    rand dv_base_reg_field field3;

    `uvm_object_utils(otp_macro_prim_reg_csr6)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      field0 =
          (dv_base_reg_field::
           type_id::create("field0"));
      field0.configure(
        .parent(this),
        .size(10),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field0.set_original_access("RW");
      field1 =
          (dv_base_reg_field::
           type_id::create("field1"));
      field1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field1.set_original_access("RW");
      field2 =
          (dv_base_reg_field::
           type_id::create("field2"));
      field2.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field2.set_original_access("RW");
      field3 =
          (dv_base_reg_field::
           type_id::create("field3"));
      field3.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field3.set_original_access("RW");
    endfunction : build
  endclass : otp_macro_prim_reg_csr6

  class otp_macro_prim_reg_csr7 extends dv_base_reg;
    // fields
    rand dv_base_reg_field field0;
    rand dv_base_reg_field field1;
    rand dv_base_reg_field field2;
    rand dv_base_reg_field field3;

    `uvm_object_utils(otp_macro_prim_reg_csr7)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      field0 =
          (dv_base_reg_field::
           type_id::create("field0"));
      field0.configure(
        .parent(this),
        .size(6),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field0.set_original_access("RO");
      field1 =
          (dv_base_reg_field::
           type_id::create("field1"));
      field1.configure(
        .parent(this),
        .size(3),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field1.set_original_access("RO");
      field2 =
          (dv_base_reg_field::
           type_id::create("field2"));
      field2.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field2.set_original_access("RO");
      field3 =
          (dv_base_reg_field::
           type_id::create("field3"));
      field3.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      field3.set_original_access("RO");
    endfunction : build
  endclass : otp_macro_prim_reg_csr7

  class otp_macro_prim_reg_block extends dv_base_reg_block;
    // registers
    rand otp_macro_prim_reg_csr0 csr0;
    rand otp_macro_prim_reg_csr1 csr1;
    rand otp_macro_prim_reg_csr2 csr2;
    rand otp_macro_prim_reg_csr3 csr3;
    rand otp_macro_prim_reg_csr4 csr4;
    rand otp_macro_prim_reg_csr5 csr5;
    rand otp_macro_prim_reg_csr6 csr6;
    rand otp_macro_prim_reg_csr7 csr7;

    `uvm_object_utils(otp_macro_prim_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      csr0 =
          (otp_macro_prim_reg_csr0::
           type_id::create("csr0"));
      csr0.configure(.blk_parent(this));
      csr0.build(csr_excl);
      default_map.add_reg(.rg(csr0),
                          .offset(32'h0));
      csr0.add_hdl_path_slice(
          "u_reg_prim.u_csr0_field0.q",
          0, 1, 0, "BkdrRegPathRtl");
      csr0.add_hdl_path_slice(
          "u_reg_prim.u_csr0_field1.q",
          1, 1, 0, "BkdrRegPathRtl");
      csr0.add_hdl_path_slice(
          "u_reg_prim.u_csr0_field2.q",
          2, 1, 0, "BkdrRegPathRtl");
      csr0.add_hdl_path_slice(
          "u_reg_prim.u_csr0_field3.q",
          4, 10, 0, "BkdrRegPathRtl");
      csr0.add_hdl_path_slice(
          "u_reg_prim.u_csr0_field4.q",
          16, 11, 0, "BkdrRegPathRtl");

      csr1 =
          (otp_macro_prim_reg_csr1::
           type_id::create("csr1"));
      csr1.configure(.blk_parent(this));
      csr1.build(csr_excl);
      default_map.add_reg(.rg(csr1),
                          .offset(32'h4));
      csr1.add_hdl_path_slice(
          "u_reg_prim.u_csr1_field0.q",
          0, 7, 0, "BkdrRegPathRtl");
      csr1.add_hdl_path_slice(
          "u_reg_prim.u_csr1_field1.q",
          7, 1, 0, "BkdrRegPathRtl");
      csr1.add_hdl_path_slice(
          "u_reg_prim.u_csr1_field2.q",
          8, 7, 0, "BkdrRegPathRtl");
      csr1.add_hdl_path_slice(
          "u_reg_prim.u_csr1_field3.q",
          15, 1, 0, "BkdrRegPathRtl");
      csr1.add_hdl_path_slice(
          "u_reg_prim.u_csr1_field4.q",
          16, 16, 0, "BkdrRegPathRtl");

      csr2 =
          (otp_macro_prim_reg_csr2::
           type_id::create("csr2"));
      csr2.configure(.blk_parent(this));
      csr2.build(csr_excl);
      default_map.add_reg(.rg(csr2),
                          .offset(32'h8));
      csr2.add_hdl_path_slice(
          "u_reg_prim.u_csr2.q",
          0, 1, 0, "BkdrRegPathRtl");

      csr3 =
          (otp_macro_prim_reg_csr3::
           type_id::create("csr3"));
      csr3.configure(.blk_parent(this));
      csr3.build(csr_excl);
      default_map.add_reg(.rg(csr3),
                          .offset(32'hc));
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field0.q",
          0, 3, 0, "BkdrRegPathRtl");
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field1.q",
          4, 10, 0, "BkdrRegPathRtl");
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field2.q",
          16, 1, 0, "BkdrRegPathRtl");
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field3.q",
          17, 1, 0, "BkdrRegPathRtl");
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field4.q",
          18, 1, 0, "BkdrRegPathRtl");
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field5.q",
          19, 1, 0, "BkdrRegPathRtl");
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field6.q",
          20, 1, 0, "BkdrRegPathRtl");
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field7.q",
          21, 1, 0, "BkdrRegPathRtl");
      csr3.add_hdl_path_slice(
          "u_reg_prim.u_csr3_field8.q",
          22, 1, 0, "BkdrRegPathRtl");

      csr4 =
          (otp_macro_prim_reg_csr4::
           type_id::create("csr4"));
      csr4.configure(.blk_parent(this));
      csr4.build(csr_excl);
      default_map.add_reg(.rg(csr4),
                          .offset(32'h10));
      csr4.add_hdl_path_slice(
          "u_reg_prim.u_csr4_field0.q",
          0, 10, 0, "BkdrRegPathRtl");
      csr4.add_hdl_path_slice(
          "u_reg_prim.u_csr4_field1.q",
          12, 1, 0, "BkdrRegPathRtl");
      csr4.add_hdl_path_slice(
          "u_reg_prim.u_csr4_field2.q",
          13, 1, 0, "BkdrRegPathRtl");
      csr4.add_hdl_path_slice(
          "u_reg_prim.u_csr4_field3.q",
          14, 1, 0, "BkdrRegPathRtl");

      csr5 =
          (otp_macro_prim_reg_csr5::
           type_id::create("csr5"));
      csr5.configure(.blk_parent(this));
      csr5.build(csr_excl);
      default_map.add_reg(.rg(csr5),
                          .offset(32'h14));
      csr5.add_hdl_path_slice(
          "u_reg_prim.u_csr5_field0.q",
          0, 6, 0, "BkdrRegPathRtl");
      csr5.add_hdl_path_slice(
          "u_reg_prim.u_csr5_field1.q",
          6, 2, 0, "BkdrRegPathRtl");
      csr5.add_hdl_path_slice(
          "u_reg_prim.u_csr5_field2.q",
          8, 1, 0, "BkdrRegPathRtl");
      csr5.add_hdl_path_slice(
          "u_reg_prim.u_csr5_field3.q",
          9, 3, 0, "BkdrRegPathRtl");
      csr5.add_hdl_path_slice(
          "u_reg_prim.u_csr5_field4.q",
          12, 1, 0, "BkdrRegPathRtl");
      csr5.add_hdl_path_slice(
          "u_reg_prim.u_csr5_field5.q",
          13, 1, 0, "BkdrRegPathRtl");
      csr5.add_hdl_path_slice(
          "u_reg_prim.u_csr5_field6.q",
          16, 16, 0, "BkdrRegPathRtl");

      csr6 =
          (otp_macro_prim_reg_csr6::
           type_id::create("csr6"));
      csr6.configure(.blk_parent(this));
      csr6.build(csr_excl);
      default_map.add_reg(.rg(csr6),
                          .offset(32'h18));
      csr6.add_hdl_path_slice(
          "u_reg_prim.u_csr6_field0.q",
          0, 10, 0, "BkdrRegPathRtl");
      csr6.add_hdl_path_slice(
          "u_reg_prim.u_csr6_field1.q",
          11, 1, 0, "BkdrRegPathRtl");
      csr6.add_hdl_path_slice(
          "u_reg_prim.u_csr6_field2.q",
          12, 1, 0, "BkdrRegPathRtl");
      csr6.add_hdl_path_slice(
          "u_reg_prim.u_csr6_field3.q",
          16, 16, 0, "BkdrRegPathRtl");

      csr7 =
          (otp_macro_prim_reg_csr7::
           type_id::create("csr7"));
      csr7.configure(.blk_parent(this));
      csr7.build(csr_excl);
      default_map.add_reg(.rg(csr7),
                          .offset(32'h1c));
      csr7.add_hdl_path_slice(
          "u_reg_prim.u_csr7_field0.q",
          0, 6, 0, "BkdrRegPathRtl");
      csr7.add_hdl_path_slice(
          "u_reg_prim.u_csr7_field1.q",
          8, 3, 0, "BkdrRegPathRtl");
      csr7.add_hdl_path_slice(
          "u_reg_prim.u_csr7_field2.q",
          14, 1, 0, "BkdrRegPathRtl");
      csr7.add_hdl_path_slice(
          "u_reg_prim.u_csr7_field3.q",
          15, 1, 0, "BkdrRegPathRtl");



      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : otp_macro_prim_reg_block

endpackage

