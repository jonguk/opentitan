// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package pattgen_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class pattgen_reg_intr_state;
  typedef class pattgen_reg_intr_enable;
  typedef class pattgen_reg_intr_test;
  typedef class pattgen_reg_alert_test;
  typedef class pattgen_reg_ctrl;
  typedef class pattgen_reg_prediv_ch0;
  typedef class pattgen_reg_prediv_ch1;
  typedef class pattgen_reg_data_ch0;
  typedef class pattgen_reg_data_ch1;
  typedef class pattgen_reg_size;
  typedef class pattgen_reg_block;

  class pattgen_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field done_ch0;
    rand dv_base_reg_field done_ch1;

    `uvm_object_utils(pattgen_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      done_ch0 =
          (dv_base_reg_field::
           type_id::create("done_ch0"));
      done_ch0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done_ch0.set_original_access("W1C");
      done_ch1 =
          (dv_base_reg_field::
           type_id::create("done_ch1"));
      done_ch1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done_ch1.set_original_access("W1C");
    endfunction : build
  endclass : pattgen_reg_intr_state

  class pattgen_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field done_ch0;
    rand dv_base_reg_field done_ch1;

    `uvm_object_utils(pattgen_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      done_ch0 =
          (dv_base_reg_field::
           type_id::create("done_ch0"));
      done_ch0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done_ch0.set_original_access("RW");
      done_ch1 =
          (dv_base_reg_field::
           type_id::create("done_ch1"));
      done_ch1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done_ch1.set_original_access("RW");
    endfunction : build
  endclass : pattgen_reg_intr_enable

  class pattgen_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field done_ch0;
    rand dv_base_reg_field done_ch1;

    `uvm_object_utils(pattgen_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      done_ch0 =
          (dv_base_reg_field::
           type_id::create("done_ch0"));
      done_ch0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done_ch0.set_original_access("WO");
      done_ch1 =
          (dv_base_reg_field::
           type_id::create("done_ch1"));
      done_ch1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done_ch1.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : pattgen_reg_intr_test

  class pattgen_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(pattgen_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : pattgen_reg_alert_test

  class pattgen_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable_ch0;
    rand dv_base_reg_field enable_ch1;
    rand dv_base_reg_field polarity_ch0;
    rand dv_base_reg_field polarity_ch1;
    rand dv_base_reg_field inactive_level_pcl_ch0;
    rand dv_base_reg_field inactive_level_pda_ch0;
    rand dv_base_reg_field inactive_level_pcl_ch1;
    rand dv_base_reg_field inactive_level_pda_ch1;

    `uvm_object_utils(pattgen_reg_ctrl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable_ch0 =
          (dv_base_reg_field::
           type_id::create("enable_ch0"));
      enable_ch0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable_ch0.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(enable_ch0.get_full_name(), CsrExclWrite, CsrNonInitTests);
      enable_ch1 =
          (dv_base_reg_field::
           type_id::create("enable_ch1"));
      enable_ch1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable_ch1.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(enable_ch1.get_full_name(), CsrExclWrite, CsrNonInitTests);
      polarity_ch0 =
          (dv_base_reg_field::
           type_id::create("polarity_ch0"));
      polarity_ch0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      polarity_ch0.set_original_access("RW");
      polarity_ch1 =
          (dv_base_reg_field::
           type_id::create("polarity_ch1"));
      polarity_ch1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      polarity_ch1.set_original_access("RW");
      inactive_level_pcl_ch0 =
          (dv_base_reg_field::
           type_id::create("inactive_level_pcl_ch0"));
      inactive_level_pcl_ch0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inactive_level_pcl_ch0.set_original_access("RW");
      inactive_level_pda_ch0 =
          (dv_base_reg_field::
           type_id::create("inactive_level_pda_ch0"));
      inactive_level_pda_ch0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inactive_level_pda_ch0.set_original_access("RW");
      inactive_level_pcl_ch1 =
          (dv_base_reg_field::
           type_id::create("inactive_level_pcl_ch1"));
      inactive_level_pcl_ch1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inactive_level_pcl_ch1.set_original_access("RW");
      inactive_level_pda_ch1 =
          (dv_base_reg_field::
           type_id::create("inactive_level_pda_ch1"));
      inactive_level_pda_ch1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inactive_level_pda_ch1.set_original_access("RW");
    endfunction : build
  endclass : pattgen_reg_ctrl

  class pattgen_reg_prediv_ch0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field clk_ratio;

    `uvm_object_utils(pattgen_reg_prediv_ch0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      clk_ratio =
          (dv_base_reg_field::
           type_id::create("clk_ratio"));
      clk_ratio.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      clk_ratio.set_original_access("RW");
    endfunction : build
  endclass : pattgen_reg_prediv_ch0

  class pattgen_reg_prediv_ch1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field clk_ratio;

    `uvm_object_utils(pattgen_reg_prediv_ch1)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      clk_ratio =
          (dv_base_reg_field::
           type_id::create("clk_ratio"));
      clk_ratio.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      clk_ratio.set_original_access("RW");
    endfunction : build
  endclass : pattgen_reg_prediv_ch1

  class pattgen_reg_data_ch0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field data;

    `uvm_object_utils(pattgen_reg_data_ch0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data =
          (dv_base_reg_field::
           type_id::create("data_0"));
      data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data.set_original_access("RW");
    endfunction : build
  endclass : pattgen_reg_data_ch0

  class pattgen_reg_data_ch1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field data;

    `uvm_object_utils(pattgen_reg_data_ch1)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data =
          (dv_base_reg_field::
           type_id::create("data_0"));
      data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data.set_original_access("RW");
    endfunction : build
  endclass : pattgen_reg_data_ch1

  class pattgen_reg_size extends dv_base_reg;
    // fields
    rand dv_base_reg_field len_ch0;
    rand dv_base_reg_field reps_ch0;
    rand dv_base_reg_field len_ch1;
    rand dv_base_reg_field reps_ch1;

    `uvm_object_utils(pattgen_reg_size)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      len_ch0 =
          (dv_base_reg_field::
           type_id::create("len_ch0"));
      len_ch0.configure(
        .parent(this),
        .size(6),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      len_ch0.set_original_access("RW");
      reps_ch0 =
          (dv_base_reg_field::
           type_id::create("reps_ch0"));
      reps_ch0.configure(
        .parent(this),
        .size(10),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reps_ch0.set_original_access("RW");
      len_ch1 =
          (dv_base_reg_field::
           type_id::create("len_ch1"));
      len_ch1.configure(
        .parent(this),
        .size(6),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      len_ch1.set_original_access("RW");
      reps_ch1 =
          (dv_base_reg_field::
           type_id::create("reps_ch1"));
      reps_ch1.configure(
        .parent(this),
        .size(10),
        .lsb_pos(22),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reps_ch1.set_original_access("RW");
    endfunction : build
  endclass : pattgen_reg_size

  class pattgen_reg_block extends dv_base_reg_block;
    // registers
    rand pattgen_reg_intr_state intr_state;
    rand pattgen_reg_intr_enable intr_enable;
    rand pattgen_reg_intr_test intr_test;
    rand pattgen_reg_alert_test alert_test;
    rand pattgen_reg_ctrl ctrl;
    rand pattgen_reg_prediv_ch0 prediv_ch0;
    rand pattgen_reg_prediv_ch1 prediv_ch1;
    rand pattgen_reg_data_ch0 data_ch0[2];
    rand pattgen_reg_data_ch1 data_ch1[2];
    rand pattgen_reg_size size;

    `uvm_object_utils(pattgen_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (pattgen_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_done_ch0.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_done_ch1.q",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (pattgen_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_done_ch0.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_done_ch1.q",
          1, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (pattgen_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_done_ch0.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_done_ch1.qs",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (pattgen_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      ctrl =
          (pattgen_reg_ctrl::
           type_id::create("ctrl"));
      ctrl.configure(.blk_parent(this));
      ctrl.build(csr_excl);
      default_map.add_reg(.rg(ctrl),
                          .offset(32'h10));
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_enable_ch0.q",
          0, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_enable_ch1.q",
          1, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_polarity_ch0.q",
          2, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_polarity_ch1.q",
          3, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_inactive_level_pcl_ch0.q",
          4, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_inactive_level_pda_ch0.q",
          5, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_inactive_level_pcl_ch1.q",
          6, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_inactive_level_pda_ch1.q",
          7, 1, 0, "BkdrRegPathRtl");

      prediv_ch0 =
          (pattgen_reg_prediv_ch0::
           type_id::create("prediv_ch0"));
      prediv_ch0.configure(.blk_parent(this));
      prediv_ch0.build(csr_excl);
      default_map.add_reg(.rg(prediv_ch0),
                          .offset(32'h14));
      prediv_ch0.add_hdl_path_slice(
          "u_reg.u_prediv_ch0.q",
          0, 32, 0, "BkdrRegPathRtl");

      prediv_ch1 =
          (pattgen_reg_prediv_ch1::
           type_id::create("prediv_ch1"));
      prediv_ch1.configure(.blk_parent(this));
      prediv_ch1.build(csr_excl);
      default_map.add_reg(.rg(prediv_ch1),
                          .offset(32'h18));
      prediv_ch1.add_hdl_path_slice(
          "u_reg.u_prediv_ch1.q",
          0, 32, 0, "BkdrRegPathRtl");

      data_ch0[0] =
          (pattgen_reg_data_ch0::
           type_id::create("data_ch0_0"));
      data_ch0[0].configure(.blk_parent(this));
      data_ch0[0].build(csr_excl);
      default_map.add_reg(.rg(data_ch0[0]),
                          .offset(32'h1c));
      data_ch0[0].add_hdl_path_slice(
          "u_reg.u_data_ch0_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      data_ch0[1] =
          (pattgen_reg_data_ch0::
           type_id::create("data_ch0_1"));
      data_ch0[1].configure(.blk_parent(this));
      data_ch0[1].build(csr_excl);
      default_map.add_reg(.rg(data_ch0[1]),
                          .offset(32'h20));
      data_ch0[1].add_hdl_path_slice(
          "u_reg.u_data_ch0_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      data_ch1[0] =
          (pattgen_reg_data_ch1::
           type_id::create("data_ch1_0"));
      data_ch1[0].configure(.blk_parent(this));
      data_ch1[0].build(csr_excl);
      default_map.add_reg(.rg(data_ch1[0]),
                          .offset(32'h24));
      data_ch1[0].add_hdl_path_slice(
          "u_reg.u_data_ch1_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      data_ch1[1] =
          (pattgen_reg_data_ch1::
           type_id::create("data_ch1_1"));
      data_ch1[1].configure(.blk_parent(this));
      data_ch1[1].build(csr_excl);
      default_map.add_reg(.rg(data_ch1[1]),
                          .offset(32'h28));
      data_ch1[1].add_hdl_path_slice(
          "u_reg.u_data_ch1_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      size =
          (pattgen_reg_size::
           type_id::create("size"));
      size.configure(.blk_parent(this));
      size.build(csr_excl);
      default_map.add_reg(.rg(size),
                          .offset(32'h2c));
      size.add_hdl_path_slice(
          "u_reg.u_size_len_ch0.q",
          0, 6, 0, "BkdrRegPathRtl");
      size.add_hdl_path_slice(
          "u_reg.u_size_reps_ch0.q",
          6, 10, 0, "BkdrRegPathRtl");
      size.add_hdl_path_slice(
          "u_reg.u_size_len_ch1.q",
          16, 6, 0, "BkdrRegPathRtl");
      size.add_hdl_path_slice(
          "u_reg.u_size_reps_ch1.q",
          22, 10, 0, "BkdrRegPathRtl");



      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : pattgen_reg_block

endpackage

