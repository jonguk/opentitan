// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package spi_host_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class spi_host_reg_intr_state;
  typedef class spi_host_reg_intr_enable;
  typedef class spi_host_reg_intr_test;
  typedef class spi_host_reg_alert_test;
  typedef class spi_host_reg_control;
  typedef class spi_host_reg_status;
  typedef class spi_host_reg_configopts;
  typedef class spi_host_reg_csid;
  typedef class spi_host_reg_command;
  typedef class spi_host_reg_error_enable;
  typedef class spi_host_reg_error_status;
  typedef class spi_host_reg_event_enable;
  typedef class spi_host_mem_rxdata;
  typedef class spi_host_mem_txdata;
  typedef class spi_host_reg_block;

  class spi_host_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field error;
    rand dv_base_reg_field spi_event;

    `uvm_object_utils(spi_host_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      error =
          (dv_base_reg_field::
           type_id::create("error"));
      error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      error.set_original_access("W1C");
      spi_event =
          (dv_base_reg_field::
           type_id::create("spi_event"));
      spi_event.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      spi_event.set_original_access("RO");
    endfunction : build
  endclass : spi_host_reg_intr_state

  class spi_host_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field error;
    rand dv_base_reg_field spi_event;

    `uvm_object_utils(spi_host_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      error =
          (dv_base_reg_field::
           type_id::create("error"));
      error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      error.set_original_access("RW");
      spi_event =
          (dv_base_reg_field::
           type_id::create("spi_event"));
      spi_event.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      spi_event.set_original_access("RW");
    endfunction : build
  endclass : spi_host_reg_intr_enable

  class spi_host_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field error;
    rand dv_base_reg_field spi_event;

    `uvm_object_utils(spi_host_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      error =
          (dv_base_reg_field::
           type_id::create("error"));
      error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      error.set_original_access("WO");
      spi_event =
          (dv_base_reg_field::
           type_id::create("spi_event"));
      spi_event.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      spi_event.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_host_reg_intr_test

  class spi_host_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(spi_host_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_host_reg_alert_test

  class spi_host_reg_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field rx_watermark;
    rand dv_base_reg_field tx_watermark;
    rand dv_base_reg_field output_en;
    rand dv_base_reg_field sw_rst;
    rand dv_base_reg_field spien;

    `uvm_object_utils(spi_host_reg_control)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rx_watermark =
          (dv_base_reg_field::
           type_id::create("rx_watermark"));
      rx_watermark.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7f),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_watermark.set_original_access("RW");
      tx_watermark =
          (dv_base_reg_field::
           type_id::create("tx_watermark"));
      tx_watermark.configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_watermark.set_original_access("RW");
      output_en =
          (dv_base_reg_field::
           type_id::create("output_en"));
      output_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      output_en.set_original_access("RW");
      sw_rst =
          (dv_base_reg_field::
           type_id::create("sw_rst"));
      sw_rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_rst.set_original_access("RW");
      spien =
          (dv_base_reg_field::
           type_id::create("spien"));
      spien.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      spien.set_original_access("RW");
    endfunction : build
  endclass : spi_host_reg_control

  class spi_host_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field txqd;
    rand dv_base_reg_field rxqd;
    rand dv_base_reg_field cmdqd;
    rand dv_base_reg_field rxwm;
    rand dv_base_reg_field byteorder;
    rand dv_base_reg_field rxstall;
    rand dv_base_reg_field rxempty;
    rand dv_base_reg_field rxfull;
    rand dv_base_reg_field txwm;
    rand dv_base_reg_field txstall;
    rand dv_base_reg_field txempty;
    rand dv_base_reg_field txfull;
    rand dv_base_reg_field active;
    rand dv_base_reg_field ready;

    `uvm_object_utils(spi_host_reg_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      txqd =
          (dv_base_reg_field::
           type_id::create("txqd"));
      txqd.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txqd.set_original_access("RO");
      rxqd =
          (dv_base_reg_field::
           type_id::create("rxqd"));
      rxqd.configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxqd.set_original_access("RO");
      cmdqd =
          (dv_base_reg_field::
           type_id::create("cmdqd"));
      cmdqd.configure(
        .parent(this),
        .size(4),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdqd.set_original_access("RO");
      rxwm =
          (dv_base_reg_field::
           type_id::create("rxwm"));
      rxwm.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxwm.set_original_access("RO");
      byteorder =
          (dv_base_reg_field::
           type_id::create("byteorder"));
      byteorder.configure(
        .parent(this),
        .size(1),
        .lsb_pos(22),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      byteorder.set_original_access("RO");
      rxstall =
          (dv_base_reg_field::
           type_id::create("rxstall"));
      rxstall.configure(
        .parent(this),
        .size(1),
        .lsb_pos(23),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxstall.set_original_access("RO");
      rxempty =
          (dv_base_reg_field::
           type_id::create("rxempty"));
      rxempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(24),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxempty.set_original_access("RO");
      rxfull =
          (dv_base_reg_field::
           type_id::create("rxfull"));
      rxfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(25),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxfull.set_original_access("RO");
      txwm =
          (dv_base_reg_field::
           type_id::create("txwm"));
      txwm.configure(
        .parent(this),
        .size(1),
        .lsb_pos(26),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txwm.set_original_access("RO");
      txstall =
          (dv_base_reg_field::
           type_id::create("txstall"));
      txstall.configure(
        .parent(this),
        .size(1),
        .lsb_pos(27),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txstall.set_original_access("RO");
      txempty =
          (dv_base_reg_field::
           type_id::create("txempty"));
      txempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(28),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txempty.set_original_access("RO");
      txfull =
          (dv_base_reg_field::
           type_id::create("txfull"));
      txfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txfull.set_original_access("RO");
      active =
          (dv_base_reg_field::
           type_id::create("active"));
      active.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      active.set_original_access("RO");
      ready =
          (dv_base_reg_field::
           type_id::create("ready"));
      ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ready.set_original_access("RO");
    endfunction : build
  endclass : spi_host_reg_status

  class spi_host_reg_configopts extends dv_base_reg;
    // fields
    rand dv_base_reg_field clkdiv;
    rand dv_base_reg_field csnidle;
    rand dv_base_reg_field csntrail;
    rand dv_base_reg_field csnlead;
    rand dv_base_reg_field fullcyc;
    rand dv_base_reg_field cpha;
    rand dv_base_reg_field cpol;

    `uvm_object_utils(spi_host_reg_configopts)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      clkdiv =
          (dv_base_reg_field::
           type_id::create("clkdiv"));
      clkdiv.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      clkdiv.set_original_access("RW");
      csnidle =
          (dv_base_reg_field::
           type_id::create("csnidle"));
      csnidle.configure(
        .parent(this),
        .size(4),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csnidle.set_original_access("RW");
      csntrail =
          (dv_base_reg_field::
           type_id::create("csntrail"));
      csntrail.configure(
        .parent(this),
        .size(4),
        .lsb_pos(20),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csntrail.set_original_access("RW");
      csnlead =
          (dv_base_reg_field::
           type_id::create("csnlead"));
      csnlead.configure(
        .parent(this),
        .size(4),
        .lsb_pos(24),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csnlead.set_original_access("RW");
      fullcyc =
          (dv_base_reg_field::
           type_id::create("fullcyc"));
      fullcyc.configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fullcyc.set_original_access("RW");
      cpha =
          (dv_base_reg_field::
           type_id::create("cpha"));
      cpha.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cpha.set_original_access("RW");
      cpol =
          (dv_base_reg_field::
           type_id::create("cpol"));
      cpol.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cpol.set_original_access("RW");
    endfunction : build
  endclass : spi_host_reg_configopts

  class spi_host_reg_csid extends dv_base_reg;
    // fields
    rand dv_base_reg_field csid;

    `uvm_object_utils(spi_host_reg_csid)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      csid =
          (dv_base_reg_field::
           type_id::create("csid"));
      csid.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csid.set_original_access("RW");
    endfunction : build
  endclass : spi_host_reg_csid

  class spi_host_reg_command extends dv_base_reg;
    // fields
    rand dv_base_reg_field csaat;
    rand dv_base_reg_field speed;
    rand dv_base_reg_field direction;
    rand dv_base_reg_field len;

    `uvm_object_utils(spi_host_reg_command)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      csaat =
          (dv_base_reg_field::
           type_id::create("csaat"));
      csaat.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csaat.set_original_access("WO");
      speed =
          (dv_base_reg_field::
           type_id::create("speed"));
      speed.configure(
        .parent(this),
        .size(2),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      speed.set_original_access("WO");
      direction =
          (dv_base_reg_field::
           type_id::create("direction"));
      direction.configure(
        .parent(this),
        .size(2),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      direction.set_original_access("WO");
      len =
          (dv_base_reg_field::
           type_id::create("len"));
      len.configure(
        .parent(this),
        .size(20),
        .lsb_pos(5),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      len.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_host_reg_command

  class spi_host_reg_error_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmdbusy;
    rand dv_base_reg_field overflow;
    rand dv_base_reg_field underflow;
    rand dv_base_reg_field cmdinval;
    rand dv_base_reg_field csidinval;

    `uvm_object_utils(spi_host_reg_error_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmdbusy =
          (dv_base_reg_field::
           type_id::create("cmdbusy"));
      cmdbusy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdbusy.set_original_access("RW");
      overflow =
          (dv_base_reg_field::
           type_id::create("overflow"));
      overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      overflow.set_original_access("RW");
      underflow =
          (dv_base_reg_field::
           type_id::create("underflow"));
      underflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      underflow.set_original_access("RW");
      cmdinval =
          (dv_base_reg_field::
           type_id::create("cmdinval"));
      cmdinval.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdinval.set_original_access("RW");
      csidinval =
          (dv_base_reg_field::
           type_id::create("csidinval"));
      csidinval.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csidinval.set_original_access("RW");
    endfunction : build
  endclass : spi_host_reg_error_enable

  class spi_host_reg_error_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmdbusy;
    rand dv_base_reg_field overflow;
    rand dv_base_reg_field underflow;
    rand dv_base_reg_field cmdinval;
    rand dv_base_reg_field csidinval;
    rand dv_base_reg_field accessinval;

    `uvm_object_utils(spi_host_reg_error_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmdbusy =
          (dv_base_reg_field::
           type_id::create("cmdbusy"));
      cmdbusy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdbusy.set_original_access("W1C");
      overflow =
          (dv_base_reg_field::
           type_id::create("overflow"));
      overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      overflow.set_original_access("W1C");
      // create field tags
      csr_excl.add_excl(overflow.get_full_name(), CsrExclCheck, CsrAllTests);
      underflow =
          (dv_base_reg_field::
           type_id::create("underflow"));
      underflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      underflow.set_original_access("W1C");
      cmdinval =
          (dv_base_reg_field::
           type_id::create("cmdinval"));
      cmdinval.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdinval.set_original_access("W1C");
      csidinval =
          (dv_base_reg_field::
           type_id::create("csidinval"));
      csidinval.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csidinval.set_original_access("W1C");
      accessinval =
          (dv_base_reg_field::
           type_id::create("accessinval"));
      accessinval.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      accessinval.set_original_access("W1C");
      // create field tags
      csr_excl.add_excl(accessinval.get_full_name(), CsrExclCheck, CsrAllTests);
    endfunction : build
  endclass : spi_host_reg_error_status

  class spi_host_reg_event_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field rxfull;
    rand dv_base_reg_field txempty;
    rand dv_base_reg_field rxwm;
    rand dv_base_reg_field txwm;
    rand dv_base_reg_field ready;
    rand dv_base_reg_field idle;

    `uvm_object_utils(spi_host_reg_event_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rxfull =
          (dv_base_reg_field::
           type_id::create("rxfull"));
      rxfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxfull.set_original_access("RW");
      txempty =
          (dv_base_reg_field::
           type_id::create("txempty"));
      txempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txempty.set_original_access("RW");
      rxwm =
          (dv_base_reg_field::
           type_id::create("rxwm"));
      rxwm.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxwm.set_original_access("RW");
      txwm =
          (dv_base_reg_field::
           type_id::create("txwm"));
      txwm.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txwm.set_original_access("RW");
      ready =
          (dv_base_reg_field::
           type_id::create("ready"));
      ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ready.set_original_access("RW");
      idle =
          (dv_base_reg_field::
           type_id::create("idle"));
      idle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      idle.set_original_access("RW");
    endfunction : build
  endclass : spi_host_reg_event_enable

  class spi_host_mem_rxdata extends dv_base_mem;

    `uvm_object_utils(spi_host_mem_rxdata)

    function new(string           name = "",
                 longint unsigned size = 1,
                 int unsigned     n_bits = 32,
                 string           access = "RO",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
    endfunction : new

  endclass : spi_host_mem_rxdata


  class spi_host_mem_txdata extends dv_base_mem;

    `uvm_object_utils(spi_host_mem_txdata)

    function new(string           name = "",
                 longint unsigned size = 1,
                 int unsigned     n_bits = 32,
                 string           access = "WO",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
      set_mem_partial_write_support(1);
    endfunction : new

  endclass : spi_host_mem_txdata


  class spi_host_reg_block extends dv_base_reg_block;
    // registers
    rand spi_host_reg_intr_state intr_state;
    rand spi_host_reg_intr_enable intr_enable;
    rand spi_host_reg_intr_test intr_test;
    rand spi_host_reg_alert_test alert_test;
    rand spi_host_reg_control control;
    rand spi_host_reg_status status;
    rand spi_host_reg_configopts configopts;
    rand spi_host_reg_csid csid;
    rand spi_host_reg_command command;
    rand spi_host_reg_error_enable error_enable;
    rand spi_host_reg_error_status error_status;
    rand spi_host_reg_event_enable event_enable;
    // memories
    rand spi_host_mem_rxdata rxdata;
    rand spi_host_mem_txdata txdata;

    `uvm_object_utils(spi_host_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (spi_host_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_error.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_spi_event.q",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (spi_host_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_error.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_spi_event.q",
          1, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (spi_host_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_error.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_spi_event.qs",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (spi_host_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      control =
          (spi_host_reg_control::
           type_id::create("control"));
      control.configure(.blk_parent(this));
      control.build(csr_excl);
      default_map.add_reg(.rg(control),
                          .offset(32'h10));
      control.add_hdl_path_slice(
          "u_reg.u_control_rx_watermark.q",
          0, 8, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_reg.u_control_tx_watermark.q",
          8, 8, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_reg.u_control_output_en.q",
          29, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_reg.u_control_sw_rst.q",
          30, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_reg.u_control_spien.q",
          31, 1, 0, "BkdrRegPathRtl");

      status =
          (spi_host_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h14));
      status.add_hdl_path_slice(
          "u_reg.u_status_txqd.q",
          0, 8, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxqd.q",
          8, 8, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_cmdqd.q",
          16, 4, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxwm.q",
          20, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_byteorder.q",
          22, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxstall.q",
          23, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxempty.q",
          24, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxfull.q",
          25, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_txwm.q",
          26, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_txstall.q",
          27, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_txempty.q",
          28, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_txfull.q",
          29, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_active.q",
          30, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_ready.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(status.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      configopts =
          (spi_host_reg_configopts::
           type_id::create("configopts"));
      configopts.configure(.blk_parent(this));
      configopts.build(csr_excl);
      default_map.add_reg(.rg(configopts),
                          .offset(32'h18));
      configopts.add_hdl_path_slice(
          "u_reg.u_configopts_clkdiv.q",
          0, 16, 0, "BkdrRegPathRtl");
      configopts.add_hdl_path_slice(
          "u_reg.u_configopts_csnidle.q",
          16, 4, 0, "BkdrRegPathRtl");
      configopts.add_hdl_path_slice(
          "u_reg.u_configopts_csntrail.q",
          20, 4, 0, "BkdrRegPathRtl");
      configopts.add_hdl_path_slice(
          "u_reg.u_configopts_csnlead.q",
          24, 4, 0, "BkdrRegPathRtl");
      configopts.add_hdl_path_slice(
          "u_reg.u_configopts_fullcyc.q",
          29, 1, 0, "BkdrRegPathRtl");
      configopts.add_hdl_path_slice(
          "u_reg.u_configopts_cpha.q",
          30, 1, 0, "BkdrRegPathRtl");
      configopts.add_hdl_path_slice(
          "u_reg.u_configopts_cpol.q",
          31, 1, 0, "BkdrRegPathRtl");

      csid =
          (spi_host_reg_csid::
           type_id::create("csid"));
      csid.configure(.blk_parent(this));
      csid.build(csr_excl);
      default_map.add_reg(.rg(csid),
                          .offset(32'h1c));
      csid.add_hdl_path_slice(
          "u_reg.u_csid.q",
          0, 32, 0, "BkdrRegPathRtl");

      command =
          (spi_host_reg_command::
           type_id::create("command"));
      command.configure(.blk_parent(this));
      command.build(csr_excl);
      default_map.add_reg(.rg(command),
                          .offset(32'h20));
      command.add_hdl_path_slice(
          "u_reg.u_command_csaat.qs",
          0, 1, 0, "BkdrRegPathRtl");
      command.add_hdl_path_slice(
          "u_reg.u_command_speed.qs",
          1, 2, 0, "BkdrRegPathRtl");
      command.add_hdl_path_slice(
          "u_reg.u_command_direction.qs",
          3, 2, 0, "BkdrRegPathRtl");
      command.add_hdl_path_slice(
          "u_reg.u_command_len.qs",
          5, 20, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(command.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      error_enable =
          (spi_host_reg_error_enable::
           type_id::create("error_enable"));
      error_enable.configure(.blk_parent(this));
      error_enable.build(csr_excl);
      default_map.add_reg(.rg(error_enable),
                          .offset(32'h2c));
      error_enable.add_hdl_path_slice(
          "u_reg.u_error_enable_cmdbusy.q",
          0, 1, 0, "BkdrRegPathRtl");
      error_enable.add_hdl_path_slice(
          "u_reg.u_error_enable_overflow.q",
          1, 1, 0, "BkdrRegPathRtl");
      error_enable.add_hdl_path_slice(
          "u_reg.u_error_enable_underflow.q",
          2, 1, 0, "BkdrRegPathRtl");
      error_enable.add_hdl_path_slice(
          "u_reg.u_error_enable_cmdinval.q",
          3, 1, 0, "BkdrRegPathRtl");
      error_enable.add_hdl_path_slice(
          "u_reg.u_error_enable_csidinval.q",
          4, 1, 0, "BkdrRegPathRtl");

      error_status =
          (spi_host_reg_error_status::
           type_id::create("error_status"));
      error_status.configure(.blk_parent(this));
      error_status.build(csr_excl);
      default_map.add_reg(.rg(error_status),
                          .offset(32'h30));
      error_status.add_hdl_path_slice(
          "u_reg.u_error_status_cmdbusy.q",
          0, 1, 0, "BkdrRegPathRtl");
      error_status.add_hdl_path_slice(
          "u_reg.u_error_status_overflow.q",
          1, 1, 0, "BkdrRegPathRtl");
      error_status.add_hdl_path_slice(
          "u_reg.u_error_status_underflow.q",
          2, 1, 0, "BkdrRegPathRtl");
      error_status.add_hdl_path_slice(
          "u_reg.u_error_status_cmdinval.q",
          3, 1, 0, "BkdrRegPathRtl");
      error_status.add_hdl_path_slice(
          "u_reg.u_error_status_csidinval.q",
          4, 1, 0, "BkdrRegPathRtl");
      error_status.add_hdl_path_slice(
          "u_reg.u_error_status_accessinval.q",
          5, 1, 0, "BkdrRegPathRtl");

      event_enable =
          (spi_host_reg_event_enable::
           type_id::create("event_enable"));
      event_enable.configure(.blk_parent(this));
      event_enable.build(csr_excl);
      default_map.add_reg(.rg(event_enable),
                          .offset(32'h34));
      event_enable.add_hdl_path_slice(
          "u_reg.u_event_enable_rxfull.q",
          0, 1, 0, "BkdrRegPathRtl");
      event_enable.add_hdl_path_slice(
          "u_reg.u_event_enable_txempty.q",
          1, 1, 0, "BkdrRegPathRtl");
      event_enable.add_hdl_path_slice(
          "u_reg.u_event_enable_rxwm.q",
          2, 1, 0, "BkdrRegPathRtl");
      event_enable.add_hdl_path_slice(
          "u_reg.u_event_enable_txwm.q",
          3, 1, 0, "BkdrRegPathRtl");
      event_enable.add_hdl_path_slice(
          "u_reg.u_event_enable_ready.q",
          4, 1, 0, "BkdrRegPathRtl");
      event_enable.add_hdl_path_slice(
          "u_reg.u_event_enable_idle.q",
          5, 1, 0, "BkdrRegPathRtl");


      // create memories
      rxdata =
          spi_host_mem_rxdata::type_id::create("rxdata");
      rxdata.configure(.parent(this));
      default_map.add_mem(.mem(rxdata),
                          .offset(32'h24),
                          .rights("RO"));
      txdata =
          spi_host_mem_txdata::type_id::create("txdata");
      txdata.configure(.parent(this));
      default_map.add_mem(.mem(txdata),
                          .offset(32'h28),
                          .rights("WO"));


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : spi_host_reg_block

endpackage

