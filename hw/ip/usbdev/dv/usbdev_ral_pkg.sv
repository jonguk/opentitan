// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package usbdev_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class usbdev_reg_intr_state;
  typedef class usbdev_reg_intr_enable;
  typedef class usbdev_reg_intr_test;
  typedef class usbdev_reg_alert_test;
  typedef class usbdev_reg_usbctrl;
  typedef class usbdev_reg_ep_out_enable;
  typedef class usbdev_reg_ep_in_enable;
  typedef class usbdev_reg_usbstat;
  typedef class usbdev_reg_avoutbuffer;
  typedef class usbdev_reg_avsetupbuffer;
  typedef class usbdev_reg_rxfifo;
  typedef class usbdev_reg_rxenable_setup;
  typedef class usbdev_reg_rxenable_out;
  typedef class usbdev_reg_set_nak_out;
  typedef class usbdev_reg_in_sent;
  typedef class usbdev_reg_out_stall;
  typedef class usbdev_reg_in_stall;
  typedef class usbdev_reg_configin;
  typedef class usbdev_reg_out_iso;
  typedef class usbdev_reg_in_iso;
  typedef class usbdev_reg_out_data_toggle;
  typedef class usbdev_reg_in_data_toggle;
  typedef class usbdev_reg_phy_pins_sense;
  typedef class usbdev_reg_phy_pins_drive;
  typedef class usbdev_reg_phy_config;
  typedef class usbdev_reg_wake_control;
  typedef class usbdev_reg_wake_events;
  typedef class usbdev_reg_fifo_ctrl;
  typedef class usbdev_reg_count_out;
  typedef class usbdev_reg_count_in;
  typedef class usbdev_reg_count_nodata_in;
  typedef class usbdev_reg_count_errors;
  typedef class usbdev_mem_buffer;
  typedef class usbdev_reg_block;

  class usbdev_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field pkt_received;
    rand dv_base_reg_field pkt_sent;
    rand dv_base_reg_field disconnected;
    rand dv_base_reg_field host_lost;
    rand dv_base_reg_field link_reset;
    rand dv_base_reg_field link_suspend;
    rand dv_base_reg_field link_resume;
    rand dv_base_reg_field av_out_empty;
    rand dv_base_reg_field rx_full;
    rand dv_base_reg_field av_overflow;
    rand dv_base_reg_field link_in_err;
    rand dv_base_reg_field rx_crc_err;
    rand dv_base_reg_field rx_pid_err;
    rand dv_base_reg_field rx_bitstuff_err;
    rand dv_base_reg_field frame;
    rand dv_base_reg_field powered;
    rand dv_base_reg_field link_out_err;
    rand dv_base_reg_field av_setup_empty;

    `uvm_object_utils(usbdev_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      pkt_received =
          (dv_base_reg_field::
           type_id::create("pkt_received"));
      pkt_received.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pkt_received.set_original_access("RO");
      pkt_sent =
          (dv_base_reg_field::
           type_id::create("pkt_sent"));
      pkt_sent.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pkt_sent.set_original_access("RO");
      disconnected =
          (dv_base_reg_field::
           type_id::create("disconnected"));
      disconnected.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      disconnected.set_original_access("W1C");
      host_lost =
          (dv_base_reg_field::
           type_id::create("host_lost"));
      host_lost.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      host_lost.set_original_access("W1C");
      link_reset =
          (dv_base_reg_field::
           type_id::create("link_reset"));
      link_reset.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_reset.set_original_access("W1C");
      link_suspend =
          (dv_base_reg_field::
           type_id::create("link_suspend"));
      link_suspend.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_suspend.set_original_access("W1C");
      link_resume =
          (dv_base_reg_field::
           type_id::create("link_resume"));
      link_resume.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_resume.set_original_access("W1C");
      av_out_empty =
          (dv_base_reg_field::
           type_id::create("av_out_empty"));
      av_out_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_out_empty.set_original_access("RO");
      rx_full =
          (dv_base_reg_field::
           type_id::create("rx_full"));
      rx_full.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_full.set_original_access("RO");
      av_overflow =
          (dv_base_reg_field::
           type_id::create("av_overflow"));
      av_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_overflow.set_original_access("W1C");
      link_in_err =
          (dv_base_reg_field::
           type_id::create("link_in_err"));
      link_in_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_in_err.set_original_access("W1C");
      rx_crc_err =
          (dv_base_reg_field::
           type_id::create("rx_crc_err"));
      rx_crc_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_crc_err.set_original_access("W1C");
      rx_pid_err =
          (dv_base_reg_field::
           type_id::create("rx_pid_err"));
      rx_pid_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_pid_err.set_original_access("W1C");
      rx_bitstuff_err =
          (dv_base_reg_field::
           type_id::create("rx_bitstuff_err"));
      rx_bitstuff_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_bitstuff_err.set_original_access("W1C");
      frame =
          (dv_base_reg_field::
           type_id::create("frame"));
      frame.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      frame.set_original_access("W1C");
      powered =
          (dv_base_reg_field::
           type_id::create("powered"));
      powered.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      powered.set_original_access("W1C");
      link_out_err =
          (dv_base_reg_field::
           type_id::create("link_out_err"));
      link_out_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_out_err.set_original_access("W1C");
      av_setup_empty =
          (dv_base_reg_field::
           type_id::create("av_setup_empty"));
      av_setup_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_setup_empty.set_original_access("RO");
    endfunction : build
  endclass : usbdev_reg_intr_state

  class usbdev_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field pkt_received;
    rand dv_base_reg_field pkt_sent;
    rand dv_base_reg_field disconnected;
    rand dv_base_reg_field host_lost;
    rand dv_base_reg_field link_reset;
    rand dv_base_reg_field link_suspend;
    rand dv_base_reg_field link_resume;
    rand dv_base_reg_field av_out_empty;
    rand dv_base_reg_field rx_full;
    rand dv_base_reg_field av_overflow;
    rand dv_base_reg_field link_in_err;
    rand dv_base_reg_field rx_crc_err;
    rand dv_base_reg_field rx_pid_err;
    rand dv_base_reg_field rx_bitstuff_err;
    rand dv_base_reg_field frame;
    rand dv_base_reg_field powered;
    rand dv_base_reg_field link_out_err;
    rand dv_base_reg_field av_setup_empty;

    `uvm_object_utils(usbdev_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      pkt_received =
          (dv_base_reg_field::
           type_id::create("pkt_received"));
      pkt_received.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pkt_received.set_original_access("RW");
      pkt_sent =
          (dv_base_reg_field::
           type_id::create("pkt_sent"));
      pkt_sent.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pkt_sent.set_original_access("RW");
      disconnected =
          (dv_base_reg_field::
           type_id::create("disconnected"));
      disconnected.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      disconnected.set_original_access("RW");
      host_lost =
          (dv_base_reg_field::
           type_id::create("host_lost"));
      host_lost.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      host_lost.set_original_access("RW");
      link_reset =
          (dv_base_reg_field::
           type_id::create("link_reset"));
      link_reset.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_reset.set_original_access("RW");
      link_suspend =
          (dv_base_reg_field::
           type_id::create("link_suspend"));
      link_suspend.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_suspend.set_original_access("RW");
      link_resume =
          (dv_base_reg_field::
           type_id::create("link_resume"));
      link_resume.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_resume.set_original_access("RW");
      av_out_empty =
          (dv_base_reg_field::
           type_id::create("av_out_empty"));
      av_out_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_out_empty.set_original_access("RW");
      rx_full =
          (dv_base_reg_field::
           type_id::create("rx_full"));
      rx_full.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_full.set_original_access("RW");
      av_overflow =
          (dv_base_reg_field::
           type_id::create("av_overflow"));
      av_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_overflow.set_original_access("RW");
      link_in_err =
          (dv_base_reg_field::
           type_id::create("link_in_err"));
      link_in_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_in_err.set_original_access("RW");
      rx_crc_err =
          (dv_base_reg_field::
           type_id::create("rx_crc_err"));
      rx_crc_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_crc_err.set_original_access("RW");
      rx_pid_err =
          (dv_base_reg_field::
           type_id::create("rx_pid_err"));
      rx_pid_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_pid_err.set_original_access("RW");
      rx_bitstuff_err =
          (dv_base_reg_field::
           type_id::create("rx_bitstuff_err"));
      rx_bitstuff_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_bitstuff_err.set_original_access("RW");
      frame =
          (dv_base_reg_field::
           type_id::create("frame"));
      frame.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      frame.set_original_access("RW");
      powered =
          (dv_base_reg_field::
           type_id::create("powered"));
      powered.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      powered.set_original_access("RW");
      link_out_err =
          (dv_base_reg_field::
           type_id::create("link_out_err"));
      link_out_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_out_err.set_original_access("RW");
      av_setup_empty =
          (dv_base_reg_field::
           type_id::create("av_setup_empty"));
      av_setup_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_setup_empty.set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_intr_enable

  class usbdev_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field pkt_received;
    rand dv_base_reg_field pkt_sent;
    rand dv_base_reg_field disconnected;
    rand dv_base_reg_field host_lost;
    rand dv_base_reg_field link_reset;
    rand dv_base_reg_field link_suspend;
    rand dv_base_reg_field link_resume;
    rand dv_base_reg_field av_out_empty;
    rand dv_base_reg_field rx_full;
    rand dv_base_reg_field av_overflow;
    rand dv_base_reg_field link_in_err;
    rand dv_base_reg_field rx_crc_err;
    rand dv_base_reg_field rx_pid_err;
    rand dv_base_reg_field rx_bitstuff_err;
    rand dv_base_reg_field frame;
    rand dv_base_reg_field powered;
    rand dv_base_reg_field link_out_err;
    rand dv_base_reg_field av_setup_empty;

    `uvm_object_utils(usbdev_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      pkt_received =
          (dv_base_reg_field::
           type_id::create("pkt_received"));
      pkt_received.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pkt_received.set_original_access("WO");
      pkt_sent =
          (dv_base_reg_field::
           type_id::create("pkt_sent"));
      pkt_sent.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pkt_sent.set_original_access("WO");
      disconnected =
          (dv_base_reg_field::
           type_id::create("disconnected"));
      disconnected.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      disconnected.set_original_access("WO");
      host_lost =
          (dv_base_reg_field::
           type_id::create("host_lost"));
      host_lost.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      host_lost.set_original_access("WO");
      link_reset =
          (dv_base_reg_field::
           type_id::create("link_reset"));
      link_reset.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_reset.set_original_access("WO");
      link_suspend =
          (dv_base_reg_field::
           type_id::create("link_suspend"));
      link_suspend.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_suspend.set_original_access("WO");
      link_resume =
          (dv_base_reg_field::
           type_id::create("link_resume"));
      link_resume.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_resume.set_original_access("WO");
      av_out_empty =
          (dv_base_reg_field::
           type_id::create("av_out_empty"));
      av_out_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_out_empty.set_original_access("WO");
      rx_full =
          (dv_base_reg_field::
           type_id::create("rx_full"));
      rx_full.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_full.set_original_access("WO");
      av_overflow =
          (dv_base_reg_field::
           type_id::create("av_overflow"));
      av_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_overflow.set_original_access("WO");
      link_in_err =
          (dv_base_reg_field::
           type_id::create("link_in_err"));
      link_in_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_in_err.set_original_access("WO");
      rx_crc_err =
          (dv_base_reg_field::
           type_id::create("rx_crc_err"));
      rx_crc_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_crc_err.set_original_access("WO");
      rx_pid_err =
          (dv_base_reg_field::
           type_id::create("rx_pid_err"));
      rx_pid_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_pid_err.set_original_access("WO");
      rx_bitstuff_err =
          (dv_base_reg_field::
           type_id::create("rx_bitstuff_err"));
      rx_bitstuff_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_bitstuff_err.set_original_access("WO");
      frame =
          (dv_base_reg_field::
           type_id::create("frame"));
      frame.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      frame.set_original_access("WO");
      powered =
          (dv_base_reg_field::
           type_id::create("powered"));
      powered.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      powered.set_original_access("WO");
      link_out_err =
          (dv_base_reg_field::
           type_id::create("link_out_err"));
      link_out_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_out_err.set_original_access("WO");
      av_setup_empty =
          (dv_base_reg_field::
           type_id::create("av_setup_empty"));
      av_setup_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_setup_empty.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_intr_test

  class usbdev_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(usbdev_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_alert_test

  class usbdev_reg_usbctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable;
    rand dv_base_reg_field resume_link_active;
    rand dv_base_reg_field device_address;

    `uvm_object_utils(usbdev_reg_usbctrl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable =
          (dv_base_reg_field::
           type_id::create("enable"));
      enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(enable.get_full_name(), CsrExclWrite, CsrNonInitTests);
      resume_link_active =
          (dv_base_reg_field::
           type_id::create("resume_link_active"));
      resume_link_active.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      resume_link_active.set_original_access("WO");
      device_address =
          (dv_base_reg_field::
           type_id::create("device_address"));
      device_address.configure(
        .parent(this),
        .size(7),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      device_address.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(device_address.get_full_name(), CsrExclWriteCheck, CsrNonInitTests);
    endfunction : build
  endclass : usbdev_reg_usbctrl

  class usbdev_reg_ep_out_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable[12];

    `uvm_object_utils(usbdev_reg_ep_out_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable[0] =
          (dv_base_reg_field::
           type_id::create("enable_0"));
      enable[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[0].set_original_access("RW");
      enable[1] =
          (dv_base_reg_field::
           type_id::create("enable_1"));
      enable[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[1].set_original_access("RW");
      enable[2] =
          (dv_base_reg_field::
           type_id::create("enable_2"));
      enable[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[2].set_original_access("RW");
      enable[3] =
          (dv_base_reg_field::
           type_id::create("enable_3"));
      enable[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[3].set_original_access("RW");
      enable[4] =
          (dv_base_reg_field::
           type_id::create("enable_4"));
      enable[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[4].set_original_access("RW");
      enable[5] =
          (dv_base_reg_field::
           type_id::create("enable_5"));
      enable[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[5].set_original_access("RW");
      enable[6] =
          (dv_base_reg_field::
           type_id::create("enable_6"));
      enable[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[6].set_original_access("RW");
      enable[7] =
          (dv_base_reg_field::
           type_id::create("enable_7"));
      enable[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[7].set_original_access("RW");
      enable[8] =
          (dv_base_reg_field::
           type_id::create("enable_8"));
      enable[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[8].set_original_access("RW");
      enable[9] =
          (dv_base_reg_field::
           type_id::create("enable_9"));
      enable[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[9].set_original_access("RW");
      enable[10] =
          (dv_base_reg_field::
           type_id::create("enable_10"));
      enable[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[10].set_original_access("RW");
      enable[11] =
          (dv_base_reg_field::
           type_id::create("enable_11"));
      enable[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[11].set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_ep_out_enable

  class usbdev_reg_ep_in_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable[12];

    `uvm_object_utils(usbdev_reg_ep_in_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable[0] =
          (dv_base_reg_field::
           type_id::create("enable_0"));
      enable[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[0].set_original_access("RW");
      enable[1] =
          (dv_base_reg_field::
           type_id::create("enable_1"));
      enable[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[1].set_original_access("RW");
      enable[2] =
          (dv_base_reg_field::
           type_id::create("enable_2"));
      enable[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[2].set_original_access("RW");
      enable[3] =
          (dv_base_reg_field::
           type_id::create("enable_3"));
      enable[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[3].set_original_access("RW");
      enable[4] =
          (dv_base_reg_field::
           type_id::create("enable_4"));
      enable[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[4].set_original_access("RW");
      enable[5] =
          (dv_base_reg_field::
           type_id::create("enable_5"));
      enable[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[5].set_original_access("RW");
      enable[6] =
          (dv_base_reg_field::
           type_id::create("enable_6"));
      enable[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[6].set_original_access("RW");
      enable[7] =
          (dv_base_reg_field::
           type_id::create("enable_7"));
      enable[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[7].set_original_access("RW");
      enable[8] =
          (dv_base_reg_field::
           type_id::create("enable_8"));
      enable[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[8].set_original_access("RW");
      enable[9] =
          (dv_base_reg_field::
           type_id::create("enable_9"));
      enable[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[9].set_original_access("RW");
      enable[10] =
          (dv_base_reg_field::
           type_id::create("enable_10"));
      enable[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[10].set_original_access("RW");
      enable[11] =
          (dv_base_reg_field::
           type_id::create("enable_11"));
      enable[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[11].set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_ep_in_enable

  class usbdev_reg_usbstat extends dv_base_reg;
    // fields
    rand dv_base_reg_field frame;
    rand dv_base_reg_field host_lost;
    rand dv_base_reg_field link_state;
    rand dv_base_reg_field sense;
    rand dv_base_reg_field av_out_depth;
    rand dv_base_reg_field av_setup_depth;
    rand dv_base_reg_field av_out_full;
    rand dv_base_reg_field rx_depth;
    rand dv_base_reg_field av_setup_full;
    rand dv_base_reg_field rx_empty;

    `uvm_object_utils(usbdev_reg_usbstat)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      frame =
          (dv_base_reg_field::
           type_id::create("frame"));
      frame.configure(
        .parent(this),
        .size(11),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      frame.set_original_access("RO");
      host_lost =
          (dv_base_reg_field::
           type_id::create("host_lost"));
      host_lost.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      host_lost.set_original_access("RO");
      link_state =
          (dv_base_reg_field::
           type_id::create("link_state"));
      link_state.configure(
        .parent(this),
        .size(3),
        .lsb_pos(12),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      link_state.set_original_access("RO");
      sense =
          (dv_base_reg_field::
           type_id::create("sense"));
      sense.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sense.set_original_access("RO");
      av_out_depth =
          (dv_base_reg_field::
           type_id::create("av_out_depth"));
      av_out_depth.configure(
        .parent(this),
        .size(4),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_out_depth.set_original_access("RO");
      av_setup_depth =
          (dv_base_reg_field::
           type_id::create("av_setup_depth"));
      av_setup_depth.configure(
        .parent(this),
        .size(3),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_setup_depth.set_original_access("RO");
      av_out_full =
          (dv_base_reg_field::
           type_id::create("av_out_full"));
      av_out_full.configure(
        .parent(this),
        .size(1),
        .lsb_pos(23),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_out_full.set_original_access("RO");
      rx_depth =
          (dv_base_reg_field::
           type_id::create("rx_depth"));
      rx_depth.configure(
        .parent(this),
        .size(4),
        .lsb_pos(24),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_depth.set_original_access("RO");
      av_setup_full =
          (dv_base_reg_field::
           type_id::create("av_setup_full"));
      av_setup_full.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      av_setup_full.set_original_access("RO");
      rx_empty =
          (dv_base_reg_field::
           type_id::create("rx_empty"));
      rx_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_empty.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_usbstat

  class usbdev_reg_avoutbuffer extends dv_base_reg;
    // fields
    rand dv_base_reg_field buffer;

    `uvm_object_utils(usbdev_reg_avoutbuffer)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      buffer =
          (dv_base_reg_field::
           type_id::create("buffer"));
      buffer.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      buffer.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_avoutbuffer

  class usbdev_reg_avsetupbuffer extends dv_base_reg;
    // fields
    rand dv_base_reg_field buffer;

    `uvm_object_utils(usbdev_reg_avsetupbuffer)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      buffer =
          (dv_base_reg_field::
           type_id::create("buffer"));
      buffer.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      buffer.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_avsetupbuffer

  class usbdev_reg_rxfifo extends dv_base_reg;
    // fields
    rand dv_base_reg_field buffer;
    rand dv_base_reg_field size;
    rand dv_base_reg_field setup;
    rand dv_base_reg_field ep;

    `uvm_object_utils(usbdev_reg_rxfifo)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      buffer =
          (dv_base_reg_field::
           type_id::create("buffer"));
      buffer.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      buffer.set_original_access("RO");
      size =
          (dv_base_reg_field::
           type_id::create("size"));
      size.configure(
        .parent(this),
        .size(7),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      size.set_original_access("RO");
      setup =
          (dv_base_reg_field::
           type_id::create("setup"));
      setup.configure(
        .parent(this),
        .size(1),
        .lsb_pos(19),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup.set_original_access("RO");
      ep =
          (dv_base_reg_field::
           type_id::create("ep"));
      ep.configure(
        .parent(this),
        .size(4),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ep.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_rxfifo

  class usbdev_reg_rxenable_setup extends dv_base_reg;
    // fields
    rand dv_base_reg_field setup[12];

    `uvm_object_utils(usbdev_reg_rxenable_setup)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      setup[0] =
          (dv_base_reg_field::
           type_id::create("setup_0"));
      setup[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[0].set_original_access("RW");
      setup[1] =
          (dv_base_reg_field::
           type_id::create("setup_1"));
      setup[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[1].set_original_access("RW");
      setup[2] =
          (dv_base_reg_field::
           type_id::create("setup_2"));
      setup[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[2].set_original_access("RW");
      setup[3] =
          (dv_base_reg_field::
           type_id::create("setup_3"));
      setup[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[3].set_original_access("RW");
      setup[4] =
          (dv_base_reg_field::
           type_id::create("setup_4"));
      setup[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[4].set_original_access("RW");
      setup[5] =
          (dv_base_reg_field::
           type_id::create("setup_5"));
      setup[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[5].set_original_access("RW");
      setup[6] =
          (dv_base_reg_field::
           type_id::create("setup_6"));
      setup[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[6].set_original_access("RW");
      setup[7] =
          (dv_base_reg_field::
           type_id::create("setup_7"));
      setup[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[7].set_original_access("RW");
      setup[8] =
          (dv_base_reg_field::
           type_id::create("setup_8"));
      setup[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[8].set_original_access("RW");
      setup[9] =
          (dv_base_reg_field::
           type_id::create("setup_9"));
      setup[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[9].set_original_access("RW");
      setup[10] =
          (dv_base_reg_field::
           type_id::create("setup_10"));
      setup[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[10].set_original_access("RW");
      setup[11] =
          (dv_base_reg_field::
           type_id::create("setup_11"));
      setup[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      setup[11].set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_rxenable_setup

  class usbdev_reg_rxenable_out extends dv_base_reg;
    // fields
    rand dv_base_reg_field out;
    rand dv_base_reg_field preserve;

    `uvm_object_utils(usbdev_reg_rxenable_out)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      out =
          (dv_base_reg_field::
           type_id::create("out"));
      out.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      out.set_original_access("RW");
      preserve =
          (dv_base_reg_field::
           type_id::create("preserve"));
      preserve.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      preserve.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_rxenable_out

  class usbdev_reg_set_nak_out extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable[12];

    `uvm_object_utils(usbdev_reg_set_nak_out)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable[0] =
          (dv_base_reg_field::
           type_id::create("enable_0"));
      enable[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[0].set_original_access("RW");
      enable[1] =
          (dv_base_reg_field::
           type_id::create("enable_1"));
      enable[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[1].set_original_access("RW");
      enable[2] =
          (dv_base_reg_field::
           type_id::create("enable_2"));
      enable[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[2].set_original_access("RW");
      enable[3] =
          (dv_base_reg_field::
           type_id::create("enable_3"));
      enable[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[3].set_original_access("RW");
      enable[4] =
          (dv_base_reg_field::
           type_id::create("enable_4"));
      enable[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[4].set_original_access("RW");
      enable[5] =
          (dv_base_reg_field::
           type_id::create("enable_5"));
      enable[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[5].set_original_access("RW");
      enable[6] =
          (dv_base_reg_field::
           type_id::create("enable_6"));
      enable[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[6].set_original_access("RW");
      enable[7] =
          (dv_base_reg_field::
           type_id::create("enable_7"));
      enable[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[7].set_original_access("RW");
      enable[8] =
          (dv_base_reg_field::
           type_id::create("enable_8"));
      enable[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[8].set_original_access("RW");
      enable[9] =
          (dv_base_reg_field::
           type_id::create("enable_9"));
      enable[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[9].set_original_access("RW");
      enable[10] =
          (dv_base_reg_field::
           type_id::create("enable_10"));
      enable[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[10].set_original_access("RW");
      enable[11] =
          (dv_base_reg_field::
           type_id::create("enable_11"));
      enable[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable[11].set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_set_nak_out

  class usbdev_reg_in_sent extends dv_base_reg;
    // fields
    rand dv_base_reg_field sent[12];

    `uvm_object_utils(usbdev_reg_in_sent)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      sent[0] =
          (dv_base_reg_field::
           type_id::create("sent_0"));
      sent[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[0].set_original_access("W1C");
      sent[1] =
          (dv_base_reg_field::
           type_id::create("sent_1"));
      sent[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[1].set_original_access("W1C");
      sent[2] =
          (dv_base_reg_field::
           type_id::create("sent_2"));
      sent[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[2].set_original_access("W1C");
      sent[3] =
          (dv_base_reg_field::
           type_id::create("sent_3"));
      sent[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[3].set_original_access("W1C");
      sent[4] =
          (dv_base_reg_field::
           type_id::create("sent_4"));
      sent[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[4].set_original_access("W1C");
      sent[5] =
          (dv_base_reg_field::
           type_id::create("sent_5"));
      sent[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[5].set_original_access("W1C");
      sent[6] =
          (dv_base_reg_field::
           type_id::create("sent_6"));
      sent[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[6].set_original_access("W1C");
      sent[7] =
          (dv_base_reg_field::
           type_id::create("sent_7"));
      sent[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[7].set_original_access("W1C");
      sent[8] =
          (dv_base_reg_field::
           type_id::create("sent_8"));
      sent[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[8].set_original_access("W1C");
      sent[9] =
          (dv_base_reg_field::
           type_id::create("sent_9"));
      sent[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[9].set_original_access("W1C");
      sent[10] =
          (dv_base_reg_field::
           type_id::create("sent_10"));
      sent[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[10].set_original_access("W1C");
      sent[11] =
          (dv_base_reg_field::
           type_id::create("sent_11"));
      sent[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sent[11].set_original_access("W1C");
    endfunction : build
  endclass : usbdev_reg_in_sent

  class usbdev_reg_out_stall extends dv_base_reg;
    // fields
    rand dv_base_reg_field endpoint[12];

    `uvm_object_utils(usbdev_reg_out_stall)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      endpoint[0] =
          (dv_base_reg_field::
           type_id::create("endpoint_0"));
      endpoint[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[0].set_original_access("RW");
      endpoint[1] =
          (dv_base_reg_field::
           type_id::create("endpoint_1"));
      endpoint[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[1].set_original_access("RW");
      endpoint[2] =
          (dv_base_reg_field::
           type_id::create("endpoint_2"));
      endpoint[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[2].set_original_access("RW");
      endpoint[3] =
          (dv_base_reg_field::
           type_id::create("endpoint_3"));
      endpoint[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[3].set_original_access("RW");
      endpoint[4] =
          (dv_base_reg_field::
           type_id::create("endpoint_4"));
      endpoint[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[4].set_original_access("RW");
      endpoint[5] =
          (dv_base_reg_field::
           type_id::create("endpoint_5"));
      endpoint[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[5].set_original_access("RW");
      endpoint[6] =
          (dv_base_reg_field::
           type_id::create("endpoint_6"));
      endpoint[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[6].set_original_access("RW");
      endpoint[7] =
          (dv_base_reg_field::
           type_id::create("endpoint_7"));
      endpoint[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[7].set_original_access("RW");
      endpoint[8] =
          (dv_base_reg_field::
           type_id::create("endpoint_8"));
      endpoint[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[8].set_original_access("RW");
      endpoint[9] =
          (dv_base_reg_field::
           type_id::create("endpoint_9"));
      endpoint[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[9].set_original_access("RW");
      endpoint[10] =
          (dv_base_reg_field::
           type_id::create("endpoint_10"));
      endpoint[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[10].set_original_access("RW");
      endpoint[11] =
          (dv_base_reg_field::
           type_id::create("endpoint_11"));
      endpoint[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[11].set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_out_stall

  class usbdev_reg_in_stall extends dv_base_reg;
    // fields
    rand dv_base_reg_field endpoint[12];

    `uvm_object_utils(usbdev_reg_in_stall)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      endpoint[0] =
          (dv_base_reg_field::
           type_id::create("endpoint_0"));
      endpoint[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[0].set_original_access("RW");
      endpoint[1] =
          (dv_base_reg_field::
           type_id::create("endpoint_1"));
      endpoint[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[1].set_original_access("RW");
      endpoint[2] =
          (dv_base_reg_field::
           type_id::create("endpoint_2"));
      endpoint[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[2].set_original_access("RW");
      endpoint[3] =
          (dv_base_reg_field::
           type_id::create("endpoint_3"));
      endpoint[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[3].set_original_access("RW");
      endpoint[4] =
          (dv_base_reg_field::
           type_id::create("endpoint_4"));
      endpoint[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[4].set_original_access("RW");
      endpoint[5] =
          (dv_base_reg_field::
           type_id::create("endpoint_5"));
      endpoint[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[5].set_original_access("RW");
      endpoint[6] =
          (dv_base_reg_field::
           type_id::create("endpoint_6"));
      endpoint[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[6].set_original_access("RW");
      endpoint[7] =
          (dv_base_reg_field::
           type_id::create("endpoint_7"));
      endpoint[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[7].set_original_access("RW");
      endpoint[8] =
          (dv_base_reg_field::
           type_id::create("endpoint_8"));
      endpoint[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[8].set_original_access("RW");
      endpoint[9] =
          (dv_base_reg_field::
           type_id::create("endpoint_9"));
      endpoint[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[9].set_original_access("RW");
      endpoint[10] =
          (dv_base_reg_field::
           type_id::create("endpoint_10"));
      endpoint[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[10].set_original_access("RW");
      endpoint[11] =
          (dv_base_reg_field::
           type_id::create("endpoint_11"));
      endpoint[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoint[11].set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_in_stall

  class usbdev_reg_configin extends dv_base_reg;
    // fields
    rand dv_base_reg_field buffer;
    rand dv_base_reg_field size;
    rand dv_base_reg_field sending;
    rand dv_base_reg_field pend;
    rand dv_base_reg_field rdy;

    `uvm_object_utils(usbdev_reg_configin)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      buffer =
          (dv_base_reg_field::
           type_id::create("buffer"));
      buffer.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      buffer.set_original_access("RW");
      size =
          (dv_base_reg_field::
           type_id::create("size"));
      size.configure(
        .parent(this),
        .size(7),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      size.set_original_access("RW");
      sending =
          (dv_base_reg_field::
           type_id::create("sending"));
      sending.configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sending.set_original_access("W1C");
      pend =
          (dv_base_reg_field::
           type_id::create("pend"));
      pend.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pend.set_original_access("W1C");
      rdy =
          (dv_base_reg_field::
           type_id::create("rdy"));
      rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rdy.set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_configin

  class usbdev_reg_out_iso extends dv_base_reg;
    // fields
    rand dv_base_reg_field iso[12];

    `uvm_object_utils(usbdev_reg_out_iso)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      iso[0] =
          (dv_base_reg_field::
           type_id::create("iso_0"));
      iso[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[0].set_original_access("RW");
      iso[1] =
          (dv_base_reg_field::
           type_id::create("iso_1"));
      iso[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[1].set_original_access("RW");
      iso[2] =
          (dv_base_reg_field::
           type_id::create("iso_2"));
      iso[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[2].set_original_access("RW");
      iso[3] =
          (dv_base_reg_field::
           type_id::create("iso_3"));
      iso[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[3].set_original_access("RW");
      iso[4] =
          (dv_base_reg_field::
           type_id::create("iso_4"));
      iso[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[4].set_original_access("RW");
      iso[5] =
          (dv_base_reg_field::
           type_id::create("iso_5"));
      iso[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[5].set_original_access("RW");
      iso[6] =
          (dv_base_reg_field::
           type_id::create("iso_6"));
      iso[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[6].set_original_access("RW");
      iso[7] =
          (dv_base_reg_field::
           type_id::create("iso_7"));
      iso[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[7].set_original_access("RW");
      iso[8] =
          (dv_base_reg_field::
           type_id::create("iso_8"));
      iso[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[8].set_original_access("RW");
      iso[9] =
          (dv_base_reg_field::
           type_id::create("iso_9"));
      iso[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[9].set_original_access("RW");
      iso[10] =
          (dv_base_reg_field::
           type_id::create("iso_10"));
      iso[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[10].set_original_access("RW");
      iso[11] =
          (dv_base_reg_field::
           type_id::create("iso_11"));
      iso[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[11].set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_out_iso

  class usbdev_reg_in_iso extends dv_base_reg;
    // fields
    rand dv_base_reg_field iso[12];

    `uvm_object_utils(usbdev_reg_in_iso)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      iso[0] =
          (dv_base_reg_field::
           type_id::create("iso_0"));
      iso[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[0].set_original_access("RW");
      iso[1] =
          (dv_base_reg_field::
           type_id::create("iso_1"));
      iso[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[1].set_original_access("RW");
      iso[2] =
          (dv_base_reg_field::
           type_id::create("iso_2"));
      iso[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[2].set_original_access("RW");
      iso[3] =
          (dv_base_reg_field::
           type_id::create("iso_3"));
      iso[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[3].set_original_access("RW");
      iso[4] =
          (dv_base_reg_field::
           type_id::create("iso_4"));
      iso[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[4].set_original_access("RW");
      iso[5] =
          (dv_base_reg_field::
           type_id::create("iso_5"));
      iso[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[5].set_original_access("RW");
      iso[6] =
          (dv_base_reg_field::
           type_id::create("iso_6"));
      iso[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[6].set_original_access("RW");
      iso[7] =
          (dv_base_reg_field::
           type_id::create("iso_7"));
      iso[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[7].set_original_access("RW");
      iso[8] =
          (dv_base_reg_field::
           type_id::create("iso_8"));
      iso[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[8].set_original_access("RW");
      iso[9] =
          (dv_base_reg_field::
           type_id::create("iso_9"));
      iso[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[9].set_original_access("RW");
      iso[10] =
          (dv_base_reg_field::
           type_id::create("iso_10"));
      iso[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[10].set_original_access("RW");
      iso[11] =
          (dv_base_reg_field::
           type_id::create("iso_11"));
      iso[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iso[11].set_original_access("RW");
    endfunction : build
  endclass : usbdev_reg_in_iso

  class usbdev_reg_out_data_toggle extends dv_base_reg;
    // fields
    rand dv_base_reg_field status;
    rand dv_base_reg_field mask;

    `uvm_object_utils(usbdev_reg_out_data_toggle)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      status =
          (dv_base_reg_field::
           type_id::create("status"));
      status.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      status.set_original_access("RW");
      mask =
          (dv_base_reg_field::
           type_id::create("mask"));
      mask.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mask.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_out_data_toggle

  class usbdev_reg_in_data_toggle extends dv_base_reg;
    // fields
    rand dv_base_reg_field status;
    rand dv_base_reg_field mask;

    `uvm_object_utils(usbdev_reg_in_data_toggle)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      status =
          (dv_base_reg_field::
           type_id::create("status"));
      status.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      status.set_original_access("RW");
      mask =
          (dv_base_reg_field::
           type_id::create("mask"));
      mask.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mask.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_in_data_toggle

  class usbdev_reg_phy_pins_sense extends dv_base_reg;
    // fields
    rand dv_base_reg_field rx_dp_i;
    rand dv_base_reg_field rx_dn_i;
    rand dv_base_reg_field rx_d_i;
    rand dv_base_reg_field tx_dp_o;
    rand dv_base_reg_field tx_dn_o;
    rand dv_base_reg_field tx_d_o;
    rand dv_base_reg_field tx_se0_o;
    rand dv_base_reg_field tx_oe_o;
    rand dv_base_reg_field pwr_sense;

    `uvm_object_utils(usbdev_reg_phy_pins_sense)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rx_dp_i =
          (dv_base_reg_field::
           type_id::create("rx_dp_i"));
      rx_dp_i.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_dp_i.set_original_access("RO");
      rx_dn_i =
          (dv_base_reg_field::
           type_id::create("rx_dn_i"));
      rx_dn_i.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_dn_i.set_original_access("RO");
      rx_d_i =
          (dv_base_reg_field::
           type_id::create("rx_d_i"));
      rx_d_i.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_d_i.set_original_access("RO");
      tx_dp_o =
          (dv_base_reg_field::
           type_id::create("tx_dp_o"));
      tx_dp_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_dp_o.set_original_access("RO");
      tx_dn_o =
          (dv_base_reg_field::
           type_id::create("tx_dn_o"));
      tx_dn_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_dn_o.set_original_access("RO");
      tx_d_o =
          (dv_base_reg_field::
           type_id::create("tx_d_o"));
      tx_d_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_d_o.set_original_access("RO");
      tx_se0_o =
          (dv_base_reg_field::
           type_id::create("tx_se0_o"));
      tx_se0_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_se0_o.set_original_access("RO");
      tx_oe_o =
          (dv_base_reg_field::
           type_id::create("tx_oe_o"));
      tx_oe_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_oe_o.set_original_access("RO");
      pwr_sense =
          (dv_base_reg_field::
           type_id::create("pwr_sense"));
      pwr_sense.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwr_sense.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_phy_pins_sense

  class usbdev_reg_phy_pins_drive extends dv_base_reg;
    // fields
    rand dv_base_reg_field dp_o;
    rand dv_base_reg_field dn_o;
    rand dv_base_reg_field d_o;
    rand dv_base_reg_field se0_o;
    rand dv_base_reg_field oe_o;
    rand dv_base_reg_field rx_enable_o;
    rand dv_base_reg_field dp_pullup_en_o;
    rand dv_base_reg_field dn_pullup_en_o;
    rand dv_base_reg_field en;

    `uvm_object_utils(usbdev_reg_phy_pins_drive)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      dp_o =
          (dv_base_reg_field::
           type_id::create("dp_o"));
      dp_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dp_o.set_original_access("RW");
      dn_o =
          (dv_base_reg_field::
           type_id::create("dn_o"));
      dn_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dn_o.set_original_access("RW");
      d_o =
          (dv_base_reg_field::
           type_id::create("d_o"));
      d_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      d_o.set_original_access("RW");
      se0_o =
          (dv_base_reg_field::
           type_id::create("se0_o"));
      se0_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      se0_o.set_original_access("RW");
      oe_o =
          (dv_base_reg_field::
           type_id::create("oe_o"));
      oe_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      oe_o.set_original_access("RW");
      rx_enable_o =
          (dv_base_reg_field::
           type_id::create("rx_enable_o"));
      rx_enable_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_enable_o.set_original_access("RW");
      dp_pullup_en_o =
          (dv_base_reg_field::
           type_id::create("dp_pullup_en_o"));
      dp_pullup_en_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dp_pullup_en_o.set_original_access("RW");
      dn_pullup_en_o =
          (dv_base_reg_field::
           type_id::create("dn_pullup_en_o"));
      dn_pullup_en_o.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dn_pullup_en_o.set_original_access("RW");
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(en.get_full_name(), CsrExclWrite, CsrNonInitTests);
    endfunction : build
  endclass : usbdev_reg_phy_pins_drive

  class usbdev_reg_phy_config extends dv_base_reg;
    // fields
    rand dv_base_reg_field use_diff_rcvr;
    rand dv_base_reg_field tx_use_d_se0;
    rand dv_base_reg_field eop_single_bit;
    rand dv_base_reg_field pinflip;
    rand dv_base_reg_field usb_ref_disable;
    rand dv_base_reg_field tx_osc_test_mode;

    `uvm_object_utils(usbdev_reg_phy_config)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      use_diff_rcvr =
          (dv_base_reg_field::
           type_id::create("use_diff_rcvr"));
      use_diff_rcvr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      use_diff_rcvr.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(use_diff_rcvr.get_full_name(), CsrExclWrite, CsrNonInitTests);
      tx_use_d_se0 =
          (dv_base_reg_field::
           type_id::create("tx_use_d_se0"));
      tx_use_d_se0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_use_d_se0.set_original_access("RW");
      eop_single_bit =
          (dv_base_reg_field::
           type_id::create("eop_single_bit"));
      eop_single_bit.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      eop_single_bit.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(eop_single_bit.get_full_name(), CsrExclWrite, CsrNonInitTests);
      pinflip =
          (dv_base_reg_field::
           type_id::create("pinflip"));
      pinflip.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pinflip.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(pinflip.get_full_name(), CsrExclWrite, CsrNonInitTests);
      usb_ref_disable =
          (dv_base_reg_field::
           type_id::create("usb_ref_disable"));
      usb_ref_disable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      usb_ref_disable.set_original_access("RW");
      tx_osc_test_mode =
          (dv_base_reg_field::
           type_id::create("tx_osc_test_mode"));
      tx_osc_test_mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_osc_test_mode.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(tx_osc_test_mode.get_full_name(), CsrExclWrite, CsrNonInitTests);
    endfunction : build
  endclass : usbdev_reg_phy_config

  class usbdev_reg_wake_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field suspend_req;
    rand dv_base_reg_field wake_ack;

    `uvm_object_utils(usbdev_reg_wake_control)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      suspend_req =
          (dv_base_reg_field::
           type_id::create("suspend_req"));
      suspend_req.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      suspend_req.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(suspend_req.get_full_name(), CsrExclWrite, CsrNonInitTests);
      wake_ack =
          (dv_base_reg_field::
           type_id::create("wake_ack"));
      wake_ack.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wake_ack.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_wake_control

  class usbdev_reg_wake_events extends dv_base_reg;
    // fields
    rand dv_base_reg_field module_active;
    rand dv_base_reg_field disconnected;
    rand dv_base_reg_field bus_reset;
    rand dv_base_reg_field bus_not_idle;

    `uvm_object_utils(usbdev_reg_wake_events)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      module_active =
          (dv_base_reg_field::
           type_id::create("module_active"));
      module_active.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      module_active.set_original_access("RO");
      disconnected =
          (dv_base_reg_field::
           type_id::create("disconnected"));
      disconnected.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      disconnected.set_original_access("RO");
      bus_reset =
          (dv_base_reg_field::
           type_id::create("bus_reset"));
      bus_reset.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_reset.set_original_access("RO");
      bus_not_idle =
          (dv_base_reg_field::
           type_id::create("bus_not_idle"));
      bus_not_idle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_not_idle.set_original_access("RO");
    endfunction : build
  endclass : usbdev_reg_wake_events

  class usbdev_reg_fifo_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field avout_rst;
    rand dv_base_reg_field avsetup_rst;
    rand dv_base_reg_field rx_rst;

    `uvm_object_utils(usbdev_reg_fifo_ctrl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      avout_rst =
          (dv_base_reg_field::
           type_id::create("avout_rst"));
      avout_rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      avout_rst.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(avout_rst.get_full_name(), CsrExclWrite, CsrNonInitTests);
      avsetup_rst =
          (dv_base_reg_field::
           type_id::create("avsetup_rst"));
      avsetup_rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      avsetup_rst.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(avsetup_rst.get_full_name(), CsrExclWrite, CsrNonInitTests);
      rx_rst =
          (dv_base_reg_field::
           type_id::create("rx_rst"));
      rx_rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_rst.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(rx_rst.get_full_name(), CsrExclWrite, CsrNonInitTests);
    endfunction : build
  endclass : usbdev_reg_fifo_ctrl

  class usbdev_reg_count_out extends dv_base_reg;
    // fields
    rand dv_base_reg_field count;
    rand dv_base_reg_field datatog_out;
    rand dv_base_reg_field drop_rx;
    rand dv_base_reg_field drop_avout;
    rand dv_base_reg_field ign_avsetup;
    rand dv_base_reg_field endpoints;
    rand dv_base_reg_field rst;

    `uvm_object_utils(usbdev_reg_count_out)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      count =
          (dv_base_reg_field::
           type_id::create("count"));
      count.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      count.set_original_access("RO");
      datatog_out =
          (dv_base_reg_field::
           type_id::create("datatog_out"));
      datatog_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      datatog_out.set_original_access("RW");
      drop_rx =
          (dv_base_reg_field::
           type_id::create("drop_rx"));
      drop_rx.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      drop_rx.set_original_access("RW");
      drop_avout =
          (dv_base_reg_field::
           type_id::create("drop_avout"));
      drop_avout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      drop_avout.set_original_access("RW");
      ign_avsetup =
          (dv_base_reg_field::
           type_id::create("ign_avsetup"));
      ign_avsetup.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ign_avsetup.set_original_access("RW");
      endpoints =
          (dv_base_reg_field::
           type_id::create("endpoints"));
      endpoints.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoints.set_original_access("RW");
      rst =
          (dv_base_reg_field::
           type_id::create("rst"));
      rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rst.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(rst.get_full_name(), CsrExclWrite, CsrNonInitTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_count_out

  class usbdev_reg_count_in extends dv_base_reg;
    // fields
    rand dv_base_reg_field count;
    rand dv_base_reg_field nodata;
    rand dv_base_reg_field nak;
    rand dv_base_reg_field timeout;
    rand dv_base_reg_field endpoints;
    rand dv_base_reg_field rst;

    `uvm_object_utils(usbdev_reg_count_in)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      count =
          (dv_base_reg_field::
           type_id::create("count"));
      count.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      count.set_original_access("RO");
      nodata =
          (dv_base_reg_field::
           type_id::create("nodata"));
      nodata.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nodata.set_original_access("RW");
      nak =
          (dv_base_reg_field::
           type_id::create("nak"));
      nak.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nak.set_original_access("RW");
      timeout =
          (dv_base_reg_field::
           type_id::create("timeout"));
      timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      timeout.set_original_access("RW");
      endpoints =
          (dv_base_reg_field::
           type_id::create("endpoints"));
      endpoints.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoints.set_original_access("RW");
      rst =
          (dv_base_reg_field::
           type_id::create("rst"));
      rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rst.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(rst.get_full_name(), CsrExclWrite, CsrNonInitTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_count_in

  class usbdev_reg_count_nodata_in extends dv_base_reg;
    // fields
    rand dv_base_reg_field count;
    rand dv_base_reg_field endpoints;
    rand dv_base_reg_field rst;

    `uvm_object_utils(usbdev_reg_count_nodata_in)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      count =
          (dv_base_reg_field::
           type_id::create("count"));
      count.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      count.set_original_access("RO");
      endpoints =
          (dv_base_reg_field::
           type_id::create("endpoints"));
      endpoints.configure(
        .parent(this),
        .size(12),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endpoints.set_original_access("RW");
      rst =
          (dv_base_reg_field::
           type_id::create("rst"));
      rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rst.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(rst.get_full_name(), CsrExclWrite, CsrNonInitTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_count_nodata_in

  class usbdev_reg_count_errors extends dv_base_reg;
    // fields
    rand dv_base_reg_field count;
    rand dv_base_reg_field pid_invalid;
    rand dv_base_reg_field bitstuff;
    rand dv_base_reg_field crc16;
    rand dv_base_reg_field crc5;
    rand dv_base_reg_field rst;

    `uvm_object_utils(usbdev_reg_count_errors)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      count =
          (dv_base_reg_field::
           type_id::create("count"));
      count.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      count.set_original_access("RO");
      pid_invalid =
          (dv_base_reg_field::
           type_id::create("pid_invalid"));
      pid_invalid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(27),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pid_invalid.set_original_access("RW");
      bitstuff =
          (dv_base_reg_field::
           type_id::create("bitstuff"));
      bitstuff.configure(
        .parent(this),
        .size(1),
        .lsb_pos(28),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bitstuff.set_original_access("RW");
      crc16 =
          (dv_base_reg_field::
           type_id::create("crc16"));
      crc16.configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      crc16.set_original_access("RW");
      crc5 =
          (dv_base_reg_field::
           type_id::create("crc5"));
      crc5.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      crc5.set_original_access("RW");
      rst =
          (dv_base_reg_field::
           type_id::create("rst"));
      rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rst.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(rst.get_full_name(), CsrExclWrite, CsrNonInitTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : usbdev_reg_count_errors

  class usbdev_mem_buffer extends dv_base_mem;

    `uvm_object_utils(usbdev_mem_buffer)

    function new(string           name = "",
                 longint unsigned size = 512,
                 int unsigned     n_bits = 32,
                 string           access = "RW",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
    endfunction : new

  endclass : usbdev_mem_buffer


  class usbdev_reg_block extends dv_base_reg_block;
    // registers
    rand usbdev_reg_intr_state intr_state;
    rand usbdev_reg_intr_enable intr_enable;
    rand usbdev_reg_intr_test intr_test;
    rand usbdev_reg_alert_test alert_test;
    rand usbdev_reg_usbctrl usbctrl;
    rand usbdev_reg_ep_out_enable ep_out_enable[1];
    rand usbdev_reg_ep_in_enable ep_in_enable[1];
    rand usbdev_reg_usbstat usbstat;
    rand usbdev_reg_avoutbuffer avoutbuffer;
    rand usbdev_reg_avsetupbuffer avsetupbuffer;
    rand usbdev_reg_rxfifo rxfifo;
    rand usbdev_reg_rxenable_setup rxenable_setup[1];
    rand usbdev_reg_rxenable_out rxenable_out;
    rand usbdev_reg_set_nak_out set_nak_out[1];
    rand usbdev_reg_in_sent in_sent[1];
    rand usbdev_reg_out_stall out_stall[1];
    rand usbdev_reg_in_stall in_stall[1];
    rand usbdev_reg_configin configin[12];
    rand usbdev_reg_out_iso out_iso[1];
    rand usbdev_reg_in_iso in_iso[1];
    rand usbdev_reg_out_data_toggle out_data_toggle;
    rand usbdev_reg_in_data_toggle in_data_toggle;
    rand usbdev_reg_phy_pins_sense phy_pins_sense;
    rand usbdev_reg_phy_pins_drive phy_pins_drive;
    rand usbdev_reg_phy_config phy_config;
    rand usbdev_reg_wake_control wake_control;
    rand usbdev_reg_wake_events wake_events;
    rand usbdev_reg_fifo_ctrl fifo_ctrl;
    rand usbdev_reg_count_out count_out;
    rand usbdev_reg_count_in count_in;
    rand usbdev_reg_count_nodata_in count_nodata_in;
    rand usbdev_reg_count_errors count_errors;
    // memories
    rand usbdev_mem_buffer buffer;

    `uvm_object_utils(usbdev_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (usbdev_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_pkt_received.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_pkt_sent.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_disconnected.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_host_lost.q",
          3, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_link_reset.q",
          4, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_link_suspend.q",
          5, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_link_resume.q",
          6, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_av_out_empty.q",
          7, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_full.q",
          8, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_av_overflow.q",
          9, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_link_in_err.q",
          10, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_crc_err.q",
          11, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_pid_err.q",
          12, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_bitstuff_err.q",
          13, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_frame.q",
          14, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_powered.q",
          15, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_link_out_err.q",
          16, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_av_setup_empty.q",
          17, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (usbdev_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_pkt_received.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_pkt_sent.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_disconnected.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_host_lost.q",
          3, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_link_reset.q",
          4, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_link_suspend.q",
          5, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_link_resume.q",
          6, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_av_out_empty.q",
          7, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_full.q",
          8, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_av_overflow.q",
          9, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_link_in_err.q",
          10, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_crc_err.q",
          11, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_pid_err.q",
          12, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_bitstuff_err.q",
          13, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_frame.q",
          14, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_powered.q",
          15, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_link_out_err.q",
          16, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_av_setup_empty.q",
          17, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (usbdev_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_pkt_received.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_pkt_sent.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_disconnected.qs",
          2, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_host_lost.qs",
          3, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_link_reset.qs",
          4, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_link_suspend.qs",
          5, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_link_resume.qs",
          6, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_av_out_empty.qs",
          7, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_full.qs",
          8, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_av_overflow.qs",
          9, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_link_in_err.qs",
          10, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_crc_err.qs",
          11, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_pid_err.qs",
          12, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_bitstuff_err.qs",
          13, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_frame.qs",
          14, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_powered.qs",
          15, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_link_out_err.qs",
          16, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_av_setup_empty.qs",
          17, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (usbdev_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      usbctrl =
          (usbdev_reg_usbctrl::
           type_id::create("usbctrl"));
      usbctrl.configure(.blk_parent(this));
      usbctrl.build(csr_excl);
      default_map.add_reg(.rg(usbctrl),
                          .offset(32'h10));
      usbctrl.add_hdl_path_slice(
          "u_reg.u_usbctrl_enable.q",
          0, 1, 0, "BkdrRegPathRtl");
      usbctrl.add_hdl_path_slice(
          "u_reg.u_usbctrl_resume_link_active.q",
          1, 1, 0, "BkdrRegPathRtl");
      usbctrl.add_hdl_path_slice(
          "u_reg.u_usbctrl_device_address.q",
          16, 7, 0, "BkdrRegPathRtl");

      ep_out_enable[0] =
          (usbdev_reg_ep_out_enable::
           type_id::create("ep_out_enable"));
      ep_out_enable[0].configure(.blk_parent(this));
      ep_out_enable[0].build(csr_excl);
      default_map.add_reg(.rg(ep_out_enable[0]),
                          .offset(32'h14));
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      ep_out_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_out_enable_enable_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      ep_in_enable[0] =
          (usbdev_reg_ep_in_enable::
           type_id::create("ep_in_enable"));
      ep_in_enable[0].configure(.blk_parent(this));
      ep_in_enable[0].build(csr_excl);
      default_map.add_reg(.rg(ep_in_enable[0]),
                          .offset(32'h18));
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      ep_in_enable[0].add_hdl_path_slice(
          "u_reg.u_ep_in_enable_enable_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      usbstat =
          (usbdev_reg_usbstat::
           type_id::create("usbstat"));
      usbstat.configure(.blk_parent(this));
      usbstat.build(csr_excl);
      default_map.add_reg(.rg(usbstat),
                          .offset(32'h1c));
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_frame.qs",
          0, 11, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_host_lost.qs",
          11, 1, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_link_state.qs",
          12, 3, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_sense.qs",
          15, 1, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_av_out_depth.qs",
          16, 4, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_av_setup_depth.qs",
          20, 3, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_av_out_full.qs",
          23, 1, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_rx_depth.qs",
          24, 4, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_av_setup_full.qs",
          30, 1, 0, "BkdrRegPathRtl");
      usbstat.add_hdl_path_slice(
          "u_reg.u_usbstat_rx_empty.qs",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(usbstat.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      avoutbuffer =
          (usbdev_reg_avoutbuffer::
           type_id::create("avoutbuffer"));
      avoutbuffer.configure(.blk_parent(this));
      avoutbuffer.build(csr_excl);
      default_map.add_reg(.rg(avoutbuffer),
                          .offset(32'h20));
      avoutbuffer.add_hdl_path_slice(
          "u_reg.u_avoutbuffer.qs",
          0, 5, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(avoutbuffer.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      avsetupbuffer =
          (usbdev_reg_avsetupbuffer::
           type_id::create("avsetupbuffer"));
      avsetupbuffer.configure(.blk_parent(this));
      avsetupbuffer.build(csr_excl);
      default_map.add_reg(.rg(avsetupbuffer),
                          .offset(32'h24));
      avsetupbuffer.add_hdl_path_slice(
          "u_reg.u_avsetupbuffer.qs",
          0, 5, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(avsetupbuffer.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      rxfifo =
          (usbdev_reg_rxfifo::
           type_id::create("rxfifo"));
      rxfifo.configure(.blk_parent(this));
      rxfifo.build(csr_excl);
      default_map.add_reg(.rg(rxfifo),
                          .offset(32'h28));
      rxfifo.add_hdl_path_slice(
          "u_reg.u_rxfifo_buffer.qs",
          0, 5, 0, "BkdrRegPathRtl");
      rxfifo.add_hdl_path_slice(
          "u_reg.u_rxfifo_size.qs",
          8, 7, 0, "BkdrRegPathRtl");
      rxfifo.add_hdl_path_slice(
          "u_reg.u_rxfifo_setup.qs",
          19, 1, 0, "BkdrRegPathRtl");
      rxfifo.add_hdl_path_slice(
          "u_reg.u_rxfifo_ep.qs",
          20, 4, 0, "BkdrRegPathRtl");

      rxenable_setup[0] =
          (usbdev_reg_rxenable_setup::
           type_id::create("rxenable_setup"));
      rxenable_setup[0].configure(.blk_parent(this));
      rxenable_setup[0].build(csr_excl);
      default_map.add_reg(.rg(rxenable_setup[0]),
                          .offset(32'h2c));
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      rxenable_setup[0].add_hdl_path_slice(
          "u_reg.u_rxenable_setup_setup_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      rxenable_out =
          (usbdev_reg_rxenable_out::
           type_id::create("rxenable_out"));
      rxenable_out.configure(.blk_parent(this));
      rxenable_out.build(csr_excl);
      default_map.add_reg(.rg(rxenable_out),
                          .offset(32'h30));
      rxenable_out.add_hdl_path_slice(
          "u_reg.u_rxenable_out_out.qs",
          0, 12, 0, "BkdrRegPathRtl");
      rxenable_out.add_hdl_path_slice(
          "u_reg.u_rxenable_out_preserve.qs",
          16, 12, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(rxenable_out.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      set_nak_out[0] =
          (usbdev_reg_set_nak_out::
           type_id::create("set_nak_out"));
      set_nak_out[0].configure(.blk_parent(this));
      set_nak_out[0].build(csr_excl);
      default_map.add_reg(.rg(set_nak_out[0]),
                          .offset(32'h34));
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      set_nak_out[0].add_hdl_path_slice(
          "u_reg.u_set_nak_out_enable_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      in_sent[0] =
          (usbdev_reg_in_sent::
           type_id::create("in_sent"));
      in_sent[0].configure(.blk_parent(this));
      in_sent[0].build(csr_excl);
      default_map.add_reg(.rg(in_sent[0]),
                          .offset(32'h38));
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      in_sent[0].add_hdl_path_slice(
          "u_reg.u_in_sent_sent_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      out_stall[0] =
          (usbdev_reg_out_stall::
           type_id::create("out_stall"));
      out_stall[0].configure(.blk_parent(this));
      out_stall[0].build(csr_excl);
      default_map.add_reg(.rg(out_stall[0]),
                          .offset(32'h3c));
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      out_stall[0].add_hdl_path_slice(
          "u_reg.u_out_stall_endpoint_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      in_stall[0] =
          (usbdev_reg_in_stall::
           type_id::create("in_stall"));
      in_stall[0].configure(.blk_parent(this));
      in_stall[0].build(csr_excl);
      default_map.add_reg(.rg(in_stall[0]),
                          .offset(32'h40));
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      in_stall[0].add_hdl_path_slice(
          "u_reg.u_in_stall_endpoint_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      configin[0] =
          (usbdev_reg_configin::
           type_id::create("configin_0"));
      configin[0].configure(.blk_parent(this));
      configin[0].build(csr_excl);
      default_map.add_reg(.rg(configin[0]),
                          .offset(32'h44));
      configin[0].add_hdl_path_slice(
          "u_reg.u_configin_0_buffer_0.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[0].add_hdl_path_slice(
          "u_reg.u_configin_0_size_0.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[0].add_hdl_path_slice(
          "u_reg.u_configin_0_sending_0.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[0].add_hdl_path_slice(
          "u_reg.u_configin_0_pend_0.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[0].add_hdl_path_slice(
          "u_reg.u_configin_0_rdy_0.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[0].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[1] =
          (usbdev_reg_configin::
           type_id::create("configin_1"));
      configin[1].configure(.blk_parent(this));
      configin[1].build(csr_excl);
      default_map.add_reg(.rg(configin[1]),
                          .offset(32'h48));
      configin[1].add_hdl_path_slice(
          "u_reg.u_configin_1_buffer_1.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[1].add_hdl_path_slice(
          "u_reg.u_configin_1_size_1.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[1].add_hdl_path_slice(
          "u_reg.u_configin_1_sending_1.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[1].add_hdl_path_slice(
          "u_reg.u_configin_1_pend_1.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[1].add_hdl_path_slice(
          "u_reg.u_configin_1_rdy_1.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[1].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[2] =
          (usbdev_reg_configin::
           type_id::create("configin_2"));
      configin[2].configure(.blk_parent(this));
      configin[2].build(csr_excl);
      default_map.add_reg(.rg(configin[2]),
                          .offset(32'h4c));
      configin[2].add_hdl_path_slice(
          "u_reg.u_configin_2_buffer_2.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[2].add_hdl_path_slice(
          "u_reg.u_configin_2_size_2.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[2].add_hdl_path_slice(
          "u_reg.u_configin_2_sending_2.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[2].add_hdl_path_slice(
          "u_reg.u_configin_2_pend_2.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[2].add_hdl_path_slice(
          "u_reg.u_configin_2_rdy_2.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[2].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[3] =
          (usbdev_reg_configin::
           type_id::create("configin_3"));
      configin[3].configure(.blk_parent(this));
      configin[3].build(csr_excl);
      default_map.add_reg(.rg(configin[3]),
                          .offset(32'h50));
      configin[3].add_hdl_path_slice(
          "u_reg.u_configin_3_buffer_3.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[3].add_hdl_path_slice(
          "u_reg.u_configin_3_size_3.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[3].add_hdl_path_slice(
          "u_reg.u_configin_3_sending_3.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[3].add_hdl_path_slice(
          "u_reg.u_configin_3_pend_3.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[3].add_hdl_path_slice(
          "u_reg.u_configin_3_rdy_3.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[3].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[4] =
          (usbdev_reg_configin::
           type_id::create("configin_4"));
      configin[4].configure(.blk_parent(this));
      configin[4].build(csr_excl);
      default_map.add_reg(.rg(configin[4]),
                          .offset(32'h54));
      configin[4].add_hdl_path_slice(
          "u_reg.u_configin_4_buffer_4.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[4].add_hdl_path_slice(
          "u_reg.u_configin_4_size_4.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[4].add_hdl_path_slice(
          "u_reg.u_configin_4_sending_4.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[4].add_hdl_path_slice(
          "u_reg.u_configin_4_pend_4.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[4].add_hdl_path_slice(
          "u_reg.u_configin_4_rdy_4.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[4].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[5] =
          (usbdev_reg_configin::
           type_id::create("configin_5"));
      configin[5].configure(.blk_parent(this));
      configin[5].build(csr_excl);
      default_map.add_reg(.rg(configin[5]),
                          .offset(32'h58));
      configin[5].add_hdl_path_slice(
          "u_reg.u_configin_5_buffer_5.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[5].add_hdl_path_slice(
          "u_reg.u_configin_5_size_5.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[5].add_hdl_path_slice(
          "u_reg.u_configin_5_sending_5.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[5].add_hdl_path_slice(
          "u_reg.u_configin_5_pend_5.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[5].add_hdl_path_slice(
          "u_reg.u_configin_5_rdy_5.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[5].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[6] =
          (usbdev_reg_configin::
           type_id::create("configin_6"));
      configin[6].configure(.blk_parent(this));
      configin[6].build(csr_excl);
      default_map.add_reg(.rg(configin[6]),
                          .offset(32'h5c));
      configin[6].add_hdl_path_slice(
          "u_reg.u_configin_6_buffer_6.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[6].add_hdl_path_slice(
          "u_reg.u_configin_6_size_6.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[6].add_hdl_path_slice(
          "u_reg.u_configin_6_sending_6.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[6].add_hdl_path_slice(
          "u_reg.u_configin_6_pend_6.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[6].add_hdl_path_slice(
          "u_reg.u_configin_6_rdy_6.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[6].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[7] =
          (usbdev_reg_configin::
           type_id::create("configin_7"));
      configin[7].configure(.blk_parent(this));
      configin[7].build(csr_excl);
      default_map.add_reg(.rg(configin[7]),
                          .offset(32'h60));
      configin[7].add_hdl_path_slice(
          "u_reg.u_configin_7_buffer_7.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[7].add_hdl_path_slice(
          "u_reg.u_configin_7_size_7.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[7].add_hdl_path_slice(
          "u_reg.u_configin_7_sending_7.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[7].add_hdl_path_slice(
          "u_reg.u_configin_7_pend_7.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[7].add_hdl_path_slice(
          "u_reg.u_configin_7_rdy_7.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[7].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[8] =
          (usbdev_reg_configin::
           type_id::create("configin_8"));
      configin[8].configure(.blk_parent(this));
      configin[8].build(csr_excl);
      default_map.add_reg(.rg(configin[8]),
                          .offset(32'h64));
      configin[8].add_hdl_path_slice(
          "u_reg.u_configin_8_buffer_8.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[8].add_hdl_path_slice(
          "u_reg.u_configin_8_size_8.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[8].add_hdl_path_slice(
          "u_reg.u_configin_8_sending_8.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[8].add_hdl_path_slice(
          "u_reg.u_configin_8_pend_8.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[8].add_hdl_path_slice(
          "u_reg.u_configin_8_rdy_8.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[8].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[9] =
          (usbdev_reg_configin::
           type_id::create("configin_9"));
      configin[9].configure(.blk_parent(this));
      configin[9].build(csr_excl);
      default_map.add_reg(.rg(configin[9]),
                          .offset(32'h68));
      configin[9].add_hdl_path_slice(
          "u_reg.u_configin_9_buffer_9.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[9].add_hdl_path_slice(
          "u_reg.u_configin_9_size_9.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[9].add_hdl_path_slice(
          "u_reg.u_configin_9_sending_9.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[9].add_hdl_path_slice(
          "u_reg.u_configin_9_pend_9.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[9].add_hdl_path_slice(
          "u_reg.u_configin_9_rdy_9.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[9].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[10] =
          (usbdev_reg_configin::
           type_id::create("configin_10"));
      configin[10].configure(.blk_parent(this));
      configin[10].build(csr_excl);
      default_map.add_reg(.rg(configin[10]),
                          .offset(32'h6c));
      configin[10].add_hdl_path_slice(
          "u_reg.u_configin_10_buffer_10.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[10].add_hdl_path_slice(
          "u_reg.u_configin_10_size_10.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[10].add_hdl_path_slice(
          "u_reg.u_configin_10_sending_10.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[10].add_hdl_path_slice(
          "u_reg.u_configin_10_pend_10.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[10].add_hdl_path_slice(
          "u_reg.u_configin_10_rdy_10.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[10].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      configin[11] =
          (usbdev_reg_configin::
           type_id::create("configin_11"));
      configin[11].configure(.blk_parent(this));
      configin[11].build(csr_excl);
      default_map.add_reg(.rg(configin[11]),
                          .offset(32'h70));
      configin[11].add_hdl_path_slice(
          "u_reg.u_configin_11_buffer_11.q",
          0, 5, 0, "BkdrRegPathRtl");
      configin[11].add_hdl_path_slice(
          "u_reg.u_configin_11_size_11.q",
          8, 7, 0, "BkdrRegPathRtl");
      configin[11].add_hdl_path_slice(
          "u_reg.u_configin_11_sending_11.q",
          29, 1, 0, "BkdrRegPathRtl");
      configin[11].add_hdl_path_slice(
          "u_reg.u_configin_11_pend_11.q",
          30, 1, 0, "BkdrRegPathRtl");
      configin[11].add_hdl_path_slice(
          "u_reg.u_configin_11_rdy_11.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(configin[11].get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      out_iso[0] =
          (usbdev_reg_out_iso::
           type_id::create("out_iso"));
      out_iso[0].configure(.blk_parent(this));
      out_iso[0].build(csr_excl);
      default_map.add_reg(.rg(out_iso[0]),
                          .offset(32'h74));
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      out_iso[0].add_hdl_path_slice(
          "u_reg.u_out_iso_iso_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      in_iso[0] =
          (usbdev_reg_in_iso::
           type_id::create("in_iso"));
      in_iso[0].configure(.blk_parent(this));
      in_iso[0].build(csr_excl);
      default_map.add_reg(.rg(in_iso[0]),
                          .offset(32'h78));
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      in_iso[0].add_hdl_path_slice(
          "u_reg.u_in_iso_iso_11.q",
          11, 1, 0, "BkdrRegPathRtl");

      out_data_toggle =
          (usbdev_reg_out_data_toggle::
           type_id::create("out_data_toggle"));
      out_data_toggle.configure(.blk_parent(this));
      out_data_toggle.build(csr_excl);
      default_map.add_reg(.rg(out_data_toggle),
                          .offset(32'h7c));
      out_data_toggle.add_hdl_path_slice(
          "u_reg.u_out_data_toggle_status.qs",
          0, 12, 0, "BkdrRegPathRtl");
      out_data_toggle.add_hdl_path_slice(
          "u_reg.u_out_data_toggle_mask.qs",
          16, 12, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(out_data_toggle.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      in_data_toggle =
          (usbdev_reg_in_data_toggle::
           type_id::create("in_data_toggle"));
      in_data_toggle.configure(.blk_parent(this));
      in_data_toggle.build(csr_excl);
      default_map.add_reg(.rg(in_data_toggle),
                          .offset(32'h80));
      in_data_toggle.add_hdl_path_slice(
          "u_reg.u_in_data_toggle_status.qs",
          0, 12, 0, "BkdrRegPathRtl");
      in_data_toggle.add_hdl_path_slice(
          "u_reg.u_in_data_toggle_mask.qs",
          16, 12, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(in_data_toggle.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      phy_pins_sense =
          (usbdev_reg_phy_pins_sense::
           type_id::create("phy_pins_sense"));
      phy_pins_sense.configure(.blk_parent(this));
      phy_pins_sense.build(csr_excl);
      default_map.add_reg(.rg(phy_pins_sense),
                          .offset(32'h84));
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_rx_dp_i.qs",
          0, 1, 0, "BkdrRegPathRtl");
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_rx_dn_i.qs",
          1, 1, 0, "BkdrRegPathRtl");
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_rx_d_i.qs",
          2, 1, 0, "BkdrRegPathRtl");
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_tx_dp_o.qs",
          8, 1, 0, "BkdrRegPathRtl");
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_tx_dn_o.qs",
          9, 1, 0, "BkdrRegPathRtl");
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_tx_d_o.qs",
          10, 1, 0, "BkdrRegPathRtl");
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_tx_se0_o.qs",
          11, 1, 0, "BkdrRegPathRtl");
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_tx_oe_o.qs",
          12, 1, 0, "BkdrRegPathRtl");
      phy_pins_sense.add_hdl_path_slice(
          "u_reg.u_phy_pins_sense_pwr_sense.qs",
          16, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(phy_pins_sense.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      phy_pins_drive =
          (usbdev_reg_phy_pins_drive::
           type_id::create("phy_pins_drive"));
      phy_pins_drive.configure(.blk_parent(this));
      phy_pins_drive.build(csr_excl);
      default_map.add_reg(.rg(phy_pins_drive),
                          .offset(32'h88));
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_dp_o.q",
          0, 1, 0, "BkdrRegPathRtl");
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_dn_o.q",
          1, 1, 0, "BkdrRegPathRtl");
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_d_o.q",
          2, 1, 0, "BkdrRegPathRtl");
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_se0_o.q",
          3, 1, 0, "BkdrRegPathRtl");
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_oe_o.q",
          4, 1, 0, "BkdrRegPathRtl");
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_rx_enable_o.q",
          5, 1, 0, "BkdrRegPathRtl");
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_dp_pullup_en_o.q",
          6, 1, 0, "BkdrRegPathRtl");
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_dn_pullup_en_o.q",
          7, 1, 0, "BkdrRegPathRtl");
      phy_pins_drive.add_hdl_path_slice(
          "u_reg.u_phy_pins_drive_en.q",
          16, 1, 0, "BkdrRegPathRtl");

      phy_config =
          (usbdev_reg_phy_config::
           type_id::create("phy_config"));
      phy_config.configure(.blk_parent(this));
      phy_config.build(csr_excl);
      default_map.add_reg(.rg(phy_config),
                          .offset(32'h8c));
      phy_config.add_hdl_path_slice(
          "u_reg.u_phy_config_use_diff_rcvr.q",
          0, 1, 0, "BkdrRegPathRtl");
      phy_config.add_hdl_path_slice(
          "u_reg.u_phy_config_tx_use_d_se0.q",
          1, 1, 0, "BkdrRegPathRtl");
      phy_config.add_hdl_path_slice(
          "u_reg.u_phy_config_eop_single_bit.q",
          2, 1, 0, "BkdrRegPathRtl");
      phy_config.add_hdl_path_slice(
          "u_reg.u_phy_config_pinflip.q",
          5, 1, 0, "BkdrRegPathRtl");
      phy_config.add_hdl_path_slice(
          "u_reg.u_phy_config_usb_ref_disable.q",
          6, 1, 0, "BkdrRegPathRtl");
      phy_config.add_hdl_path_slice(
          "u_reg.u_phy_config_tx_osc_test_mode.q",
          7, 1, 0, "BkdrRegPathRtl");

      wake_control =
          (usbdev_reg_wake_control::
           type_id::create("wake_control"));
      wake_control.configure(.blk_parent(this));
      wake_control.build(csr_excl);
      default_map.add_reg(.rg(wake_control),
                          .offset(32'h90));
      wake_control.add_hdl_path_slice(
          "u_reg.u_wake_control_suspend_req.qs",
          0, 1, 0, "BkdrRegPathRtl");
      wake_control.add_hdl_path_slice(
          "u_reg.u_wake_control_wake_ack.qs",
          1, 1, 0, "BkdrRegPathRtl");

      wake_events =
          (usbdev_reg_wake_events::
           type_id::create("wake_events"));
      wake_events.configure(.blk_parent(this));
      wake_events.build(csr_excl);
      default_map.add_reg(.rg(wake_events),
                          .offset(32'h94));
      wake_events.add_hdl_path_slice(
          "u_reg.u_wake_events_module_active.q",
          0, 1, 0, "BkdrRegPathRtl");
      wake_events.add_hdl_path_slice(
          "u_reg.u_wake_events_disconnected.q",
          8, 1, 0, "BkdrRegPathRtl");
      wake_events.add_hdl_path_slice(
          "u_reg.u_wake_events_bus_reset.q",
          9, 1, 0, "BkdrRegPathRtl");
      wake_events.add_hdl_path_slice(
          "u_reg.u_wake_events_bus_not_idle.q",
          10, 1, 0, "BkdrRegPathRtl");

      fifo_ctrl =
          (usbdev_reg_fifo_ctrl::
           type_id::create("fifo_ctrl"));
      fifo_ctrl.configure(.blk_parent(this));
      fifo_ctrl.build(csr_excl);
      default_map.add_reg(.rg(fifo_ctrl),
                          .offset(32'h98));
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_avout_rst.q",
          0, 1, 0, "BkdrRegPathRtl");
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_avsetup_rst.q",
          1, 1, 0, "BkdrRegPathRtl");
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_rx_rst.q",
          2, 1, 0, "BkdrRegPathRtl");

      count_out =
          (usbdev_reg_count_out::
           type_id::create("count_out"));
      count_out.configure(.blk_parent(this));
      count_out.build(csr_excl);
      default_map.add_reg(.rg(count_out),
                          .offset(32'h9c));
      count_out.add_hdl_path_slice(
          "u_reg.u_count_out_count.qs",
          0, 8, 0, "BkdrRegPathRtl");
      count_out.add_hdl_path_slice(
          "u_reg.u_count_out_datatog_out.qs",
          12, 1, 0, "BkdrRegPathRtl");
      count_out.add_hdl_path_slice(
          "u_reg.u_count_out_drop_rx.qs",
          13, 1, 0, "BkdrRegPathRtl");
      count_out.add_hdl_path_slice(
          "u_reg.u_count_out_drop_avout.qs",
          14, 1, 0, "BkdrRegPathRtl");
      count_out.add_hdl_path_slice(
          "u_reg.u_count_out_ign_avsetup.qs",
          15, 1, 0, "BkdrRegPathRtl");
      count_out.add_hdl_path_slice(
          "u_reg.u_count_out_endpoints.qs",
          16, 12, 0, "BkdrRegPathRtl");
      count_out.add_hdl_path_slice(
          "u_reg.u_count_out_rst.qs",
          31, 1, 0, "BkdrRegPathRtl");

      count_in =
          (usbdev_reg_count_in::
           type_id::create("count_in"));
      count_in.configure(.blk_parent(this));
      count_in.build(csr_excl);
      default_map.add_reg(.rg(count_in),
                          .offset(32'ha0));
      count_in.add_hdl_path_slice(
          "u_reg.u_count_in_count.qs",
          0, 8, 0, "BkdrRegPathRtl");
      count_in.add_hdl_path_slice(
          "u_reg.u_count_in_nodata.qs",
          13, 1, 0, "BkdrRegPathRtl");
      count_in.add_hdl_path_slice(
          "u_reg.u_count_in_nak.qs",
          14, 1, 0, "BkdrRegPathRtl");
      count_in.add_hdl_path_slice(
          "u_reg.u_count_in_timeout.qs",
          15, 1, 0, "BkdrRegPathRtl");
      count_in.add_hdl_path_slice(
          "u_reg.u_count_in_endpoints.qs",
          16, 12, 0, "BkdrRegPathRtl");
      count_in.add_hdl_path_slice(
          "u_reg.u_count_in_rst.qs",
          31, 1, 0, "BkdrRegPathRtl");

      count_nodata_in =
          (usbdev_reg_count_nodata_in::
           type_id::create("count_nodata_in"));
      count_nodata_in.configure(.blk_parent(this));
      count_nodata_in.build(csr_excl);
      default_map.add_reg(.rg(count_nodata_in),
                          .offset(32'ha4));
      count_nodata_in.add_hdl_path_slice(
          "u_reg.u_count_nodata_in_count.qs",
          0, 8, 0, "BkdrRegPathRtl");
      count_nodata_in.add_hdl_path_slice(
          "u_reg.u_count_nodata_in_endpoints.qs",
          16, 12, 0, "BkdrRegPathRtl");
      count_nodata_in.add_hdl_path_slice(
          "u_reg.u_count_nodata_in_rst.qs",
          31, 1, 0, "BkdrRegPathRtl");

      count_errors =
          (usbdev_reg_count_errors::
           type_id::create("count_errors"));
      count_errors.configure(.blk_parent(this));
      count_errors.build(csr_excl);
      default_map.add_reg(.rg(count_errors),
                          .offset(32'ha8));
      count_errors.add_hdl_path_slice(
          "u_reg.u_count_errors_count.qs",
          0, 8, 0, "BkdrRegPathRtl");
      count_errors.add_hdl_path_slice(
          "u_reg.u_count_errors_pid_invalid.qs",
          27, 1, 0, "BkdrRegPathRtl");
      count_errors.add_hdl_path_slice(
          "u_reg.u_count_errors_bitstuff.qs",
          28, 1, 0, "BkdrRegPathRtl");
      count_errors.add_hdl_path_slice(
          "u_reg.u_count_errors_crc16.qs",
          29, 1, 0, "BkdrRegPathRtl");
      count_errors.add_hdl_path_slice(
          "u_reg.u_count_errors_crc5.qs",
          30, 1, 0, "BkdrRegPathRtl");
      count_errors.add_hdl_path_slice(
          "u_reg.u_count_errors_rst.qs",
          31, 1, 0, "BkdrRegPathRtl");


      // create memories
      buffer =
          usbdev_mem_buffer::type_id::create("buffer");
      buffer.configure(.parent(this));
      default_map.add_mem(.mem(buffer),
                          .offset(32'h800),
                          .rights("RW"));


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : usbdev_reg_block

endpackage

