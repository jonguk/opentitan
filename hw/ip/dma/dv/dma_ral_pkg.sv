// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package dma_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class dma_reg_intr_state;
  typedef class dma_reg_intr_enable;
  typedef class dma_reg_intr_test;
  typedef class dma_reg_alert_test;
  typedef class dma_reg_src_addr_lo;
  typedef class dma_reg_src_addr_hi;
  typedef class dma_reg_dst_addr_lo;
  typedef class dma_reg_dst_addr_hi;
  typedef class dma_reg_addr_space_id;
  typedef class dma_reg_enabled_memory_range_base;
  typedef class dma_reg_enabled_memory_range_limit;
  typedef class dma_reg_range_valid;
  typedef class dma_reg_range_regwen;
  typedef class dma_reg_cfg_regwen;
  typedef class dma_reg_total_data_size;
  typedef class dma_reg_chunk_data_size;
  typedef class dma_reg_transfer_width;
  typedef class dma_reg_control;
  typedef class dma_reg_src_config;
  typedef class dma_reg_dst_config;
  typedef class dma_reg_status;
  typedef class dma_reg_error_code;
  typedef class dma_reg_sha2_digest;
  typedef class dma_reg_handshake_intr_enable;
  typedef class dma_reg_clear_intr_src;
  typedef class dma_reg_clear_intr_bus;
  typedef class dma_reg_intr_src_addr;
  typedef class dma_reg_intr_src_wr_val;
  typedef class dma_reg_block;

  class dma_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field dma_done;
    rand dv_base_reg_field dma_chunk_done;
    rand dv_base_reg_field dma_error;

    `uvm_object_utils(dma_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      dma_done =
          (dv_base_reg_field::
           type_id::create("dma_done"));
      dma_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_done.set_original_access("RO");
      dma_chunk_done =
          (dv_base_reg_field::
           type_id::create("dma_chunk_done"));
      dma_chunk_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_chunk_done.set_original_access("RO");
      dma_error =
          (dv_base_reg_field::
           type_id::create("dma_error"));
      dma_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_error.set_original_access("RO");
    endfunction : build
  endclass : dma_reg_intr_state

  class dma_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field dma_done;
    rand dv_base_reg_field dma_chunk_done;
    rand dv_base_reg_field dma_error;

    `uvm_object_utils(dma_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      dma_done =
          (dv_base_reg_field::
           type_id::create("dma_done"));
      dma_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_done.set_original_access("RW");
      dma_chunk_done =
          (dv_base_reg_field::
           type_id::create("dma_chunk_done"));
      dma_chunk_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_chunk_done.set_original_access("RW");
      dma_error =
          (dv_base_reg_field::
           type_id::create("dma_error"));
      dma_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_error.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_intr_enable

  class dma_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field dma_done;
    rand dv_base_reg_field dma_chunk_done;
    rand dv_base_reg_field dma_error;

    `uvm_object_utils(dma_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      dma_done =
          (dv_base_reg_field::
           type_id::create("dma_done"));
      dma_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_done.set_original_access("WO");
      dma_chunk_done =
          (dv_base_reg_field::
           type_id::create("dma_chunk_done"));
      dma_chunk_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_chunk_done.set_original_access("WO");
      dma_error =
          (dv_base_reg_field::
           type_id::create("dma_error"));
      dma_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dma_error.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : dma_reg_intr_test

  class dma_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(dma_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : dma_reg_alert_test

  class dma_reg_src_addr_lo extends dv_base_reg;
    // fields
    rand dv_base_reg_field src_addr_lo;

    `uvm_object_utils(dma_reg_src_addr_lo)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      src_addr_lo =
          (dv_base_reg_field::
           type_id::create("src_addr_lo"));
      src_addr_lo.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      src_addr_lo.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_src_addr_lo

  class dma_reg_src_addr_hi extends dv_base_reg;
    // fields
    rand dv_base_reg_field src_addr_hi;

    `uvm_object_utils(dma_reg_src_addr_hi)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      src_addr_hi =
          (dv_base_reg_field::
           type_id::create("src_addr_hi"));
      src_addr_hi.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      src_addr_hi.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_src_addr_hi

  class dma_reg_dst_addr_lo extends dv_base_reg;
    // fields
    rand dv_base_reg_field dst_addr_lo;

    `uvm_object_utils(dma_reg_dst_addr_lo)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      dst_addr_lo =
          (dv_base_reg_field::
           type_id::create("dst_addr_lo"));
      dst_addr_lo.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dst_addr_lo.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_dst_addr_lo

  class dma_reg_dst_addr_hi extends dv_base_reg;
    // fields
    rand dv_base_reg_field dst_addr_hi;

    `uvm_object_utils(dma_reg_dst_addr_hi)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      dst_addr_hi =
          (dv_base_reg_field::
           type_id::create("dst_addr_hi"));
      dst_addr_hi.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dst_addr_hi.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_dst_addr_hi

  class dma_reg_addr_space_id extends dv_base_reg;
    // fields
    rand dv_base_reg_field src_asid;
    rand dv_base_reg_field dst_asid;

    `uvm_object_utils(dma_reg_addr_space_id)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      src_asid =
          (dv_base_reg_field::
           type_id::create("src_asid"));
      src_asid.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      src_asid.set_original_access("RW");
      dst_asid =
          (dv_base_reg_field::
           type_id::create("dst_asid"));
      dst_asid.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dst_asid.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_addr_space_id

  class dma_reg_enabled_memory_range_base extends dv_base_reg;
    // fields
    rand dv_base_reg_field base;

    `uvm_object_utils(dma_reg_enabled_memory_range_base)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      base =
          (dv_base_reg_field::
           type_id::create("base"));
      base.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      base.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_enabled_memory_range_base

  class dma_reg_enabled_memory_range_limit extends dv_base_reg;
    // fields
    rand dv_base_reg_field limit;

    `uvm_object_utils(dma_reg_enabled_memory_range_limit)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      limit =
          (dv_base_reg_field::
           type_id::create("limit"));
      limit.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      limit.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_enabled_memory_range_limit

  class dma_reg_range_valid extends dv_base_reg;
    // fields
    rand dv_base_reg_field range_valid;

    `uvm_object_utils(dma_reg_range_valid)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      range_valid =
          (dv_base_reg_field::
           type_id::create("range_valid"));
      range_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      range_valid.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_range_valid

  class dma_reg_range_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field regwen;

    `uvm_object_utils(dma_reg_range_regwen)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      regwen =
          (dv_base_reg_field::
           type_id::create("regwen"));
      regwen.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("W0C"),
        .volatile(0),
        .reset(32'h6),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      regwen.set_original_access("RW");
      regwen.set_mubi_width(4);
    endfunction : build
  endclass : dma_reg_range_regwen

  class dma_reg_cfg_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field regwen;

    `uvm_object_utils(dma_reg_cfg_regwen)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      regwen =
          (dv_base_reg_field::
           type_id::create("regwen"));
      regwen.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("RO"),
        .volatile(1),
        .reset(32'h6),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      regwen.set_original_access("RO");
      regwen.set_mubi_width(4);
      set_is_ext_reg(1);
    endfunction : build
  endclass : dma_reg_cfg_regwen

  class dma_reg_total_data_size extends dv_base_reg;
    // fields
    rand dv_base_reg_field data_size;

    `uvm_object_utils(dma_reg_total_data_size)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data_size =
          (dv_base_reg_field::
           type_id::create("data_size"));
      data_size.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data_size.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_total_data_size

  class dma_reg_chunk_data_size extends dv_base_reg;
    // fields
    rand dv_base_reg_field data_size;

    `uvm_object_utils(dma_reg_chunk_data_size)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data_size =
          (dv_base_reg_field::
           type_id::create("data_size"));
      data_size.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data_size.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_chunk_data_size

  class dma_reg_transfer_width extends dv_base_reg;
    // fields
    rand dv_base_reg_field transaction_width;

    `uvm_object_utils(dma_reg_transfer_width)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      transaction_width =
          (dv_base_reg_field::
           type_id::create("transaction_width"));
      transaction_width.configure(
        .parent(this),
        .size(2),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h2),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      transaction_width.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_transfer_width

  class dma_reg_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field opcode;
    rand dv_base_reg_field hardware_handshake_enable;
    rand dv_base_reg_field digest_swap;
    rand dv_base_reg_field initial_transfer;
    rand dv_base_reg_field abort;
    rand dv_base_reg_field go;

    `uvm_object_utils(dma_reg_control)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      opcode =
          (dv_base_reg_field::
           type_id::create("opcode"));
      opcode.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      opcode.set_original_access("RW");
      hardware_handshake_enable =
          (dv_base_reg_field::
           type_id::create("hardware_handshake_enable"));
      hardware_handshake_enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hardware_handshake_enable.set_original_access("RW");
      digest_swap =
          (dv_base_reg_field::
           type_id::create("digest_swap"));
      digest_swap.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      digest_swap.set_original_access("RW");
      initial_transfer =
          (dv_base_reg_field::
           type_id::create("initial_transfer"));
      initial_transfer.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      initial_transfer.set_original_access("RW");
      abort =
          (dv_base_reg_field::
           type_id::create("abort"));
      abort.configure(
        .parent(this),
        .size(1),
        .lsb_pos(27),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      abort.set_original_access("WO");
      go =
          (dv_base_reg_field::
           type_id::create("go"));
      go.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      go.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_control

  class dma_reg_src_config extends dv_base_reg;
    // fields
    rand dv_base_reg_field increment;
    rand dv_base_reg_field wrap;

    `uvm_object_utils(dma_reg_src_config)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      increment =
          (dv_base_reg_field::
           type_id::create("increment"));
      increment.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      increment.set_original_access("RW");
      wrap =
          (dv_base_reg_field::
           type_id::create("wrap"));
      wrap.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wrap.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_src_config

  class dma_reg_dst_config extends dv_base_reg;
    // fields
    rand dv_base_reg_field increment;
    rand dv_base_reg_field wrap;

    `uvm_object_utils(dma_reg_dst_config)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      increment =
          (dv_base_reg_field::
           type_id::create("increment"));
      increment.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      increment.set_original_access("RW");
      wrap =
          (dv_base_reg_field::
           type_id::create("wrap"));
      wrap.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wrap.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_dst_config

  class dma_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field busy;
    rand dv_base_reg_field done;
    rand dv_base_reg_field aborted;
    rand dv_base_reg_field error;
    rand dv_base_reg_field sha2_digest_valid;
    rand dv_base_reg_field chunk_done;

    `uvm_object_utils(dma_reg_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      busy =
          (dv_base_reg_field::
           type_id::create("busy"));
      busy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      busy.set_original_access("RO");
      done =
          (dv_base_reg_field::
           type_id::create("done"));
      done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done.set_original_access("W1C");
      aborted =
          (dv_base_reg_field::
           type_id::create("aborted"));
      aborted.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      aborted.set_original_access("W1C");
      error =
          (dv_base_reg_field::
           type_id::create("error"));
      error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      error.set_original_access("W1C");
      sha2_digest_valid =
          (dv_base_reg_field::
           type_id::create("sha2_digest_valid"));
      sha2_digest_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha2_digest_valid.set_original_access("RO");
      chunk_done =
          (dv_base_reg_field::
           type_id::create("chunk_done"));
      chunk_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      chunk_done.set_original_access("W1C");
    endfunction : build
  endclass : dma_reg_status

  class dma_reg_error_code extends dv_base_reg;
    // fields
    rand dv_base_reg_field src_addr_error;
    rand dv_base_reg_field dst_addr_error;
    rand dv_base_reg_field opcode_error;
    rand dv_base_reg_field size_error;
    rand dv_base_reg_field bus_error;
    rand dv_base_reg_field base_limit_error;
    rand dv_base_reg_field range_valid_error;
    rand dv_base_reg_field asid_error;

    `uvm_object_utils(dma_reg_error_code)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      src_addr_error =
          (dv_base_reg_field::
           type_id::create("src_addr_error"));
      src_addr_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      src_addr_error.set_original_access("RO");
      dst_addr_error =
          (dv_base_reg_field::
           type_id::create("dst_addr_error"));
      dst_addr_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dst_addr_error.set_original_access("RO");
      opcode_error =
          (dv_base_reg_field::
           type_id::create("opcode_error"));
      opcode_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      opcode_error.set_original_access("RO");
      size_error =
          (dv_base_reg_field::
           type_id::create("size_error"));
      size_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      size_error.set_original_access("RO");
      bus_error =
          (dv_base_reg_field::
           type_id::create("bus_error"));
      bus_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_error.set_original_access("RO");
      base_limit_error =
          (dv_base_reg_field::
           type_id::create("base_limit_error"));
      base_limit_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      base_limit_error.set_original_access("RO");
      range_valid_error =
          (dv_base_reg_field::
           type_id::create("range_valid_error"));
      range_valid_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      range_valid_error.set_original_access("RO");
      asid_error =
          (dv_base_reg_field::
           type_id::create("asid_error"));
      asid_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      asid_error.set_original_access("RO");
    endfunction : build
  endclass : dma_reg_error_code

  class dma_reg_sha2_digest extends dv_base_reg;
    // fields
    rand dv_base_reg_field data;

    `uvm_object_utils(dma_reg_sha2_digest)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data =
          (dv_base_reg_field::
           type_id::create("data_0"));
      data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data.set_original_access("RO");
    endfunction : build
  endclass : dma_reg_sha2_digest

  class dma_reg_handshake_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field mask;

    `uvm_object_utils(dma_reg_handshake_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      mask =
          (dv_base_reg_field::
           type_id::create("mask"));
      mask.configure(
        .parent(this),
        .size(11),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7ff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mask.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_handshake_intr_enable

  class dma_reg_clear_intr_src extends dv_base_reg;
    // fields
    rand dv_base_reg_field source;

    `uvm_object_utils(dma_reg_clear_intr_src)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      source =
          (dv_base_reg_field::
           type_id::create("source"));
      source.configure(
        .parent(this),
        .size(11),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      source.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_clear_intr_src

  class dma_reg_clear_intr_bus extends dv_base_reg;
    // fields
    rand dv_base_reg_field bus;

    `uvm_object_utils(dma_reg_clear_intr_bus)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      bus =
          (dv_base_reg_field::
           type_id::create("bus"));
      bus.configure(
        .parent(this),
        .size(11),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_clear_intr_bus

  class dma_reg_intr_src_addr extends dv_base_reg;
    // fields
    rand dv_base_reg_field addr;

    `uvm_object_utils(dma_reg_intr_src_addr)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      addr =
          (dv_base_reg_field::
           type_id::create("addr_0"));
      addr.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addr.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_intr_src_addr

  class dma_reg_intr_src_wr_val extends dv_base_reg;
    // fields
    rand dv_base_reg_field wr_val;

    `uvm_object_utils(dma_reg_intr_src_wr_val)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      wr_val =
          (dv_base_reg_field::
           type_id::create("wr_val_0"));
      wr_val.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wr_val.set_original_access("RW");
    endfunction : build
  endclass : dma_reg_intr_src_wr_val

  class dma_reg_block extends dv_base_reg_block;
    // registers
    rand dma_reg_intr_state intr_state;
    rand dma_reg_intr_enable intr_enable;
    rand dma_reg_intr_test intr_test;
    rand dma_reg_alert_test alert_test;
    rand dma_reg_src_addr_lo src_addr_lo;
    rand dma_reg_src_addr_hi src_addr_hi;
    rand dma_reg_dst_addr_lo dst_addr_lo;
    rand dma_reg_dst_addr_hi dst_addr_hi;
    rand dma_reg_addr_space_id addr_space_id;
    rand dma_reg_enabled_memory_range_base enabled_memory_range_base;
    rand dma_reg_enabled_memory_range_limit enabled_memory_range_limit;
    rand dma_reg_range_valid range_valid;
    rand dma_reg_range_regwen range_regwen;
    rand dma_reg_cfg_regwen cfg_regwen;
    rand dma_reg_total_data_size total_data_size;
    rand dma_reg_chunk_data_size chunk_data_size;
    rand dma_reg_transfer_width transfer_width;
    rand dma_reg_control control;
    rand dma_reg_src_config src_config;
    rand dma_reg_dst_config dst_config;
    rand dma_reg_status status;
    rand dma_reg_error_code error_code;
    rand dma_reg_sha2_digest sha2_digest[16];
    rand dma_reg_handshake_intr_enable handshake_intr_enable;
    rand dma_reg_clear_intr_src clear_intr_src;
    rand dma_reg_clear_intr_bus clear_intr_bus;
    rand dma_reg_intr_src_addr intr_src_addr[11];
    rand dma_reg_intr_src_wr_val intr_src_wr_val[11];

    `uvm_object_utils(dma_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (dma_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_dma_reg.u_intr_state_dma_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_dma_reg.u_intr_state_dma_chunk_done.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_dma_reg.u_intr_state_dma_error.q",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (dma_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_dma_reg.u_intr_enable_dma_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_dma_reg.u_intr_enable_dma_chunk_done.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_dma_reg.u_intr_enable_dma_error.q",
          2, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (dma_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_dma_reg.u_intr_test_dma_done.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_dma_reg.u_intr_test_dma_chunk_done.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_dma_reg.u_intr_test_dma_error.qs",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (dma_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_dma_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      src_addr_lo =
          (dma_reg_src_addr_lo::
           type_id::create("src_addr_lo"));
      src_addr_lo.configure(.blk_parent(this));
      src_addr_lo.build(csr_excl);
      default_map.add_reg(.rg(src_addr_lo),
                          .offset(32'h10));
      src_addr_lo.add_hdl_path_slice(
          "u_dma_reg.u_src_addr_lo.q",
          0, 32, 0, "BkdrRegPathRtl");

      src_addr_hi =
          (dma_reg_src_addr_hi::
           type_id::create("src_addr_hi"));
      src_addr_hi.configure(.blk_parent(this));
      src_addr_hi.build(csr_excl);
      default_map.add_reg(.rg(src_addr_hi),
                          .offset(32'h14));
      src_addr_hi.add_hdl_path_slice(
          "u_dma_reg.u_src_addr_hi.q",
          0, 32, 0, "BkdrRegPathRtl");

      dst_addr_lo =
          (dma_reg_dst_addr_lo::
           type_id::create("dst_addr_lo"));
      dst_addr_lo.configure(.blk_parent(this));
      dst_addr_lo.build(csr_excl);
      default_map.add_reg(.rg(dst_addr_lo),
                          .offset(32'h18));
      dst_addr_lo.add_hdl_path_slice(
          "u_dma_reg.u_dst_addr_lo.q",
          0, 32, 0, "BkdrRegPathRtl");

      dst_addr_hi =
          (dma_reg_dst_addr_hi::
           type_id::create("dst_addr_hi"));
      dst_addr_hi.configure(.blk_parent(this));
      dst_addr_hi.build(csr_excl);
      default_map.add_reg(.rg(dst_addr_hi),
                          .offset(32'h1c));
      dst_addr_hi.add_hdl_path_slice(
          "u_dma_reg.u_dst_addr_hi.q",
          0, 32, 0, "BkdrRegPathRtl");

      addr_space_id =
          (dma_reg_addr_space_id::
           type_id::create("addr_space_id"));
      addr_space_id.configure(.blk_parent(this));
      addr_space_id.build(csr_excl);
      default_map.add_reg(.rg(addr_space_id),
                          .offset(32'h20));
      addr_space_id.add_hdl_path_slice(
          "u_dma_reg.u_addr_space_id_src_asid.q",
          0, 4, 0, "BkdrRegPathRtl");
      addr_space_id.add_hdl_path_slice(
          "u_dma_reg.u_addr_space_id_dst_asid.q",
          4, 4, 0, "BkdrRegPathRtl");

      enabled_memory_range_base =
          (dma_reg_enabled_memory_range_base::
           type_id::create("enabled_memory_range_base"));
      enabled_memory_range_base.configure(.blk_parent(this));
      enabled_memory_range_base.build(csr_excl);
      default_map.add_reg(.rg(enabled_memory_range_base),
                          .offset(32'h24));
      enabled_memory_range_base.add_hdl_path_slice(
          "u_dma_reg.u_enabled_memory_range_base.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(enabled_memory_range_base.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      enabled_memory_range_limit =
          (dma_reg_enabled_memory_range_limit::
           type_id::create("enabled_memory_range_limit"));
      enabled_memory_range_limit.configure(.blk_parent(this));
      enabled_memory_range_limit.build(csr_excl);
      default_map.add_reg(.rg(enabled_memory_range_limit),
                          .offset(32'h28));
      enabled_memory_range_limit.add_hdl_path_slice(
          "u_dma_reg.u_enabled_memory_range_limit.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(enabled_memory_range_limit.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      range_valid =
          (dma_reg_range_valid::
           type_id::create("range_valid"));
      range_valid.configure(.blk_parent(this));
      range_valid.build(csr_excl);
      default_map.add_reg(.rg(range_valid),
                          .offset(32'h2c));
      range_valid.add_hdl_path_slice(
          "u_dma_reg.u_range_valid.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(range_valid.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      range_regwen =
          (dma_reg_range_regwen::
           type_id::create("range_regwen"));
      range_regwen.configure(.blk_parent(this));
      range_regwen.build(csr_excl);
      default_map.add_reg(.rg(range_regwen),
                          .offset(32'h30));
      range_regwen.add_hdl_path_slice(
          "u_dma_reg.u_range_regwen.q",
          0, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(range_regwen.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      cfg_regwen =
          (dma_reg_cfg_regwen::
           type_id::create("cfg_regwen"));
      cfg_regwen.configure(.blk_parent(this));
      cfg_regwen.build(csr_excl);
      default_map.add_reg(.rg(cfg_regwen),
                          .offset(32'h34));
      cfg_regwen.add_hdl_path_slice(
          "u_dma_reg.u_cfg_regwen.qs",
          0, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(cfg_regwen.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      total_data_size =
          (dma_reg_total_data_size::
           type_id::create("total_data_size"));
      total_data_size.configure(.blk_parent(this));
      total_data_size.build(csr_excl);
      default_map.add_reg(.rg(total_data_size),
                          .offset(32'h38));
      total_data_size.add_hdl_path_slice(
          "u_dma_reg.u_total_data_size.q",
          0, 32, 0, "BkdrRegPathRtl");

      chunk_data_size =
          (dma_reg_chunk_data_size::
           type_id::create("chunk_data_size"));
      chunk_data_size.configure(.blk_parent(this));
      chunk_data_size.build(csr_excl);
      default_map.add_reg(.rg(chunk_data_size),
                          .offset(32'h3c));
      chunk_data_size.add_hdl_path_slice(
          "u_dma_reg.u_chunk_data_size.q",
          0, 32, 0, "BkdrRegPathRtl");

      transfer_width =
          (dma_reg_transfer_width::
           type_id::create("transfer_width"));
      transfer_width.configure(.blk_parent(this));
      transfer_width.build(csr_excl);
      default_map.add_reg(.rg(transfer_width),
                          .offset(32'h40));
      transfer_width.add_hdl_path_slice(
          "u_dma_reg.u_transfer_width.q",
          0, 2, 0, "BkdrRegPathRtl");

      control =
          (dma_reg_control::
           type_id::create("control"));
      control.configure(.blk_parent(this));
      control.build(csr_excl);
      default_map.add_reg(.rg(control),
                          .offset(32'h44));
      control.add_hdl_path_slice(
          "u_dma_reg.u_control_opcode.q",
          0, 4, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_dma_reg.u_control_hardware_handshake_enable.q",
          4, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_dma_reg.u_control_digest_swap.q",
          5, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_dma_reg.u_control_initial_transfer.q",
          8, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_dma_reg.u_control_abort.q",
          27, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_dma_reg.u_control_go.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(control.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      src_config =
          (dma_reg_src_config::
           type_id::create("src_config"));
      src_config.configure(.blk_parent(this));
      src_config.build(csr_excl);
      default_map.add_reg(.rg(src_config),
                          .offset(32'h48));
      src_config.add_hdl_path_slice(
          "u_dma_reg.u_src_config_increment.q",
          0, 1, 0, "BkdrRegPathRtl");
      src_config.add_hdl_path_slice(
          "u_dma_reg.u_src_config_wrap.q",
          1, 1, 0, "BkdrRegPathRtl");

      dst_config =
          (dma_reg_dst_config::
           type_id::create("dst_config"));
      dst_config.configure(.blk_parent(this));
      dst_config.build(csr_excl);
      default_map.add_reg(.rg(dst_config),
                          .offset(32'h4c));
      dst_config.add_hdl_path_slice(
          "u_dma_reg.u_dst_config_increment.q",
          0, 1, 0, "BkdrRegPathRtl");
      dst_config.add_hdl_path_slice(
          "u_dma_reg.u_dst_config_wrap.q",
          1, 1, 0, "BkdrRegPathRtl");

      status =
          (dma_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h50));
      status.add_hdl_path_slice(
          "u_dma_reg.u_status_busy.q",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_dma_reg.u_status_done.q",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_dma_reg.u_status_aborted.q",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_dma_reg.u_status_error.q",
          3, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_dma_reg.u_status_sha2_digest_valid.q",
          4, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_dma_reg.u_status_chunk_done.q",
          5, 1, 0, "BkdrRegPathRtl");

      error_code =
          (dma_reg_error_code::
           type_id::create("error_code"));
      error_code.configure(.blk_parent(this));
      error_code.build(csr_excl);
      default_map.add_reg(.rg(error_code),
                          .offset(32'h54));
      error_code.add_hdl_path_slice(
          "u_dma_reg.u_error_code_src_addr_error.q",
          0, 1, 0, "BkdrRegPathRtl");
      error_code.add_hdl_path_slice(
          "u_dma_reg.u_error_code_dst_addr_error.q",
          1, 1, 0, "BkdrRegPathRtl");
      error_code.add_hdl_path_slice(
          "u_dma_reg.u_error_code_opcode_error.q",
          2, 1, 0, "BkdrRegPathRtl");
      error_code.add_hdl_path_slice(
          "u_dma_reg.u_error_code_size_error.q",
          3, 1, 0, "BkdrRegPathRtl");
      error_code.add_hdl_path_slice(
          "u_dma_reg.u_error_code_bus_error.q",
          4, 1, 0, "BkdrRegPathRtl");
      error_code.add_hdl_path_slice(
          "u_dma_reg.u_error_code_base_limit_error.q",
          5, 1, 0, "BkdrRegPathRtl");
      error_code.add_hdl_path_slice(
          "u_dma_reg.u_error_code_range_valid_error.q",
          6, 1, 0, "BkdrRegPathRtl");
      error_code.add_hdl_path_slice(
          "u_dma_reg.u_error_code_asid_error.q",
          7, 1, 0, "BkdrRegPathRtl");

      sha2_digest[0] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_0"));
      sha2_digest[0].configure(.blk_parent(this));
      sha2_digest[0].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[0]),
                          .offset(32'h58));
      sha2_digest[0].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[1] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_1"));
      sha2_digest[1].configure(.blk_parent(this));
      sha2_digest[1].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[1]),
                          .offset(32'h5c));
      sha2_digest[1].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[2] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_2"));
      sha2_digest[2].configure(.blk_parent(this));
      sha2_digest[2].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[2]),
                          .offset(32'h60));
      sha2_digest[2].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[3] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_3"));
      sha2_digest[3].configure(.blk_parent(this));
      sha2_digest[3].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[3]),
                          .offset(32'h64));
      sha2_digest[3].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[4] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_4"));
      sha2_digest[4].configure(.blk_parent(this));
      sha2_digest[4].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[4]),
                          .offset(32'h68));
      sha2_digest[4].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[5] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_5"));
      sha2_digest[5].configure(.blk_parent(this));
      sha2_digest[5].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[5]),
                          .offset(32'h6c));
      sha2_digest[5].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[6] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_6"));
      sha2_digest[6].configure(.blk_parent(this));
      sha2_digest[6].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[6]),
                          .offset(32'h70));
      sha2_digest[6].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[7] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_7"));
      sha2_digest[7].configure(.blk_parent(this));
      sha2_digest[7].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[7]),
                          .offset(32'h74));
      sha2_digest[7].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[8] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_8"));
      sha2_digest[8].configure(.blk_parent(this));
      sha2_digest[8].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[8]),
                          .offset(32'h78));
      sha2_digest[8].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_8.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[9] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_9"));
      sha2_digest[9].configure(.blk_parent(this));
      sha2_digest[9].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[9]),
                          .offset(32'h7c));
      sha2_digest[9].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_9.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[10] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_10"));
      sha2_digest[10].configure(.blk_parent(this));
      sha2_digest[10].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[10]),
                          .offset(32'h80));
      sha2_digest[10].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_10.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[11] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_11"));
      sha2_digest[11].configure(.blk_parent(this));
      sha2_digest[11].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[11]),
                          .offset(32'h84));
      sha2_digest[11].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_11.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[12] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_12"));
      sha2_digest[12].configure(.blk_parent(this));
      sha2_digest[12].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[12]),
                          .offset(32'h88));
      sha2_digest[12].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_12.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[13] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_13"));
      sha2_digest[13].configure(.blk_parent(this));
      sha2_digest[13].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[13]),
                          .offset(32'h8c));
      sha2_digest[13].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_13.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[14] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_14"));
      sha2_digest[14].configure(.blk_parent(this));
      sha2_digest[14].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[14]),
                          .offset(32'h90));
      sha2_digest[14].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_14.q",
          0, 32, 0, "BkdrRegPathRtl");

      sha2_digest[15] =
          (dma_reg_sha2_digest::
           type_id::create("sha2_digest_15"));
      sha2_digest[15].configure(.blk_parent(this));
      sha2_digest[15].build(csr_excl);
      default_map.add_reg(.rg(sha2_digest[15]),
                          .offset(32'h94));
      sha2_digest[15].add_hdl_path_slice(
          "u_dma_reg.u_sha2_digest_15.q",
          0, 32, 0, "BkdrRegPathRtl");

      handshake_intr_enable =
          (dma_reg_handshake_intr_enable::
           type_id::create("handshake_intr_enable"));
      handshake_intr_enable.configure(.blk_parent(this));
      handshake_intr_enable.build(csr_excl);
      default_map.add_reg(.rg(handshake_intr_enable),
                          .offset(32'h98));
      handshake_intr_enable.add_hdl_path_slice(
          "u_dma_reg.u_handshake_intr_enable.q",
          0, 11, 0, "BkdrRegPathRtl");

      clear_intr_src =
          (dma_reg_clear_intr_src::
           type_id::create("clear_intr_src"));
      clear_intr_src.configure(.blk_parent(this));
      clear_intr_src.build(csr_excl);
      default_map.add_reg(.rg(clear_intr_src),
                          .offset(32'h9c));
      clear_intr_src.add_hdl_path_slice(
          "u_dma_reg.u_clear_intr_src.q",
          0, 11, 0, "BkdrRegPathRtl");

      clear_intr_bus =
          (dma_reg_clear_intr_bus::
           type_id::create("clear_intr_bus"));
      clear_intr_bus.configure(.blk_parent(this));
      clear_intr_bus.build(csr_excl);
      default_map.add_reg(.rg(clear_intr_bus),
                          .offset(32'ha0));
      clear_intr_bus.add_hdl_path_slice(
          "u_dma_reg.u_clear_intr_bus.q",
          0, 11, 0, "BkdrRegPathRtl");

      intr_src_addr[0] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_0"));
      intr_src_addr[0].configure(.blk_parent(this));
      intr_src_addr[0].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[0]),
                          .offset(32'ha4));
      intr_src_addr[0].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[1] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_1"));
      intr_src_addr[1].configure(.blk_parent(this));
      intr_src_addr[1].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[1]),
                          .offset(32'ha8));
      intr_src_addr[1].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[2] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_2"));
      intr_src_addr[2].configure(.blk_parent(this));
      intr_src_addr[2].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[2]),
                          .offset(32'hac));
      intr_src_addr[2].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[3] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_3"));
      intr_src_addr[3].configure(.blk_parent(this));
      intr_src_addr[3].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[3]),
                          .offset(32'hb0));
      intr_src_addr[3].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[4] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_4"));
      intr_src_addr[4].configure(.blk_parent(this));
      intr_src_addr[4].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[4]),
                          .offset(32'hb4));
      intr_src_addr[4].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[5] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_5"));
      intr_src_addr[5].configure(.blk_parent(this));
      intr_src_addr[5].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[5]),
                          .offset(32'hb8));
      intr_src_addr[5].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[6] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_6"));
      intr_src_addr[6].configure(.blk_parent(this));
      intr_src_addr[6].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[6]),
                          .offset(32'hbc));
      intr_src_addr[6].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[7] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_7"));
      intr_src_addr[7].configure(.blk_parent(this));
      intr_src_addr[7].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[7]),
                          .offset(32'hc0));
      intr_src_addr[7].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[8] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_8"));
      intr_src_addr[8].configure(.blk_parent(this));
      intr_src_addr[8].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[8]),
                          .offset(32'hc4));
      intr_src_addr[8].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_8.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[9] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_9"));
      intr_src_addr[9].configure(.blk_parent(this));
      intr_src_addr[9].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[9]),
                          .offset(32'hc8));
      intr_src_addr[9].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_9.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_addr[10] =
          (dma_reg_intr_src_addr::
           type_id::create("intr_src_addr_10"));
      intr_src_addr[10].configure(.blk_parent(this));
      intr_src_addr[10].build(csr_excl);
      default_map.add_reg(.rg(intr_src_addr[10]),
                          .offset(32'hcc));
      intr_src_addr[10].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_addr_10.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[0] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_0"));
      intr_src_wr_val[0].configure(.blk_parent(this));
      intr_src_wr_val[0].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[0]),
                          .offset(32'h124));
      intr_src_wr_val[0].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[1] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_1"));
      intr_src_wr_val[1].configure(.blk_parent(this));
      intr_src_wr_val[1].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[1]),
                          .offset(32'h128));
      intr_src_wr_val[1].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[2] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_2"));
      intr_src_wr_val[2].configure(.blk_parent(this));
      intr_src_wr_val[2].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[2]),
                          .offset(32'h12c));
      intr_src_wr_val[2].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[3] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_3"));
      intr_src_wr_val[3].configure(.blk_parent(this));
      intr_src_wr_val[3].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[3]),
                          .offset(32'h130));
      intr_src_wr_val[3].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[4] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_4"));
      intr_src_wr_val[4].configure(.blk_parent(this));
      intr_src_wr_val[4].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[4]),
                          .offset(32'h134));
      intr_src_wr_val[4].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[5] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_5"));
      intr_src_wr_val[5].configure(.blk_parent(this));
      intr_src_wr_val[5].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[5]),
                          .offset(32'h138));
      intr_src_wr_val[5].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[6] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_6"));
      intr_src_wr_val[6].configure(.blk_parent(this));
      intr_src_wr_val[6].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[6]),
                          .offset(32'h13c));
      intr_src_wr_val[6].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[7] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_7"));
      intr_src_wr_val[7].configure(.blk_parent(this));
      intr_src_wr_val[7].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[7]),
                          .offset(32'h140));
      intr_src_wr_val[7].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[8] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_8"));
      intr_src_wr_val[8].configure(.blk_parent(this));
      intr_src_wr_val[8].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[8]),
                          .offset(32'h144));
      intr_src_wr_val[8].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_8.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[9] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_9"));
      intr_src_wr_val[9].configure(.blk_parent(this));
      intr_src_wr_val[9].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[9]),
                          .offset(32'h148));
      intr_src_wr_val[9].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_9.q",
          0, 32, 0, "BkdrRegPathRtl");

      intr_src_wr_val[10] =
          (dma_reg_intr_src_wr_val::
           type_id::create("intr_src_wr_val_10"));
      intr_src_wr_val[10].configure(.blk_parent(this));
      intr_src_wr_val[10].build(csr_excl);
      default_map.add_reg(.rg(intr_src_wr_val[10]),
                          .offset(32'h14c));
      intr_src_wr_val[10].add_hdl_path_slice(
          "u_dma_reg.u_intr_src_wr_val_10.q",
          0, 32, 0, "BkdrRegPathRtl");

      // assign locked reg to its regwen reg
      cfg_regwen.add_lockable_reg_or_fld(src_addr_lo);
      cfg_regwen.add_lockable_reg_or_fld(src_addr_hi);
      cfg_regwen.add_lockable_reg_or_fld(dst_addr_lo);
      cfg_regwen.add_lockable_reg_or_fld(dst_addr_hi);
      cfg_regwen.add_lockable_reg_or_fld(addr_space_id);
      range_regwen.add_lockable_reg_or_fld(enabled_memory_range_base);
      range_regwen.add_lockable_reg_or_fld(enabled_memory_range_limit);
      range_regwen.add_lockable_reg_or_fld(range_valid);
      cfg_regwen.add_lockable_reg_or_fld(total_data_size);
      cfg_regwen.add_lockable_reg_or_fld(chunk_data_size);
      cfg_regwen.add_lockable_reg_or_fld(transfer_width);
      cfg_regwen.add_lockable_reg_or_fld(src_config);
      cfg_regwen.add_lockable_reg_or_fld(dst_config);
      cfg_regwen.add_lockable_reg_or_fld(handshake_intr_enable);
      cfg_regwen.add_lockable_reg_or_fld(clear_intr_src);
      cfg_regwen.add_lockable_reg_or_fld(clear_intr_bus);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[0]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[1]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[2]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[3]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[4]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[5]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[6]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[7]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[8]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[9]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_addr[10]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[0]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[1]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[2]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[3]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[4]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[5]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[6]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[7]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[8]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[9]);
      cfg_regwen.add_lockable_reg_or_fld(intr_src_wr_val[10]);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : dma_reg_block

endpackage

