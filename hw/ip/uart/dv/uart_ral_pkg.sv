// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package uart_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class uart_reg_intr_state;
  typedef class uart_reg_intr_enable;
  typedef class uart_reg_intr_test;
  typedef class uart_reg_alert_test;
  typedef class uart_reg_ctrl;
  typedef class uart_reg_status;
  typedef class uart_reg_rdata;
  typedef class uart_reg_wdata;
  typedef class uart_reg_fifo_ctrl;
  typedef class uart_reg_fifo_status;
  typedef class uart_reg_ovrd;
  typedef class uart_reg_val;
  typedef class uart_reg_timeout_ctrl;
  typedef class uart_reg_block;

  class uart_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field tx_watermark;
    rand dv_base_reg_field rx_watermark;
    rand dv_base_reg_field tx_done;
    rand dv_base_reg_field rx_overflow;
    rand dv_base_reg_field rx_frame_err;
    rand dv_base_reg_field rx_break_err;
    rand dv_base_reg_field rx_timeout;
    rand dv_base_reg_field rx_parity_err;
    rand dv_base_reg_field tx_empty;

    `uvm_object_utils(uart_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tx_watermark =
          (dv_base_reg_field::
           type_id::create("tx_watermark"));
      tx_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_watermark.set_original_access("RO");
      rx_watermark =
          (dv_base_reg_field::
           type_id::create("rx_watermark"));
      rx_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_watermark.set_original_access("RO");
      tx_done =
          (dv_base_reg_field::
           type_id::create("tx_done"));
      tx_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_done.set_original_access("W1C");
      rx_overflow =
          (dv_base_reg_field::
           type_id::create("rx_overflow"));
      rx_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_overflow.set_original_access("W1C");
      rx_frame_err =
          (dv_base_reg_field::
           type_id::create("rx_frame_err"));
      rx_frame_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_frame_err.set_original_access("W1C");
      rx_break_err =
          (dv_base_reg_field::
           type_id::create("rx_break_err"));
      rx_break_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_break_err.set_original_access("W1C");
      rx_timeout =
          (dv_base_reg_field::
           type_id::create("rx_timeout"));
      rx_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_timeout.set_original_access("W1C");
      rx_parity_err =
          (dv_base_reg_field::
           type_id::create("rx_parity_err"));
      rx_parity_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_parity_err.set_original_access("W1C");
      tx_empty =
          (dv_base_reg_field::
           type_id::create("tx_empty"));
      tx_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_empty.set_original_access("RO");
    endfunction : build
  endclass : uart_reg_intr_state

  class uart_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field tx_watermark;
    rand dv_base_reg_field rx_watermark;
    rand dv_base_reg_field tx_done;
    rand dv_base_reg_field rx_overflow;
    rand dv_base_reg_field rx_frame_err;
    rand dv_base_reg_field rx_break_err;
    rand dv_base_reg_field rx_timeout;
    rand dv_base_reg_field rx_parity_err;
    rand dv_base_reg_field tx_empty;

    `uvm_object_utils(uart_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tx_watermark =
          (dv_base_reg_field::
           type_id::create("tx_watermark"));
      tx_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_watermark.set_original_access("RW");
      rx_watermark =
          (dv_base_reg_field::
           type_id::create("rx_watermark"));
      rx_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_watermark.set_original_access("RW");
      tx_done =
          (dv_base_reg_field::
           type_id::create("tx_done"));
      tx_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_done.set_original_access("RW");
      rx_overflow =
          (dv_base_reg_field::
           type_id::create("rx_overflow"));
      rx_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_overflow.set_original_access("RW");
      rx_frame_err =
          (dv_base_reg_field::
           type_id::create("rx_frame_err"));
      rx_frame_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_frame_err.set_original_access("RW");
      rx_break_err =
          (dv_base_reg_field::
           type_id::create("rx_break_err"));
      rx_break_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_break_err.set_original_access("RW");
      rx_timeout =
          (dv_base_reg_field::
           type_id::create("rx_timeout"));
      rx_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_timeout.set_original_access("RW");
      rx_parity_err =
          (dv_base_reg_field::
           type_id::create("rx_parity_err"));
      rx_parity_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_parity_err.set_original_access("RW");
      tx_empty =
          (dv_base_reg_field::
           type_id::create("tx_empty"));
      tx_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_empty.set_original_access("RW");
    endfunction : build
  endclass : uart_reg_intr_enable

  class uart_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field tx_watermark;
    rand dv_base_reg_field rx_watermark;
    rand dv_base_reg_field tx_done;
    rand dv_base_reg_field rx_overflow;
    rand dv_base_reg_field rx_frame_err;
    rand dv_base_reg_field rx_break_err;
    rand dv_base_reg_field rx_timeout;
    rand dv_base_reg_field rx_parity_err;
    rand dv_base_reg_field tx_empty;

    `uvm_object_utils(uart_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tx_watermark =
          (dv_base_reg_field::
           type_id::create("tx_watermark"));
      tx_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_watermark.set_original_access("WO");
      rx_watermark =
          (dv_base_reg_field::
           type_id::create("rx_watermark"));
      rx_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_watermark.set_original_access("WO");
      tx_done =
          (dv_base_reg_field::
           type_id::create("tx_done"));
      tx_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_done.set_original_access("WO");
      rx_overflow =
          (dv_base_reg_field::
           type_id::create("rx_overflow"));
      rx_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_overflow.set_original_access("WO");
      rx_frame_err =
          (dv_base_reg_field::
           type_id::create("rx_frame_err"));
      rx_frame_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_frame_err.set_original_access("WO");
      rx_break_err =
          (dv_base_reg_field::
           type_id::create("rx_break_err"));
      rx_break_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_break_err.set_original_access("WO");
      rx_timeout =
          (dv_base_reg_field::
           type_id::create("rx_timeout"));
      rx_timeout.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_timeout.set_original_access("WO");
      rx_parity_err =
          (dv_base_reg_field::
           type_id::create("rx_parity_err"));
      rx_parity_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_parity_err.set_original_access("WO");
      tx_empty =
          (dv_base_reg_field::
           type_id::create("tx_empty"));
      tx_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_empty.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : uart_reg_intr_test

  class uart_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(uart_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : uart_reg_alert_test

  class uart_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field tx;
    rand dv_base_reg_field rx;
    rand dv_base_reg_field nf;
    rand dv_base_reg_field slpbk;
    rand dv_base_reg_field llpbk;
    rand dv_base_reg_field parity_en;
    rand dv_base_reg_field parity_odd;
    rand dv_base_reg_field rxblvl;
    rand dv_base_reg_field nco;

    `uvm_object_utils(uart_reg_ctrl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tx =
          (dv_base_reg_field::
           type_id::create("tx"));
      tx.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx.set_original_access("RW");
      rx =
          (dv_base_reg_field::
           type_id::create("rx"));
      rx.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(rx.get_full_name(), CsrExclWrite, CsrAllTests);
      nf =
          (dv_base_reg_field::
           type_id::create("nf"));
      nf.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nf.set_original_access("RW");
      slpbk =
          (dv_base_reg_field::
           type_id::create("slpbk"));
      slpbk.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      slpbk.set_original_access("RW");
      llpbk =
          (dv_base_reg_field::
           type_id::create("llpbk"));
      llpbk.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      llpbk.set_original_access("RW");
      parity_en =
          (dv_base_reg_field::
           type_id::create("parity_en"));
      parity_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      parity_en.set_original_access("RW");
      parity_odd =
          (dv_base_reg_field::
           type_id::create("parity_odd"));
      parity_odd.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      parity_odd.set_original_access("RW");
      rxblvl =
          (dv_base_reg_field::
           type_id::create("rxblvl"));
      rxblvl.configure(
        .parent(this),
        .size(2),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxblvl.set_original_access("RW");
      nco =
          (dv_base_reg_field::
           type_id::create("nco"));
      nco.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nco.set_original_access("RW");
    endfunction : build
  endclass : uart_reg_ctrl

  class uart_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field txfull;
    rand dv_base_reg_field rxfull;
    rand dv_base_reg_field txempty;
    rand dv_base_reg_field txidle;
    rand dv_base_reg_field rxidle;
    rand dv_base_reg_field rxempty;

    `uvm_object_utils(uart_reg_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      txfull =
          (dv_base_reg_field::
           type_id::create("txfull"));
      txfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txfull.set_original_access("RO");
      rxfull =
          (dv_base_reg_field::
           type_id::create("rxfull"));
      rxfull.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxfull.set_original_access("RO");
      txempty =
          (dv_base_reg_field::
           type_id::create("txempty"));
      txempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txempty.set_original_access("RO");
      txidle =
          (dv_base_reg_field::
           type_id::create("txidle"));
      txidle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txidle.set_original_access("RO");
      rxidle =
          (dv_base_reg_field::
           type_id::create("rxidle"));
      rxidle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxidle.set_original_access("RO");
      rxempty =
          (dv_base_reg_field::
           type_id::create("rxempty"));
      rxempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxempty.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : uart_reg_status

  class uart_reg_rdata extends dv_base_reg;
    // fields
    rand dv_base_reg_field rdata;

    `uvm_object_utils(uart_reg_rdata)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rdata =
          (dv_base_reg_field::
           type_id::create("rdata"));
      rdata.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rdata.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : uart_reg_rdata

  class uart_reg_wdata extends dv_base_reg;
    // fields
    rand dv_base_reg_field wdata;

    `uvm_object_utils(uart_reg_wdata)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      wdata =
          (dv_base_reg_field::
           type_id::create("wdata"));
      wdata.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wdata.set_original_access("WO");
    endfunction : build
  endclass : uart_reg_wdata

  class uart_reg_fifo_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field rxrst;
    rand dv_base_reg_field txrst;
    rand dv_base_reg_field rxilvl;
    rand dv_base_reg_field txilvl;

    `uvm_object_utils(uart_reg_fifo_ctrl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rxrst =
          (dv_base_reg_field::
           type_id::create("rxrst"));
      rxrst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxrst.set_original_access("WO");
      txrst =
          (dv_base_reg_field::
           type_id::create("txrst"));
      txrst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txrst.set_original_access("WO");
      rxilvl =
          (dv_base_reg_field::
           type_id::create("rxilvl"));
      rxilvl.configure(
        .parent(this),
        .size(3),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxilvl.set_original_access("RW");
      txilvl =
          (dv_base_reg_field::
           type_id::create("txilvl"));
      txilvl.configure(
        .parent(this),
        .size(3),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txilvl.set_original_access("RW");
    endfunction : build
  endclass : uart_reg_fifo_ctrl

  class uart_reg_fifo_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field txlvl;
    rand dv_base_reg_field rxlvl;

    `uvm_object_utils(uart_reg_fifo_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      txlvl =
          (dv_base_reg_field::
           type_id::create("txlvl"));
      txlvl.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txlvl.set_original_access("RO");
      rxlvl =
          (dv_base_reg_field::
           type_id::create("rxlvl"));
      rxlvl.configure(
        .parent(this),
        .size(8),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rxlvl.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : uart_reg_fifo_status

  class uart_reg_ovrd extends dv_base_reg;
    // fields
    rand dv_base_reg_field txen;
    rand dv_base_reg_field txval;

    `uvm_object_utils(uart_reg_ovrd)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      txen =
          (dv_base_reg_field::
           type_id::create("txen"));
      txen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txen.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(txen.get_full_name(), CsrExclWrite, CsrAllTests);
      txval =
          (dv_base_reg_field::
           type_id::create("txval"));
      txval.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      txval.set_original_access("RW");
    endfunction : build
  endclass : uart_reg_ovrd

  class uart_reg_val extends dv_base_reg;
    // fields
    rand dv_base_reg_field rx;

    `uvm_object_utils(uart_reg_val)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rx =
          (dv_base_reg_field::
           type_id::create("rx"));
      rx.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(rx.get_full_name(), CsrExclCheck, CsrNonInitTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : uart_reg_val

  class uart_reg_timeout_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field val;
    rand dv_base_reg_field en;

    `uvm_object_utils(uart_reg_timeout_ctrl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      val =
          (dv_base_reg_field::
           type_id::create("val"));
      val.configure(
        .parent(this),
        .size(24),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      val.set_original_access("RW");
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
    endfunction : build
  endclass : uart_reg_timeout_ctrl

  class uart_reg_block extends dv_base_reg_block;
    // registers
    rand uart_reg_intr_state intr_state;
    rand uart_reg_intr_enable intr_enable;
    rand uart_reg_intr_test intr_test;
    rand uart_reg_alert_test alert_test;
    rand uart_reg_ctrl ctrl;
    rand uart_reg_status status;
    rand uart_reg_rdata rdata;
    rand uart_reg_wdata wdata;
    rand uart_reg_fifo_ctrl fifo_ctrl;
    rand uart_reg_fifo_status fifo_status;
    rand uart_reg_ovrd ovrd;
    rand uart_reg_val val;
    rand uart_reg_timeout_ctrl timeout_ctrl;

    `uvm_object_utils(uart_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (uart_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_tx_watermark.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_watermark.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_tx_done.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_overflow.q",
          3, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_frame_err.q",
          4, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_break_err.q",
          5, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_timeout.q",
          6, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_rx_parity_err.q",
          7, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_tx_empty.q",
          8, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (uart_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_tx_watermark.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_watermark.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_tx_done.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_overflow.q",
          3, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_frame_err.q",
          4, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_break_err.q",
          5, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_timeout.q",
          6, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_rx_parity_err.q",
          7, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_tx_empty.q",
          8, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (uart_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_tx_watermark.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_watermark.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_tx_done.qs",
          2, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_overflow.qs",
          3, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_frame_err.qs",
          4, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_break_err.qs",
          5, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_timeout.qs",
          6, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_rx_parity_err.qs",
          7, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_tx_empty.qs",
          8, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (uart_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      ctrl =
          (uart_reg_ctrl::
           type_id::create("ctrl"));
      ctrl.configure(.blk_parent(this));
      ctrl.build(csr_excl);
      default_map.add_reg(.rg(ctrl),
                          .offset(32'h10));
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_tx.q",
          0, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_rx.q",
          1, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_nf.q",
          2, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_slpbk.q",
          4, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_llpbk.q",
          5, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_parity_en.q",
          6, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_parity_odd.q",
          7, 1, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_rxblvl.q",
          8, 2, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_nco.q",
          16, 16, 0, "BkdrRegPathRtl");

      status =
          (uart_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h14));
      status.add_hdl_path_slice(
          "u_reg.u_status_txfull.qs",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxfull.qs",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_txempty.qs",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_txidle.qs",
          3, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxidle.qs",
          4, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_rxempty.qs",
          5, 1, 0, "BkdrRegPathRtl");

      rdata =
          (uart_reg_rdata::
           type_id::create("rdata"));
      rdata.configure(.blk_parent(this));
      rdata.build(csr_excl);
      default_map.add_reg(.rg(rdata),
                          .offset(32'h18));
      rdata.add_hdl_path_slice(
          "u_reg.u_rdata.qs",
          0, 8, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(rdata.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      wdata =
          (uart_reg_wdata::
           type_id::create("wdata"));
      wdata.configure(.blk_parent(this));
      wdata.build(csr_excl);
      default_map.add_reg(.rg(wdata),
                          .offset(32'h1c));
      wdata.add_hdl_path_slice(
          "u_reg.u_wdata.q",
          0, 8, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(wdata.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      fifo_ctrl =
          (uart_reg_fifo_ctrl::
           type_id::create("fifo_ctrl"));
      fifo_ctrl.configure(.blk_parent(this));
      fifo_ctrl.build(csr_excl);
      default_map.add_reg(.rg(fifo_ctrl),
                          .offset(32'h20));
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_rxrst.q",
          0, 1, 0, "BkdrRegPathRtl");
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_txrst.q",
          1, 1, 0, "BkdrRegPathRtl");
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_rxilvl.q",
          2, 3, 0, "BkdrRegPathRtl");
      fifo_ctrl.add_hdl_path_slice(
          "u_reg.u_fifo_ctrl_txilvl.q",
          5, 3, 0, "BkdrRegPathRtl");

      fifo_status =
          (uart_reg_fifo_status::
           type_id::create("fifo_status"));
      fifo_status.configure(.blk_parent(this));
      fifo_status.build(csr_excl);
      default_map.add_reg(.rg(fifo_status),
                          .offset(32'h24));
      fifo_status.add_hdl_path_slice(
          "u_reg.u_fifo_status_txlvl.qs",
          0, 8, 0, "BkdrRegPathRtl");
      fifo_status.add_hdl_path_slice(
          "u_reg.u_fifo_status_rxlvl.qs",
          16, 8, 0, "BkdrRegPathRtl");

      ovrd =
          (uart_reg_ovrd::
           type_id::create("ovrd"));
      ovrd.configure(.blk_parent(this));
      ovrd.build(csr_excl);
      default_map.add_reg(.rg(ovrd),
                          .offset(32'h28));
      ovrd.add_hdl_path_slice(
          "u_reg.u_ovrd_txen.q",
          0, 1, 0, "BkdrRegPathRtl");
      ovrd.add_hdl_path_slice(
          "u_reg.u_ovrd_txval.q",
          1, 1, 0, "BkdrRegPathRtl");

      val =
          (uart_reg_val::
           type_id::create("val"));
      val.configure(.blk_parent(this));
      val.build(csr_excl);
      default_map.add_reg(.rg(val),
                          .offset(32'h2c));
      val.add_hdl_path_slice(
          "u_reg.u_val.qs",
          0, 16, 0, "BkdrRegPathRtl");

      timeout_ctrl =
          (uart_reg_timeout_ctrl::
           type_id::create("timeout_ctrl"));
      timeout_ctrl.configure(.blk_parent(this));
      timeout_ctrl.build(csr_excl);
      default_map.add_reg(.rg(timeout_ctrl),
                          .offset(32'h30));
      timeout_ctrl.add_hdl_path_slice(
          "u_reg.u_timeout_ctrl_val.q",
          0, 24, 0, "BkdrRegPathRtl");
      timeout_ctrl.add_hdl_path_slice(
          "u_reg.u_timeout_ctrl_en.q",
          31, 1, 0, "BkdrRegPathRtl");



      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : uart_reg_block

endpackage

