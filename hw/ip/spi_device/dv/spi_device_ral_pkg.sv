// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package spi_device_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class spi_device_reg_intr_state;
  typedef class spi_device_reg_intr_enable;
  typedef class spi_device_reg_intr_test;
  typedef class spi_device_reg_alert_test;
  typedef class spi_device_reg_control;
  typedef class spi_device_reg_cfg;
  typedef class spi_device_reg_status;
  typedef class spi_device_reg_intercept_en;
  typedef class spi_device_reg_addr_mode;
  typedef class spi_device_reg_last_read_addr;
  typedef class spi_device_reg_flash_status;
  typedef class spi_device_reg_jedec_cc;
  typedef class spi_device_reg_jedec_id;
  typedef class spi_device_reg_read_threshold;
  typedef class spi_device_reg_mailbox_addr;
  typedef class spi_device_reg_upload_status;
  typedef class spi_device_reg_upload_status2;
  typedef class spi_device_reg_upload_cmdfifo;
  typedef class spi_device_reg_upload_addrfifo;
  typedef class spi_device_reg_cmd_filter;
  typedef class spi_device_reg_addr_swap_mask;
  typedef class spi_device_reg_addr_swap_data;
  typedef class spi_device_reg_payload_swap_mask;
  typedef class spi_device_reg_payload_swap_data;
  typedef class spi_device_reg_cmd_info;
  typedef class spi_device_reg_cmd_info_en4b;
  typedef class spi_device_reg_cmd_info_ex4b;
  typedef class spi_device_reg_cmd_info_wren;
  typedef class spi_device_reg_cmd_info_wrdi;
  typedef class spi_device_reg_tpm_cap;
  typedef class spi_device_reg_tpm_cfg;
  typedef class spi_device_reg_tpm_status;
  typedef class spi_device_reg_tpm_access_0;
  typedef class spi_device_reg_tpm_access_1;
  typedef class spi_device_reg_tpm_sts;
  typedef class spi_device_reg_tpm_intf_capability;
  typedef class spi_device_reg_tpm_int_enable;
  typedef class spi_device_reg_tpm_int_vector;
  typedef class spi_device_reg_tpm_int_status;
  typedef class spi_device_reg_tpm_did_vid;
  typedef class spi_device_reg_tpm_rid;
  typedef class spi_device_reg_tpm_cmd_addr;
  typedef class spi_device_reg_tpm_read_fifo;
  typedef class spi_device_mem_egress_buffer;
  typedef class spi_device_mem_ingress_buffer;
  typedef class spi_device_reg_block;

  class spi_device_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field upload_cmdfifo_not_empty;
    rand dv_base_reg_field upload_payload_not_empty;
    rand dv_base_reg_field upload_payload_overflow;
    rand dv_base_reg_field readbuf_watermark;
    rand dv_base_reg_field readbuf_flip;
    rand dv_base_reg_field tpm_header_not_empty;
    rand dv_base_reg_field tpm_rdfifo_cmd_end;
    rand dv_base_reg_field tpm_rdfifo_drop;

    `uvm_object_utils(spi_device_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      upload_cmdfifo_not_empty =
          (dv_base_reg_field::
           type_id::create("upload_cmdfifo_not_empty"));
      upload_cmdfifo_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_cmdfifo_not_empty.set_original_access("W1C");
      upload_payload_not_empty =
          (dv_base_reg_field::
           type_id::create("upload_payload_not_empty"));
      upload_payload_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_payload_not_empty.set_original_access("W1C");
      upload_payload_overflow =
          (dv_base_reg_field::
           type_id::create("upload_payload_overflow"));
      upload_payload_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_payload_overflow.set_original_access("W1C");
      readbuf_watermark =
          (dv_base_reg_field::
           type_id::create("readbuf_watermark"));
      readbuf_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readbuf_watermark.set_original_access("W1C");
      readbuf_flip =
          (dv_base_reg_field::
           type_id::create("readbuf_flip"));
      readbuf_flip.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readbuf_flip.set_original_access("W1C");
      tpm_header_not_empty =
          (dv_base_reg_field::
           type_id::create("tpm_header_not_empty"));
      tpm_header_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_header_not_empty.set_original_access("RO");
      tpm_rdfifo_cmd_end =
          (dv_base_reg_field::
           type_id::create("tpm_rdfifo_cmd_end"));
      tpm_rdfifo_cmd_end.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_rdfifo_cmd_end.set_original_access("W1C");
      tpm_rdfifo_drop =
          (dv_base_reg_field::
           type_id::create("tpm_rdfifo_drop"));
      tpm_rdfifo_drop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_rdfifo_drop.set_original_access("W1C");
    endfunction : build
  endclass : spi_device_reg_intr_state

  class spi_device_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field upload_cmdfifo_not_empty;
    rand dv_base_reg_field upload_payload_not_empty;
    rand dv_base_reg_field upload_payload_overflow;
    rand dv_base_reg_field readbuf_watermark;
    rand dv_base_reg_field readbuf_flip;
    rand dv_base_reg_field tpm_header_not_empty;
    rand dv_base_reg_field tpm_rdfifo_cmd_end;
    rand dv_base_reg_field tpm_rdfifo_drop;

    `uvm_object_utils(spi_device_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      upload_cmdfifo_not_empty =
          (dv_base_reg_field::
           type_id::create("upload_cmdfifo_not_empty"));
      upload_cmdfifo_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_cmdfifo_not_empty.set_original_access("RW");
      upload_payload_not_empty =
          (dv_base_reg_field::
           type_id::create("upload_payload_not_empty"));
      upload_payload_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_payload_not_empty.set_original_access("RW");
      upload_payload_overflow =
          (dv_base_reg_field::
           type_id::create("upload_payload_overflow"));
      upload_payload_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_payload_overflow.set_original_access("RW");
      readbuf_watermark =
          (dv_base_reg_field::
           type_id::create("readbuf_watermark"));
      readbuf_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readbuf_watermark.set_original_access("RW");
      readbuf_flip =
          (dv_base_reg_field::
           type_id::create("readbuf_flip"));
      readbuf_flip.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readbuf_flip.set_original_access("RW");
      tpm_header_not_empty =
          (dv_base_reg_field::
           type_id::create("tpm_header_not_empty"));
      tpm_header_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_header_not_empty.set_original_access("RW");
      tpm_rdfifo_cmd_end =
          (dv_base_reg_field::
           type_id::create("tpm_rdfifo_cmd_end"));
      tpm_rdfifo_cmd_end.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_rdfifo_cmd_end.set_original_access("RW");
      tpm_rdfifo_drop =
          (dv_base_reg_field::
           type_id::create("tpm_rdfifo_drop"));
      tpm_rdfifo_drop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_rdfifo_drop.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_intr_enable

  class spi_device_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field upload_cmdfifo_not_empty;
    rand dv_base_reg_field upload_payload_not_empty;
    rand dv_base_reg_field upload_payload_overflow;
    rand dv_base_reg_field readbuf_watermark;
    rand dv_base_reg_field readbuf_flip;
    rand dv_base_reg_field tpm_header_not_empty;
    rand dv_base_reg_field tpm_rdfifo_cmd_end;
    rand dv_base_reg_field tpm_rdfifo_drop;

    `uvm_object_utils(spi_device_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      upload_cmdfifo_not_empty =
          (dv_base_reg_field::
           type_id::create("upload_cmdfifo_not_empty"));
      upload_cmdfifo_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_cmdfifo_not_empty.set_original_access("WO");
      upload_payload_not_empty =
          (dv_base_reg_field::
           type_id::create("upload_payload_not_empty"));
      upload_payload_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_payload_not_empty.set_original_access("WO");
      upload_payload_overflow =
          (dv_base_reg_field::
           type_id::create("upload_payload_overflow"));
      upload_payload_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload_payload_overflow.set_original_access("WO");
      readbuf_watermark =
          (dv_base_reg_field::
           type_id::create("readbuf_watermark"));
      readbuf_watermark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readbuf_watermark.set_original_access("WO");
      readbuf_flip =
          (dv_base_reg_field::
           type_id::create("readbuf_flip"));
      readbuf_flip.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      readbuf_flip.set_original_access("WO");
      tpm_header_not_empty =
          (dv_base_reg_field::
           type_id::create("tpm_header_not_empty"));
      tpm_header_not_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_header_not_empty.set_original_access("WO");
      tpm_rdfifo_cmd_end =
          (dv_base_reg_field::
           type_id::create("tpm_rdfifo_cmd_end"));
      tpm_rdfifo_cmd_end.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_rdfifo_cmd_end.set_original_access("WO");
      tpm_rdfifo_drop =
          (dv_base_reg_field::
           type_id::create("tpm_rdfifo_drop"));
      tpm_rdfifo_drop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_rdfifo_drop.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_intr_test

  class spi_device_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(spi_device_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_alert_test

  class spi_device_reg_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field flash_status_fifo_clr;
    rand dv_base_reg_field flash_read_buffer_clr;
    rand dv_base_reg_field mode;

    `uvm_object_utils(spi_device_reg_control)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      flash_status_fifo_clr =
          (dv_base_reg_field::
           type_id::create("flash_status_fifo_clr"));
      flash_status_fifo_clr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1S"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_status_fifo_clr.set_original_access("W1S");
      // create field tags
      csr_excl.add_excl(flash_status_fifo_clr.get_full_name(), CsrExclWrite, CsrNonInitTests);
      flash_read_buffer_clr =
          (dv_base_reg_field::
           type_id::create("flash_read_buffer_clr"));
      flash_read_buffer_clr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1S"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_read_buffer_clr.set_original_access("W1S");
      // create field tags
      csr_excl.add_excl(flash_read_buffer_clr.get_full_name(), CsrExclWrite, CsrNonInitTests);
      mode =
          (dv_base_reg_field::
           type_id::create("mode"));
      mode.configure(
        .parent(this),
        .size(2),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mode.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(mode.get_full_name(), CsrExclWrite, CsrNonInitTests);
    endfunction : build
  endclass : spi_device_reg_control

  class spi_device_reg_cfg extends dv_base_reg;
    // fields
    rand dv_base_reg_field tx_order;
    rand dv_base_reg_field rx_order;
    rand dv_base_reg_field mailbox_en;

    `uvm_object_utils(spi_device_reg_cfg)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tx_order =
          (dv_base_reg_field::
           type_id::create("tx_order"));
      tx_order.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tx_order.set_original_access("RW");
      rx_order =
          (dv_base_reg_field::
           type_id::create("rx_order"));
      rx_order.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rx_order.set_original_access("RW");
      mailbox_en =
          (dv_base_reg_field::
           type_id::create("mailbox_en"));
      mailbox_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(24),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mailbox_en.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_cfg

  class spi_device_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field csb;
    rand dv_base_reg_field tpm_csb;

    `uvm_object_utils(spi_device_reg_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      csb =
          (dv_base_reg_field::
           type_id::create("csb"));
      csb.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csb.set_original_access("RO");
      tpm_csb =
          (dv_base_reg_field::
           type_id::create("tpm_csb"));
      tpm_csb.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_csb.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(tpm_csb.get_full_name(), CsrExclCheck, CsrAllTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_status

  class spi_device_reg_intercept_en extends dv_base_reg;
    // fields
    rand dv_base_reg_field status;
    rand dv_base_reg_field jedec;
    rand dv_base_reg_field sfdp;
    rand dv_base_reg_field mbx;

    `uvm_object_utils(spi_device_reg_intercept_en)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      status =
          (dv_base_reg_field::
           type_id::create("status"));
      status.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      status.set_original_access("RW");
      jedec =
          (dv_base_reg_field::
           type_id::create("jedec"));
      jedec.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      jedec.set_original_access("RW");
      sfdp =
          (dv_base_reg_field::
           type_id::create("sfdp"));
      sfdp.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfdp.set_original_access("RW");
      mbx =
          (dv_base_reg_field::
           type_id::create("mbx"));
      mbx.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_intercept_en

  class spi_device_reg_addr_mode extends dv_base_reg;
    // fields
    rand dv_base_reg_field addr_4b_en;
    rand dv_base_reg_field pending;

    `uvm_object_utils(spi_device_reg_addr_mode)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      addr_4b_en =
          (dv_base_reg_field::
           type_id::create("addr_4b_en"));
      addr_4b_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addr_4b_en.set_original_access("RW");
      pending =
          (dv_base_reg_field::
           type_id::create("pending"));
      pending.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pending.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_addr_mode

  class spi_device_reg_last_read_addr extends dv_base_reg;
    // fields
    rand dv_base_reg_field addr;

    `uvm_object_utils(spi_device_reg_last_read_addr)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      addr =
          (dv_base_reg_field::
           type_id::create("addr"));
      addr.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addr.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_last_read_addr

  class spi_device_reg_flash_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field busy;
    rand dv_base_reg_field wel;
    rand dv_base_reg_field status;

    `uvm_object_utils(spi_device_reg_flash_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      busy =
          (dv_base_reg_field::
           type_id::create("busy"));
      busy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      busy.set_original_access("W0C");
      wel =
          (dv_base_reg_field::
           type_id::create("wel"));
      wel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wel.set_original_access("W0C");
      status =
          (dv_base_reg_field::
           type_id::create("status"));
      status.configure(
        .parent(this),
        .size(22),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      status.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_flash_status

  class spi_device_reg_jedec_cc extends dv_base_reg;
    // fields
    rand dv_base_reg_field cc;
    rand dv_base_reg_field num_cc;

    `uvm_object_utils(spi_device_reg_jedec_cc)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cc =
          (dv_base_reg_field::
           type_id::create("cc"));
      cc.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7f),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cc.set_original_access("RW");
      num_cc =
          (dv_base_reg_field::
           type_id::create("num_cc"));
      num_cc.configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      num_cc.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_jedec_cc

  class spi_device_reg_jedec_id extends dv_base_reg;
    // fields
    rand dv_base_reg_field id;
    rand dv_base_reg_field mf;

    `uvm_object_utils(spi_device_reg_jedec_id)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      id =
          (dv_base_reg_field::
           type_id::create("id"));
      id.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      id.set_original_access("RW");
      mf =
          (dv_base_reg_field::
           type_id::create("mf"));
      mf.configure(
        .parent(this),
        .size(8),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mf.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_jedec_id

  class spi_device_reg_read_threshold extends dv_base_reg;
    // fields
    rand dv_base_reg_field threshold;

    `uvm_object_utils(spi_device_reg_read_threshold)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      threshold =
          (dv_base_reg_field::
           type_id::create("threshold"));
      threshold.configure(
        .parent(this),
        .size(10),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      threshold.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_read_threshold

  class spi_device_reg_mailbox_addr extends dv_base_reg;
    // fields
    rand dv_base_reg_field addr;

    `uvm_object_utils(spi_device_reg_mailbox_addr)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      addr =
          (dv_base_reg_field::
           type_id::create("addr"));
      addr.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addr.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_mailbox_addr

  class spi_device_reg_upload_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmdfifo_depth;
    rand dv_base_reg_field cmdfifo_notempty;
    rand dv_base_reg_field addrfifo_depth;
    rand dv_base_reg_field addrfifo_notempty;

    `uvm_object_utils(spi_device_reg_upload_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmdfifo_depth =
          (dv_base_reg_field::
           type_id::create("cmdfifo_depth"));
      cmdfifo_depth.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdfifo_depth.set_original_access("RO");
      cmdfifo_notempty =
          (dv_base_reg_field::
           type_id::create("cmdfifo_notempty"));
      cmdfifo_notempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdfifo_notempty.set_original_access("RO");
      addrfifo_depth =
          (dv_base_reg_field::
           type_id::create("addrfifo_depth"));
      addrfifo_depth.configure(
        .parent(this),
        .size(5),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addrfifo_depth.set_original_access("RO");
      addrfifo_notempty =
          (dv_base_reg_field::
           type_id::create("addrfifo_notempty"));
      addrfifo_notempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addrfifo_notempty.set_original_access("RO");
    endfunction : build
  endclass : spi_device_reg_upload_status

  class spi_device_reg_upload_status2 extends dv_base_reg;
    // fields
    rand dv_base_reg_field payload_depth;
    rand dv_base_reg_field payload_start_idx;

    `uvm_object_utils(spi_device_reg_upload_status2)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      payload_depth =
          (dv_base_reg_field::
           type_id::create("payload_depth"));
      payload_depth.configure(
        .parent(this),
        .size(9),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      payload_depth.set_original_access("RO");
      payload_start_idx =
          (dv_base_reg_field::
           type_id::create("payload_start_idx"));
      payload_start_idx.configure(
        .parent(this),
        .size(8),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      payload_start_idx.set_original_access("RO");
    endfunction : build
  endclass : spi_device_reg_upload_status2

  class spi_device_reg_upload_cmdfifo extends dv_base_reg;
    // fields
    rand dv_base_reg_field data;
    rand dv_base_reg_field busy;
    rand dv_base_reg_field wel;
    rand dv_base_reg_field addr4b_mode;

    `uvm_object_utils(spi_device_reg_upload_cmdfifo)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data =
          (dv_base_reg_field::
           type_id::create("data"));
      data.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data.set_original_access("RO");
      busy =
          (dv_base_reg_field::
           type_id::create("busy"));
      busy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      busy.set_original_access("RO");
      wel =
          (dv_base_reg_field::
           type_id::create("wel"));
      wel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wel.set_original_access("RO");
      addr4b_mode =
          (dv_base_reg_field::
           type_id::create("addr4b_mode"));
      addr4b_mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addr4b_mode.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_upload_cmdfifo

  class spi_device_reg_upload_addrfifo extends dv_base_reg;
    // fields
    rand dv_base_reg_field data;

    `uvm_object_utils(spi_device_reg_upload_addrfifo)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data =
          (dv_base_reg_field::
           type_id::create("data"));
      data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_upload_addrfifo

  class spi_device_reg_cmd_filter extends dv_base_reg;
    // fields
    rand dv_base_reg_field filter[32];

    `uvm_object_utils(spi_device_reg_cmd_filter)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      filter[0] =
          (dv_base_reg_field::
           type_id::create("filter_0"));
      filter[0].configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[0].set_original_access("RW");
      filter[1] =
          (dv_base_reg_field::
           type_id::create("filter_1"));
      filter[1].configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[1].set_original_access("RW");
      filter[2] =
          (dv_base_reg_field::
           type_id::create("filter_2"));
      filter[2].configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[2].set_original_access("RW");
      filter[3] =
          (dv_base_reg_field::
           type_id::create("filter_3"));
      filter[3].configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[3].set_original_access("RW");
      filter[4] =
          (dv_base_reg_field::
           type_id::create("filter_4"));
      filter[4].configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[4].set_original_access("RW");
      filter[5] =
          (dv_base_reg_field::
           type_id::create("filter_5"));
      filter[5].configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[5].set_original_access("RW");
      filter[6] =
          (dv_base_reg_field::
           type_id::create("filter_6"));
      filter[6].configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[6].set_original_access("RW");
      filter[7] =
          (dv_base_reg_field::
           type_id::create("filter_7"));
      filter[7].configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[7].set_original_access("RW");
      filter[8] =
          (dv_base_reg_field::
           type_id::create("filter_8"));
      filter[8].configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[8].set_original_access("RW");
      filter[9] =
          (dv_base_reg_field::
           type_id::create("filter_9"));
      filter[9].configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[9].set_original_access("RW");
      filter[10] =
          (dv_base_reg_field::
           type_id::create("filter_10"));
      filter[10].configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[10].set_original_access("RW");
      filter[11] =
          (dv_base_reg_field::
           type_id::create("filter_11"));
      filter[11].configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[11].set_original_access("RW");
      filter[12] =
          (dv_base_reg_field::
           type_id::create("filter_12"));
      filter[12].configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[12].set_original_access("RW");
      filter[13] =
          (dv_base_reg_field::
           type_id::create("filter_13"));
      filter[13].configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[13].set_original_access("RW");
      filter[14] =
          (dv_base_reg_field::
           type_id::create("filter_14"));
      filter[14].configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[14].set_original_access("RW");
      filter[15] =
          (dv_base_reg_field::
           type_id::create("filter_15"));
      filter[15].configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[15].set_original_access("RW");
      filter[16] =
          (dv_base_reg_field::
           type_id::create("filter_16"));
      filter[16].configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[16].set_original_access("RW");
      filter[17] =
          (dv_base_reg_field::
           type_id::create("filter_17"));
      filter[17].configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[17].set_original_access("RW");
      filter[18] =
          (dv_base_reg_field::
           type_id::create("filter_18"));
      filter[18].configure(
        .parent(this),
        .size(1),
        .lsb_pos(18),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[18].set_original_access("RW");
      filter[19] =
          (dv_base_reg_field::
           type_id::create("filter_19"));
      filter[19].configure(
        .parent(this),
        .size(1),
        .lsb_pos(19),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[19].set_original_access("RW");
      filter[20] =
          (dv_base_reg_field::
           type_id::create("filter_20"));
      filter[20].configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[20].set_original_access("RW");
      filter[21] =
          (dv_base_reg_field::
           type_id::create("filter_21"));
      filter[21].configure(
        .parent(this),
        .size(1),
        .lsb_pos(21),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[21].set_original_access("RW");
      filter[22] =
          (dv_base_reg_field::
           type_id::create("filter_22"));
      filter[22].configure(
        .parent(this),
        .size(1),
        .lsb_pos(22),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[22].set_original_access("RW");
      filter[23] =
          (dv_base_reg_field::
           type_id::create("filter_23"));
      filter[23].configure(
        .parent(this),
        .size(1),
        .lsb_pos(23),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[23].set_original_access("RW");
      filter[24] =
          (dv_base_reg_field::
           type_id::create("filter_24"));
      filter[24].configure(
        .parent(this),
        .size(1),
        .lsb_pos(24),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[24].set_original_access("RW");
      filter[25] =
          (dv_base_reg_field::
           type_id::create("filter_25"));
      filter[25].configure(
        .parent(this),
        .size(1),
        .lsb_pos(25),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[25].set_original_access("RW");
      filter[26] =
          (dv_base_reg_field::
           type_id::create("filter_26"));
      filter[26].configure(
        .parent(this),
        .size(1),
        .lsb_pos(26),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[26].set_original_access("RW");
      filter[27] =
          (dv_base_reg_field::
           type_id::create("filter_27"));
      filter[27].configure(
        .parent(this),
        .size(1),
        .lsb_pos(27),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[27].set_original_access("RW");
      filter[28] =
          (dv_base_reg_field::
           type_id::create("filter_28"));
      filter[28].configure(
        .parent(this),
        .size(1),
        .lsb_pos(28),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[28].set_original_access("RW");
      filter[29] =
          (dv_base_reg_field::
           type_id::create("filter_29"));
      filter[29].configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[29].set_original_access("RW");
      filter[30] =
          (dv_base_reg_field::
           type_id::create("filter_30"));
      filter[30].configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[30].set_original_access("RW");
      filter[31] =
          (dv_base_reg_field::
           type_id::create("filter_31"));
      filter[31].configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      filter[31].set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_cmd_filter

  class spi_device_reg_addr_swap_mask extends dv_base_reg;
    // fields
    rand dv_base_reg_field mask;

    `uvm_object_utils(spi_device_reg_addr_swap_mask)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      mask =
          (dv_base_reg_field::
           type_id::create("mask"));
      mask.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mask.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_addr_swap_mask

  class spi_device_reg_addr_swap_data extends dv_base_reg;
    // fields
    rand dv_base_reg_field data;

    `uvm_object_utils(spi_device_reg_addr_swap_data)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data =
          (dv_base_reg_field::
           type_id::create("data"));
      data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_addr_swap_data

  class spi_device_reg_payload_swap_mask extends dv_base_reg;
    // fields
    rand dv_base_reg_field mask;

    `uvm_object_utils(spi_device_reg_payload_swap_mask)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      mask =
          (dv_base_reg_field::
           type_id::create("mask"));
      mask.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mask.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_payload_swap_mask

  class spi_device_reg_payload_swap_data extends dv_base_reg;
    // fields
    rand dv_base_reg_field data;

    `uvm_object_utils(spi_device_reg_payload_swap_data)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data =
          (dv_base_reg_field::
           type_id::create("data"));
      data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_payload_swap_data

  class spi_device_reg_cmd_info extends dv_base_reg;
    // fields
    rand dv_base_reg_field opcode;
    rand dv_base_reg_field addr_mode;
    rand dv_base_reg_field addr_swap_en;
    rand dv_base_reg_field mbyte_en;
    rand dv_base_reg_field dummy_size;
    rand dv_base_reg_field dummy_en;
    rand dv_base_reg_field payload_en;
    rand dv_base_reg_field payload_dir;
    rand dv_base_reg_field payload_swap_en;
    rand dv_base_reg_field read_pipeline_mode;
    rand dv_base_reg_field upload;
    rand dv_base_reg_field busy;
    rand dv_base_reg_field valid;

    `uvm_object_utils(spi_device_reg_cmd_info)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      opcode =
          (dv_base_reg_field::
           type_id::create("opcode"));
      opcode.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      opcode.set_original_access("RW");
      addr_mode =
          (dv_base_reg_field::
           type_id::create("addr_mode"));
      addr_mode.configure(
        .parent(this),
        .size(2),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addr_mode.set_original_access("RW");
      addr_swap_en =
          (dv_base_reg_field::
           type_id::create("addr_swap_en"));
      addr_swap_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addr_swap_en.set_original_access("RW");
      mbyte_en =
          (dv_base_reg_field::
           type_id::create("mbyte_en"));
      mbyte_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbyte_en.set_original_access("RW");
      dummy_size =
          (dv_base_reg_field::
           type_id::create("dummy_size"));
      dummy_size.configure(
        .parent(this),
        .size(3),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dummy_size.set_original_access("RW");
      dummy_en =
          (dv_base_reg_field::
           type_id::create("dummy_en"));
      dummy_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dummy_en.set_original_access("RW");
      payload_en =
          (dv_base_reg_field::
           type_id::create("payload_en"));
      payload_en.configure(
        .parent(this),
        .size(4),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      payload_en.set_original_access("RW");
      payload_dir =
          (dv_base_reg_field::
           type_id::create("payload_dir"));
      payload_dir.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      payload_dir.set_original_access("RW");
      payload_swap_en =
          (dv_base_reg_field::
           type_id::create("payload_swap_en"));
      payload_swap_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(21),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      payload_swap_en.set_original_access("RW");
      read_pipeline_mode =
          (dv_base_reg_field::
           type_id::create("read_pipeline_mode"));
      read_pipeline_mode.configure(
        .parent(this),
        .size(2),
        .lsb_pos(22),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      read_pipeline_mode.set_original_access("RW");
      upload =
          (dv_base_reg_field::
           type_id::create("upload"));
      upload.configure(
        .parent(this),
        .size(1),
        .lsb_pos(24),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      upload.set_original_access("RW");
      busy =
          (dv_base_reg_field::
           type_id::create("busy"));
      busy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(25),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      busy.set_original_access("RW");
      valid =
          (dv_base_reg_field::
           type_id::create("valid"));
      valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      valid.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_cmd_info

  class spi_device_reg_cmd_info_en4b extends dv_base_reg;
    // fields
    rand dv_base_reg_field opcode;
    rand dv_base_reg_field valid;

    `uvm_object_utils(spi_device_reg_cmd_info_en4b)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      opcode =
          (dv_base_reg_field::
           type_id::create("opcode"));
      opcode.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      opcode.set_original_access("RW");
      valid =
          (dv_base_reg_field::
           type_id::create("valid"));
      valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      valid.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_cmd_info_en4b

  class spi_device_reg_cmd_info_ex4b extends dv_base_reg;
    // fields
    rand dv_base_reg_field opcode;
    rand dv_base_reg_field valid;

    `uvm_object_utils(spi_device_reg_cmd_info_ex4b)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      opcode =
          (dv_base_reg_field::
           type_id::create("opcode"));
      opcode.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      opcode.set_original_access("RW");
      valid =
          (dv_base_reg_field::
           type_id::create("valid"));
      valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      valid.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_cmd_info_ex4b

  class spi_device_reg_cmd_info_wren extends dv_base_reg;
    // fields
    rand dv_base_reg_field opcode;
    rand dv_base_reg_field valid;

    `uvm_object_utils(spi_device_reg_cmd_info_wren)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      opcode =
          (dv_base_reg_field::
           type_id::create("opcode"));
      opcode.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      opcode.set_original_access("RW");
      valid =
          (dv_base_reg_field::
           type_id::create("valid"));
      valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      valid.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_cmd_info_wren

  class spi_device_reg_cmd_info_wrdi extends dv_base_reg;
    // fields
    rand dv_base_reg_field opcode;
    rand dv_base_reg_field valid;

    `uvm_object_utils(spi_device_reg_cmd_info_wrdi)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      opcode =
          (dv_base_reg_field::
           type_id::create("opcode"));
      opcode.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      opcode.set_original_access("RW");
      valid =
          (dv_base_reg_field::
           type_id::create("valid"));
      valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      valid.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_cmd_info_wrdi

  class spi_device_reg_tpm_cap extends dv_base_reg;
    // fields
    rand dv_base_reg_field rev;
    rand dv_base_reg_field locality;
    rand dv_base_reg_field max_wr_size;
    rand dv_base_reg_field max_rd_size;

    `uvm_object_utils(spi_device_reg_tpm_cap)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rev =
          (dv_base_reg_field::
           type_id::create("rev"));
      rev.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rev.set_original_access("RO");
      locality =
          (dv_base_reg_field::
           type_id::create("locality"));
      locality.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      locality.set_original_access("RO");
      max_wr_size =
          (dv_base_reg_field::
           type_id::create("max_wr_size"));
      max_wr_size.configure(
        .parent(this),
        .size(3),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h6),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      max_wr_size.set_original_access("RO");
      max_rd_size =
          (dv_base_reg_field::
           type_id::create("max_rd_size"));
      max_rd_size.configure(
        .parent(this),
        .size(3),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h6),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      max_rd_size.set_original_access("RO");
    endfunction : build
  endclass : spi_device_reg_tpm_cap

  class spi_device_reg_tpm_cfg extends dv_base_reg;
    // fields
    rand dv_base_reg_field en;
    rand dv_base_reg_field tpm_mode;
    rand dv_base_reg_field hw_reg_dis;
    rand dv_base_reg_field tpm_reg_chk_dis;
    rand dv_base_reg_field invalid_locality;

    `uvm_object_utils(spi_device_reg_tpm_cfg)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(en.get_full_name(), CsrExclWrite, CsrNonInitTests);
      tpm_mode =
          (dv_base_reg_field::
           type_id::create("tpm_mode"));
      tpm_mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_mode.set_original_access("RW");
      hw_reg_dis =
          (dv_base_reg_field::
           type_id::create("hw_reg_dis"));
      hw_reg_dis.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hw_reg_dis.set_original_access("RW");
      tpm_reg_chk_dis =
          (dv_base_reg_field::
           type_id::create("tpm_reg_chk_dis"));
      tpm_reg_chk_dis.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tpm_reg_chk_dis.set_original_access("RW");
      invalid_locality =
          (dv_base_reg_field::
           type_id::create("invalid_locality"));
      invalid_locality.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      invalid_locality.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_cfg

  class spi_device_reg_tpm_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmdaddr_notempty;
    rand dv_base_reg_field wrfifo_pending;
    rand dv_base_reg_field rdfifo_aborted;

    `uvm_object_utils(spi_device_reg_tpm_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmdaddr_notempty =
          (dv_base_reg_field::
           type_id::create("cmdaddr_notempty"));
      cmdaddr_notempty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmdaddr_notempty.set_original_access("RO");
      wrfifo_pending =
          (dv_base_reg_field::
           type_id::create("wrfifo_pending"));
      wrfifo_pending.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wrfifo_pending.set_original_access("W0C");
      rdfifo_aborted =
          (dv_base_reg_field::
           type_id::create("rdfifo_aborted"));
      rdfifo_aborted.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rdfifo_aborted.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_tpm_status

  class spi_device_reg_tpm_access_0 extends dv_base_reg;
    // fields
    // verilog_lint: waive unpacked-dimensions-range-ordering
    rand dv_base_reg_field access[0:3];

    `uvm_object_utils(spi_device_reg_tpm_access_0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      access[0] =
          (dv_base_reg_field::
           type_id::create("access_0"));
      access[0].configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      access[0].set_original_access("RW");
      access[1] =
          (dv_base_reg_field::
           type_id::create("access_1"));
      access[1].configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      access[1].set_original_access("RW");
      access[2] =
          (dv_base_reg_field::
           type_id::create("access_2"));
      access[2].configure(
        .parent(this),
        .size(8),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      access[2].set_original_access("RW");
      access[3] =
          (dv_base_reg_field::
           type_id::create("access_3"));
      access[3].configure(
        .parent(this),
        .size(8),
        .lsb_pos(24),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      access[3].set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_access_0

  class spi_device_reg_tpm_access_1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field access[4:4];

    `uvm_object_utils(spi_device_reg_tpm_access_1)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      access[4] =
          (dv_base_reg_field::
           type_id::create("access_4"));
      access[4].configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      access[4].set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_access_1

  class spi_device_reg_tpm_sts extends dv_base_reg;
    // fields
    rand dv_base_reg_field sts;

    `uvm_object_utils(spi_device_reg_tpm_sts)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      sts =
          (dv_base_reg_field::
           type_id::create("sts"));
      sts.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sts.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_sts

  class spi_device_reg_tpm_intf_capability extends dv_base_reg;
    // fields
    rand dv_base_reg_field intf_capability;

    `uvm_object_utils(spi_device_reg_tpm_intf_capability)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      intf_capability =
          (dv_base_reg_field::
           type_id::create("intf_capability"));
      intf_capability.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      intf_capability.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_intf_capability

  class spi_device_reg_tpm_int_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field int_enable;

    `uvm_object_utils(spi_device_reg_tpm_int_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      int_enable =
          (dv_base_reg_field::
           type_id::create("int_enable"));
      int_enable.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      int_enable.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_int_enable

  class spi_device_reg_tpm_int_vector extends dv_base_reg;
    // fields
    rand dv_base_reg_field int_vector;

    `uvm_object_utils(spi_device_reg_tpm_int_vector)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      int_vector =
          (dv_base_reg_field::
           type_id::create("int_vector"));
      int_vector.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      int_vector.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_int_vector

  class spi_device_reg_tpm_int_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field int_status;

    `uvm_object_utils(spi_device_reg_tpm_int_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      int_status =
          (dv_base_reg_field::
           type_id::create("int_status"));
      int_status.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      int_status.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_int_status

  class spi_device_reg_tpm_did_vid extends dv_base_reg;
    // fields
    rand dv_base_reg_field vid;
    rand dv_base_reg_field did;

    `uvm_object_utils(spi_device_reg_tpm_did_vid)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      vid =
          (dv_base_reg_field::
           type_id::create("vid"));
      vid.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      vid.set_original_access("RW");
      did =
          (dv_base_reg_field::
           type_id::create("did"));
      did.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      did.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_did_vid

  class spi_device_reg_tpm_rid extends dv_base_reg;
    // fields
    rand dv_base_reg_field rid;

    `uvm_object_utils(spi_device_reg_tpm_rid)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rid =
          (dv_base_reg_field::
           type_id::create("rid"));
      rid.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rid.set_original_access("RW");
    endfunction : build
  endclass : spi_device_reg_tpm_rid

  class spi_device_reg_tpm_cmd_addr extends dv_base_reg;
    // fields
    rand dv_base_reg_field addr;
    rand dv_base_reg_field cmd;

    `uvm_object_utils(spi_device_reg_tpm_cmd_addr)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      addr =
          (dv_base_reg_field::
           type_id::create("addr"));
      addr.configure(
        .parent(this),
        .size(24),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      addr.set_original_access("RO");
      cmd =
          (dv_base_reg_field::
           type_id::create("cmd"));
      cmd.configure(
        .parent(this),
        .size(8),
        .lsb_pos(24),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_tpm_cmd_addr

  class spi_device_reg_tpm_read_fifo extends dv_base_reg;
    // fields
    rand dv_base_reg_field value;

    `uvm_object_utils(spi_device_reg_tpm_read_fifo)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      value =
          (dv_base_reg_field::
           type_id::create("value"));
      value.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      value.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : spi_device_reg_tpm_read_fifo

  class spi_device_mem_egress_buffer extends dv_base_mem;

    `uvm_object_utils(spi_device_mem_egress_buffer)

    function new(string           name = "",
                 longint unsigned size = 848,
                 int unsigned     n_bits = 32,
                 string           access = "WO",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
    endfunction : new

  endclass : spi_device_mem_egress_buffer


  class spi_device_mem_ingress_buffer extends dv_base_mem;

    `uvm_object_utils(spi_device_mem_ingress_buffer)

    function new(string           name = "",
                 longint unsigned size = 112,
                 int unsigned     n_bits = 32,
                 string           access = "RO",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
    endfunction : new

  endclass : spi_device_mem_ingress_buffer


  class spi_device_reg_block extends dv_base_reg_block;
    // registers
    rand spi_device_reg_intr_state intr_state;
    rand spi_device_reg_intr_enable intr_enable;
    rand spi_device_reg_intr_test intr_test;
    rand spi_device_reg_alert_test alert_test;
    rand spi_device_reg_control control;
    rand spi_device_reg_cfg cfg;
    rand spi_device_reg_status status;
    rand spi_device_reg_intercept_en intercept_en;
    rand spi_device_reg_addr_mode addr_mode;
    rand spi_device_reg_last_read_addr last_read_addr;
    rand spi_device_reg_flash_status flash_status;
    rand spi_device_reg_jedec_cc jedec_cc;
    rand spi_device_reg_jedec_id jedec_id;
    rand spi_device_reg_read_threshold read_threshold;
    rand spi_device_reg_mailbox_addr mailbox_addr;
    rand spi_device_reg_upload_status upload_status;
    rand spi_device_reg_upload_status2 upload_status2;
    rand spi_device_reg_upload_cmdfifo upload_cmdfifo;
    rand spi_device_reg_upload_addrfifo upload_addrfifo;
    rand spi_device_reg_cmd_filter cmd_filter[8];
    rand spi_device_reg_addr_swap_mask addr_swap_mask;
    rand spi_device_reg_addr_swap_data addr_swap_data;
    rand spi_device_reg_payload_swap_mask payload_swap_mask;
    rand spi_device_reg_payload_swap_data payload_swap_data;
    rand spi_device_reg_cmd_info cmd_info[24];
    rand spi_device_reg_cmd_info_en4b cmd_info_en4b;
    rand spi_device_reg_cmd_info_ex4b cmd_info_ex4b;
    rand spi_device_reg_cmd_info_wren cmd_info_wren;
    rand spi_device_reg_cmd_info_wrdi cmd_info_wrdi;
    rand spi_device_reg_tpm_cap tpm_cap;
    rand spi_device_reg_tpm_cfg tpm_cfg;
    rand spi_device_reg_tpm_status tpm_status;
    rand spi_device_reg_tpm_access_0 tpm_access_0;
    rand spi_device_reg_tpm_access_1 tpm_access_1;
    rand spi_device_reg_tpm_sts tpm_sts;
    rand spi_device_reg_tpm_intf_capability tpm_intf_capability;
    rand spi_device_reg_tpm_int_enable tpm_int_enable;
    rand spi_device_reg_tpm_int_vector tpm_int_vector;
    rand spi_device_reg_tpm_int_status tpm_int_status;
    rand spi_device_reg_tpm_did_vid tpm_did_vid;
    rand spi_device_reg_tpm_rid tpm_rid;
    rand spi_device_reg_tpm_cmd_addr tpm_cmd_addr;
    rand spi_device_reg_tpm_read_fifo tpm_read_fifo;
    // memories
    rand spi_device_mem_egress_buffer egress_buffer;
    rand spi_device_mem_ingress_buffer ingress_buffer;

    `uvm_object_utils(spi_device_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (spi_device_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_upload_cmdfifo_not_empty.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_upload_payload_not_empty.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_upload_payload_overflow.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_readbuf_watermark.q",
          3, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_readbuf_flip.q",
          4, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_tpm_header_not_empty.q",
          5, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_tpm_rdfifo_cmd_end.q",
          6, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_tpm_rdfifo_drop.q",
          7, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (spi_device_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_upload_cmdfifo_not_empty.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_upload_payload_not_empty.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_upload_payload_overflow.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_readbuf_watermark.q",
          3, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_readbuf_flip.q",
          4, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_tpm_header_not_empty.q",
          5, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_tpm_rdfifo_cmd_end.q",
          6, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_tpm_rdfifo_drop.q",
          7, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (spi_device_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_upload_cmdfifo_not_empty.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_upload_payload_not_empty.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_upload_payload_overflow.qs",
          2, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_readbuf_watermark.qs",
          3, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_readbuf_flip.qs",
          4, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_tpm_header_not_empty.qs",
          5, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_tpm_rdfifo_cmd_end.qs",
          6, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_tpm_rdfifo_drop.qs",
          7, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (spi_device_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      control =
          (spi_device_reg_control::
           type_id::create("control"));
      control.configure(.blk_parent(this));
      control.build(csr_excl);
      default_map.add_reg(.rg(control),
                          .offset(32'h10));
      control.add_hdl_path_slice(
          "u_reg.u_control_flash_status_fifo_clr.q",
          0, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_reg.u_control_flash_read_buffer_clr.q",
          1, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_reg.u_control_mode.q",
          4, 2, 0, "BkdrRegPathRtl");

      cfg =
          (spi_device_reg_cfg::
           type_id::create("cfg"));
      cfg.configure(.blk_parent(this));
      cfg.build(csr_excl);
      default_map.add_reg(.rg(cfg),
                          .offset(32'h14));
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_tx_order.q",
          2, 1, 0, "BkdrRegPathRtl");
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_rx_order.q",
          3, 1, 0, "BkdrRegPathRtl");
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_mailbox_en.q",
          24, 1, 0, "BkdrRegPathRtl");

      status =
          (spi_device_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h18));
      status.add_hdl_path_slice(
          "u_reg.u_status_csb.qs",
          5, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_tpm_csb.qs",
          6, 1, 0, "BkdrRegPathRtl");

      intercept_en =
          (spi_device_reg_intercept_en::
           type_id::create("intercept_en"));
      intercept_en.configure(.blk_parent(this));
      intercept_en.build(csr_excl);
      default_map.add_reg(.rg(intercept_en),
                          .offset(32'h1c));
      intercept_en.add_hdl_path_slice(
          "u_reg.u_intercept_en_status.q",
          0, 1, 0, "BkdrRegPathRtl");
      intercept_en.add_hdl_path_slice(
          "u_reg.u_intercept_en_jedec.q",
          1, 1, 0, "BkdrRegPathRtl");
      intercept_en.add_hdl_path_slice(
          "u_reg.u_intercept_en_sfdp.q",
          2, 1, 0, "BkdrRegPathRtl");
      intercept_en.add_hdl_path_slice(
          "u_reg.u_intercept_en_mbx.q",
          3, 1, 0, "BkdrRegPathRtl");

      addr_mode =
          (spi_device_reg_addr_mode::
           type_id::create("addr_mode"));
      addr_mode.configure(.blk_parent(this));
      addr_mode.build(csr_excl);
      default_map.add_reg(.rg(addr_mode),
                          .offset(32'h20));
      addr_mode.add_hdl_path_slice(
          "u_reg.u_addr_mode_addr_4b_en.qs",
          0, 1, 0, "BkdrRegPathRtl");
      addr_mode.add_hdl_path_slice(
          "u_reg.u_addr_mode_pending.qs",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(addr_mode.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      last_read_addr =
          (spi_device_reg_last_read_addr::
           type_id::create("last_read_addr"));
      last_read_addr.configure(.blk_parent(this));
      last_read_addr.build(csr_excl);
      default_map.add_reg(.rg(last_read_addr),
                          .offset(32'h24));
      last_read_addr.add_hdl_path_slice(
          "u_reg.u_last_read_addr.qs",
          0, 32, 0, "BkdrRegPathRtl");

      flash_status =
          (spi_device_reg_flash_status::
           type_id::create("flash_status"));
      flash_status.configure(.blk_parent(this));
      flash_status.build(csr_excl);
      default_map.add_reg(.rg(flash_status),
                          .offset(32'h28));
      flash_status.add_hdl_path_slice(
          "u_reg.u_flash_status_busy.qs",
          0, 1, 0, "BkdrRegPathRtl");
      flash_status.add_hdl_path_slice(
          "u_reg.u_flash_status_wel.qs",
          1, 1, 0, "BkdrRegPathRtl");
      flash_status.add_hdl_path_slice(
          "u_reg.u_flash_status_status.qs",
          2, 22, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(flash_status.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      jedec_cc =
          (spi_device_reg_jedec_cc::
           type_id::create("jedec_cc"));
      jedec_cc.configure(.blk_parent(this));
      jedec_cc.build(csr_excl);
      default_map.add_reg(.rg(jedec_cc),
                          .offset(32'h2c));
      jedec_cc.add_hdl_path_slice(
          "u_reg.u_jedec_cc_cc.q",
          0, 8, 0, "BkdrRegPathRtl");
      jedec_cc.add_hdl_path_slice(
          "u_reg.u_jedec_cc_num_cc.q",
          8, 8, 0, "BkdrRegPathRtl");

      jedec_id =
          (spi_device_reg_jedec_id::
           type_id::create("jedec_id"));
      jedec_id.configure(.blk_parent(this));
      jedec_id.build(csr_excl);
      default_map.add_reg(.rg(jedec_id),
                          .offset(32'h30));
      jedec_id.add_hdl_path_slice(
          "u_reg.u_jedec_id_id.q",
          0, 16, 0, "BkdrRegPathRtl");
      jedec_id.add_hdl_path_slice(
          "u_reg.u_jedec_id_mf.q",
          16, 8, 0, "BkdrRegPathRtl");

      read_threshold =
          (spi_device_reg_read_threshold::
           type_id::create("read_threshold"));
      read_threshold.configure(.blk_parent(this));
      read_threshold.build(csr_excl);
      default_map.add_reg(.rg(read_threshold),
                          .offset(32'h34));
      read_threshold.add_hdl_path_slice(
          "u_reg.u_read_threshold.q",
          0, 10, 0, "BkdrRegPathRtl");

      mailbox_addr =
          (spi_device_reg_mailbox_addr::
           type_id::create("mailbox_addr"));
      mailbox_addr.configure(.blk_parent(this));
      mailbox_addr.build(csr_excl);
      default_map.add_reg(.rg(mailbox_addr),
                          .offset(32'h38));
      mailbox_addr.add_hdl_path_slice(
          "u_reg.u_mailbox_addr.q",
          0, 32, 0, "BkdrRegPathRtl");

      upload_status =
          (spi_device_reg_upload_status::
           type_id::create("upload_status"));
      upload_status.configure(.blk_parent(this));
      upload_status.build(csr_excl);
      default_map.add_reg(.rg(upload_status),
                          .offset(32'h3c));
      upload_status.add_hdl_path_slice(
          "u_reg.u_upload_status_cmdfifo_depth.q",
          0, 5, 0, "BkdrRegPathRtl");
      upload_status.add_hdl_path_slice(
          "u_reg.u_upload_status_cmdfifo_notempty.q",
          7, 1, 0, "BkdrRegPathRtl");
      upload_status.add_hdl_path_slice(
          "u_reg.u_upload_status_addrfifo_depth.q",
          8, 5, 0, "BkdrRegPathRtl");
      upload_status.add_hdl_path_slice(
          "u_reg.u_upload_status_addrfifo_notempty.q",
          15, 1, 0, "BkdrRegPathRtl");

      upload_status2 =
          (spi_device_reg_upload_status2::
           type_id::create("upload_status2"));
      upload_status2.configure(.blk_parent(this));
      upload_status2.build(csr_excl);
      default_map.add_reg(.rg(upload_status2),
                          .offset(32'h40));
      upload_status2.add_hdl_path_slice(
          "u_reg.u_upload_status2_payload_depth.q",
          0, 9, 0, "BkdrRegPathRtl");
      upload_status2.add_hdl_path_slice(
          "u_reg.u_upload_status2_payload_start_idx.q",
          16, 8, 0, "BkdrRegPathRtl");

      upload_cmdfifo =
          (spi_device_reg_upload_cmdfifo::
           type_id::create("upload_cmdfifo"));
      upload_cmdfifo.configure(.blk_parent(this));
      upload_cmdfifo.build(csr_excl);
      default_map.add_reg(.rg(upload_cmdfifo),
                          .offset(32'h44));
      upload_cmdfifo.add_hdl_path_slice(
          "u_reg.u_upload_cmdfifo_data.qs",
          0, 8, 0, "BkdrRegPathRtl");
      upload_cmdfifo.add_hdl_path_slice(
          "u_reg.u_upload_cmdfifo_busy.qs",
          13, 1, 0, "BkdrRegPathRtl");
      upload_cmdfifo.add_hdl_path_slice(
          "u_reg.u_upload_cmdfifo_wel.qs",
          14, 1, 0, "BkdrRegPathRtl");
      upload_cmdfifo.add_hdl_path_slice(
          "u_reg.u_upload_cmdfifo_addr4b_mode.qs",
          15, 1, 0, "BkdrRegPathRtl");

      upload_addrfifo =
          (spi_device_reg_upload_addrfifo::
           type_id::create("upload_addrfifo"));
      upload_addrfifo.configure(.blk_parent(this));
      upload_addrfifo.build(csr_excl);
      default_map.add_reg(.rg(upload_addrfifo),
                          .offset(32'h48));
      upload_addrfifo.add_hdl_path_slice(
          "u_reg.u_upload_addrfifo.qs",
          0, 32, 0, "BkdrRegPathRtl");

      cmd_filter[0] =
          (spi_device_reg_cmd_filter::
           type_id::create("cmd_filter_0"));
      cmd_filter[0].configure(.blk_parent(this));
      cmd_filter[0].build(csr_excl);
      default_map.add_reg(.rg(cmd_filter[0]),
                          .offset(32'h4c));
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_4.q",
          4, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_5.q",
          5, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_6.q",
          6, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_7.q",
          7, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_8.q",
          8, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_9.q",
          9, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_11.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_12.q",
          12, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_13.q",
          13, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_14.q",
          14, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_15.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_16.q",
          16, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_17.q",
          17, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_18.q",
          18, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_19.q",
          19, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_20.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_21.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_22.q",
          22, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_23.q",
          23, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_24.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_25.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_26.q",
          26, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_27.q",
          27, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_28.q",
          28, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_29.q",
          29, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_30.q",
          30, 1, 0, "BkdrRegPathRtl");
      cmd_filter[0].add_hdl_path_slice(
          "u_reg.u_cmd_filter_0_filter_31.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_filter[1] =
          (spi_device_reg_cmd_filter::
           type_id::create("cmd_filter_1"));
      cmd_filter[1].configure(.blk_parent(this));
      cmd_filter[1].build(csr_excl);
      default_map.add_reg(.rg(cmd_filter[1]),
                          .offset(32'h50));
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_32.q",
          0, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_33.q",
          1, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_34.q",
          2, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_35.q",
          3, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_36.q",
          4, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_37.q",
          5, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_38.q",
          6, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_39.q",
          7, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_40.q",
          8, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_41.q",
          9, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_42.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_43.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_44.q",
          12, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_45.q",
          13, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_46.q",
          14, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_47.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_48.q",
          16, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_49.q",
          17, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_50.q",
          18, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_51.q",
          19, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_52.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_53.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_54.q",
          22, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_55.q",
          23, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_56.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_57.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_58.q",
          26, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_59.q",
          27, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_60.q",
          28, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_61.q",
          29, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_62.q",
          30, 1, 0, "BkdrRegPathRtl");
      cmd_filter[1].add_hdl_path_slice(
          "u_reg.u_cmd_filter_1_filter_63.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_filter[2] =
          (spi_device_reg_cmd_filter::
           type_id::create("cmd_filter_2"));
      cmd_filter[2].configure(.blk_parent(this));
      cmd_filter[2].build(csr_excl);
      default_map.add_reg(.rg(cmd_filter[2]),
                          .offset(32'h54));
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_64.q",
          0, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_65.q",
          1, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_66.q",
          2, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_67.q",
          3, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_68.q",
          4, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_69.q",
          5, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_70.q",
          6, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_71.q",
          7, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_72.q",
          8, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_73.q",
          9, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_74.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_75.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_76.q",
          12, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_77.q",
          13, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_78.q",
          14, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_79.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_80.q",
          16, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_81.q",
          17, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_82.q",
          18, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_83.q",
          19, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_84.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_85.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_86.q",
          22, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_87.q",
          23, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_88.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_89.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_90.q",
          26, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_91.q",
          27, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_92.q",
          28, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_93.q",
          29, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_94.q",
          30, 1, 0, "BkdrRegPathRtl");
      cmd_filter[2].add_hdl_path_slice(
          "u_reg.u_cmd_filter_2_filter_95.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_filter[3] =
          (spi_device_reg_cmd_filter::
           type_id::create("cmd_filter_3"));
      cmd_filter[3].configure(.blk_parent(this));
      cmd_filter[3].build(csr_excl);
      default_map.add_reg(.rg(cmd_filter[3]),
                          .offset(32'h58));
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_96.q",
          0, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_97.q",
          1, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_98.q",
          2, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_99.q",
          3, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_100.q",
          4, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_101.q",
          5, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_102.q",
          6, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_103.q",
          7, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_104.q",
          8, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_105.q",
          9, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_106.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_107.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_108.q",
          12, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_109.q",
          13, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_110.q",
          14, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_111.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_112.q",
          16, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_113.q",
          17, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_114.q",
          18, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_115.q",
          19, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_116.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_117.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_118.q",
          22, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_119.q",
          23, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_120.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_121.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_122.q",
          26, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_123.q",
          27, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_124.q",
          28, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_125.q",
          29, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_126.q",
          30, 1, 0, "BkdrRegPathRtl");
      cmd_filter[3].add_hdl_path_slice(
          "u_reg.u_cmd_filter_3_filter_127.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_filter[4] =
          (spi_device_reg_cmd_filter::
           type_id::create("cmd_filter_4"));
      cmd_filter[4].configure(.blk_parent(this));
      cmd_filter[4].build(csr_excl);
      default_map.add_reg(.rg(cmd_filter[4]),
                          .offset(32'h5c));
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_128.q",
          0, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_129.q",
          1, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_130.q",
          2, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_131.q",
          3, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_132.q",
          4, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_133.q",
          5, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_134.q",
          6, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_135.q",
          7, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_136.q",
          8, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_137.q",
          9, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_138.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_139.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_140.q",
          12, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_141.q",
          13, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_142.q",
          14, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_143.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_144.q",
          16, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_145.q",
          17, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_146.q",
          18, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_147.q",
          19, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_148.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_149.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_150.q",
          22, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_151.q",
          23, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_152.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_153.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_154.q",
          26, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_155.q",
          27, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_156.q",
          28, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_157.q",
          29, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_158.q",
          30, 1, 0, "BkdrRegPathRtl");
      cmd_filter[4].add_hdl_path_slice(
          "u_reg.u_cmd_filter_4_filter_159.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_filter[5] =
          (spi_device_reg_cmd_filter::
           type_id::create("cmd_filter_5"));
      cmd_filter[5].configure(.blk_parent(this));
      cmd_filter[5].build(csr_excl);
      default_map.add_reg(.rg(cmd_filter[5]),
                          .offset(32'h60));
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_160.q",
          0, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_161.q",
          1, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_162.q",
          2, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_163.q",
          3, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_164.q",
          4, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_165.q",
          5, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_166.q",
          6, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_167.q",
          7, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_168.q",
          8, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_169.q",
          9, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_170.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_171.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_172.q",
          12, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_173.q",
          13, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_174.q",
          14, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_175.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_176.q",
          16, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_177.q",
          17, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_178.q",
          18, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_179.q",
          19, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_180.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_181.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_182.q",
          22, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_183.q",
          23, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_184.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_185.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_186.q",
          26, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_187.q",
          27, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_188.q",
          28, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_189.q",
          29, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_190.q",
          30, 1, 0, "BkdrRegPathRtl");
      cmd_filter[5].add_hdl_path_slice(
          "u_reg.u_cmd_filter_5_filter_191.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_filter[6] =
          (spi_device_reg_cmd_filter::
           type_id::create("cmd_filter_6"));
      cmd_filter[6].configure(.blk_parent(this));
      cmd_filter[6].build(csr_excl);
      default_map.add_reg(.rg(cmd_filter[6]),
                          .offset(32'h64));
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_192.q",
          0, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_193.q",
          1, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_194.q",
          2, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_195.q",
          3, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_196.q",
          4, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_197.q",
          5, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_198.q",
          6, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_199.q",
          7, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_200.q",
          8, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_201.q",
          9, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_202.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_203.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_204.q",
          12, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_205.q",
          13, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_206.q",
          14, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_207.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_208.q",
          16, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_209.q",
          17, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_210.q",
          18, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_211.q",
          19, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_212.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_213.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_214.q",
          22, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_215.q",
          23, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_216.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_217.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_218.q",
          26, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_219.q",
          27, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_220.q",
          28, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_221.q",
          29, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_222.q",
          30, 1, 0, "BkdrRegPathRtl");
      cmd_filter[6].add_hdl_path_slice(
          "u_reg.u_cmd_filter_6_filter_223.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_filter[7] =
          (spi_device_reg_cmd_filter::
           type_id::create("cmd_filter_7"));
      cmd_filter[7].configure(.blk_parent(this));
      cmd_filter[7].build(csr_excl);
      default_map.add_reg(.rg(cmd_filter[7]),
                          .offset(32'h68));
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_224.q",
          0, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_225.q",
          1, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_226.q",
          2, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_227.q",
          3, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_228.q",
          4, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_229.q",
          5, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_230.q",
          6, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_231.q",
          7, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_232.q",
          8, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_233.q",
          9, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_234.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_235.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_236.q",
          12, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_237.q",
          13, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_238.q",
          14, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_239.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_240.q",
          16, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_241.q",
          17, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_242.q",
          18, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_243.q",
          19, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_244.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_245.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_246.q",
          22, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_247.q",
          23, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_248.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_249.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_250.q",
          26, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_251.q",
          27, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_252.q",
          28, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_253.q",
          29, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_254.q",
          30, 1, 0, "BkdrRegPathRtl");
      cmd_filter[7].add_hdl_path_slice(
          "u_reg.u_cmd_filter_7_filter_255.q",
          31, 1, 0, "BkdrRegPathRtl");

      addr_swap_mask =
          (spi_device_reg_addr_swap_mask::
           type_id::create("addr_swap_mask"));
      addr_swap_mask.configure(.blk_parent(this));
      addr_swap_mask.build(csr_excl);
      default_map.add_reg(.rg(addr_swap_mask),
                          .offset(32'h6c));
      addr_swap_mask.add_hdl_path_slice(
          "u_reg.u_addr_swap_mask.q",
          0, 32, 0, "BkdrRegPathRtl");

      addr_swap_data =
          (spi_device_reg_addr_swap_data::
           type_id::create("addr_swap_data"));
      addr_swap_data.configure(.blk_parent(this));
      addr_swap_data.build(csr_excl);
      default_map.add_reg(.rg(addr_swap_data),
                          .offset(32'h70));
      addr_swap_data.add_hdl_path_slice(
          "u_reg.u_addr_swap_data.q",
          0, 32, 0, "BkdrRegPathRtl");

      payload_swap_mask =
          (spi_device_reg_payload_swap_mask::
           type_id::create("payload_swap_mask"));
      payload_swap_mask.configure(.blk_parent(this));
      payload_swap_mask.build(csr_excl);
      default_map.add_reg(.rg(payload_swap_mask),
                          .offset(32'h74));
      payload_swap_mask.add_hdl_path_slice(
          "u_reg.u_payload_swap_mask.q",
          0, 32, 0, "BkdrRegPathRtl");

      payload_swap_data =
          (spi_device_reg_payload_swap_data::
           type_id::create("payload_swap_data"));
      payload_swap_data.configure(.blk_parent(this));
      payload_swap_data.build(csr_excl);
      default_map.add_reg(.rg(payload_swap_data),
                          .offset(32'h78));
      payload_swap_data.add_hdl_path_slice(
          "u_reg.u_payload_swap_data.q",
          0, 32, 0, "BkdrRegPathRtl");

      cmd_info[0] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_0"));
      cmd_info[0].configure(.blk_parent(this));
      cmd_info[0].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[0]),
                          .offset(32'h7c));
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_opcode_0.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_addr_mode_0.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_addr_swap_en_0.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_mbyte_en_0.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_dummy_size_0.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_dummy_en_0.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_payload_en_0.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_payload_dir_0.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_payload_swap_en_0.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_read_pipeline_mode_0.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_upload_0.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_busy_0.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[0].add_hdl_path_slice(
          "u_reg.u_cmd_info_0_valid_0.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[1] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_1"));
      cmd_info[1].configure(.blk_parent(this));
      cmd_info[1].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[1]),
                          .offset(32'h80));
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_opcode_1.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_addr_mode_1.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_addr_swap_en_1.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_mbyte_en_1.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_dummy_size_1.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_dummy_en_1.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_payload_en_1.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_payload_dir_1.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_payload_swap_en_1.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_read_pipeline_mode_1.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_upload_1.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_busy_1.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[1].add_hdl_path_slice(
          "u_reg.u_cmd_info_1_valid_1.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[2] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_2"));
      cmd_info[2].configure(.blk_parent(this));
      cmd_info[2].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[2]),
                          .offset(32'h84));
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_opcode_2.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_addr_mode_2.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_addr_swap_en_2.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_mbyte_en_2.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_dummy_size_2.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_dummy_en_2.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_payload_en_2.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_payload_dir_2.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_payload_swap_en_2.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_read_pipeline_mode_2.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_upload_2.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_busy_2.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[2].add_hdl_path_slice(
          "u_reg.u_cmd_info_2_valid_2.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[3] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_3"));
      cmd_info[3].configure(.blk_parent(this));
      cmd_info[3].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[3]),
                          .offset(32'h88));
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_opcode_3.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_addr_mode_3.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_addr_swap_en_3.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_mbyte_en_3.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_dummy_size_3.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_dummy_en_3.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_payload_en_3.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_payload_dir_3.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_payload_swap_en_3.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_read_pipeline_mode_3.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_upload_3.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_busy_3.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[3].add_hdl_path_slice(
          "u_reg.u_cmd_info_3_valid_3.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[4] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_4"));
      cmd_info[4].configure(.blk_parent(this));
      cmd_info[4].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[4]),
                          .offset(32'h8c));
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_opcode_4.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_addr_mode_4.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_addr_swap_en_4.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_mbyte_en_4.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_dummy_size_4.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_dummy_en_4.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_payload_en_4.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_payload_dir_4.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_payload_swap_en_4.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_read_pipeline_mode_4.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_upload_4.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_busy_4.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[4].add_hdl_path_slice(
          "u_reg.u_cmd_info_4_valid_4.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[5] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_5"));
      cmd_info[5].configure(.blk_parent(this));
      cmd_info[5].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[5]),
                          .offset(32'h90));
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_opcode_5.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_addr_mode_5.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_addr_swap_en_5.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_mbyte_en_5.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_dummy_size_5.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_dummy_en_5.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_payload_en_5.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_payload_dir_5.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_payload_swap_en_5.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_read_pipeline_mode_5.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_upload_5.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_busy_5.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[5].add_hdl_path_slice(
          "u_reg.u_cmd_info_5_valid_5.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[6] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_6"));
      cmd_info[6].configure(.blk_parent(this));
      cmd_info[6].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[6]),
                          .offset(32'h94));
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_opcode_6.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_addr_mode_6.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_addr_swap_en_6.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_mbyte_en_6.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_dummy_size_6.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_dummy_en_6.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_payload_en_6.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_payload_dir_6.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_payload_swap_en_6.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_read_pipeline_mode_6.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_upload_6.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_busy_6.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[6].add_hdl_path_slice(
          "u_reg.u_cmd_info_6_valid_6.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[7] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_7"));
      cmd_info[7].configure(.blk_parent(this));
      cmd_info[7].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[7]),
                          .offset(32'h98));
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_opcode_7.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_addr_mode_7.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_addr_swap_en_7.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_mbyte_en_7.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_dummy_size_7.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_dummy_en_7.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_payload_en_7.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_payload_dir_7.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_payload_swap_en_7.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_read_pipeline_mode_7.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_upload_7.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_busy_7.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[7].add_hdl_path_slice(
          "u_reg.u_cmd_info_7_valid_7.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[8] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_8"));
      cmd_info[8].configure(.blk_parent(this));
      cmd_info[8].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[8]),
                          .offset(32'h9c));
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_opcode_8.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_addr_mode_8.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_addr_swap_en_8.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_mbyte_en_8.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_dummy_size_8.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_dummy_en_8.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_payload_en_8.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_payload_dir_8.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_payload_swap_en_8.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_read_pipeline_mode_8.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_upload_8.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_busy_8.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[8].add_hdl_path_slice(
          "u_reg.u_cmd_info_8_valid_8.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[9] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_9"));
      cmd_info[9].configure(.blk_parent(this));
      cmd_info[9].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[9]),
                          .offset(32'ha0));
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_opcode_9.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_addr_mode_9.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_addr_swap_en_9.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_mbyte_en_9.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_dummy_size_9.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_dummy_en_9.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_payload_en_9.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_payload_dir_9.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_payload_swap_en_9.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_read_pipeline_mode_9.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_upload_9.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_busy_9.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[9].add_hdl_path_slice(
          "u_reg.u_cmd_info_9_valid_9.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[10] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_10"));
      cmd_info[10].configure(.blk_parent(this));
      cmd_info[10].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[10]),
                          .offset(32'ha4));
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_opcode_10.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_addr_mode_10.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_addr_swap_en_10.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_mbyte_en_10.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_dummy_size_10.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_dummy_en_10.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_payload_en_10.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_payload_dir_10.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_payload_swap_en_10.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_read_pipeline_mode_10.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_upload_10.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_busy_10.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[10].add_hdl_path_slice(
          "u_reg.u_cmd_info_10_valid_10.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[11] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_11"));
      cmd_info[11].configure(.blk_parent(this));
      cmd_info[11].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[11]),
                          .offset(32'ha8));
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_opcode_11.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_addr_mode_11.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_addr_swap_en_11.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_mbyte_en_11.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_dummy_size_11.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_dummy_en_11.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_payload_en_11.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_payload_dir_11.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_payload_swap_en_11.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_read_pipeline_mode_11.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_upload_11.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_busy_11.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[11].add_hdl_path_slice(
          "u_reg.u_cmd_info_11_valid_11.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[12] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_12"));
      cmd_info[12].configure(.blk_parent(this));
      cmd_info[12].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[12]),
                          .offset(32'hac));
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_opcode_12.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_addr_mode_12.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_addr_swap_en_12.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_mbyte_en_12.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_dummy_size_12.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_dummy_en_12.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_payload_en_12.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_payload_dir_12.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_payload_swap_en_12.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_read_pipeline_mode_12.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_upload_12.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_busy_12.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[12].add_hdl_path_slice(
          "u_reg.u_cmd_info_12_valid_12.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[13] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_13"));
      cmd_info[13].configure(.blk_parent(this));
      cmd_info[13].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[13]),
                          .offset(32'hb0));
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_opcode_13.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_addr_mode_13.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_addr_swap_en_13.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_mbyte_en_13.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_dummy_size_13.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_dummy_en_13.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_payload_en_13.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_payload_dir_13.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_payload_swap_en_13.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_read_pipeline_mode_13.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_upload_13.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_busy_13.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[13].add_hdl_path_slice(
          "u_reg.u_cmd_info_13_valid_13.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[14] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_14"));
      cmd_info[14].configure(.blk_parent(this));
      cmd_info[14].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[14]),
                          .offset(32'hb4));
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_opcode_14.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_addr_mode_14.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_addr_swap_en_14.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_mbyte_en_14.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_dummy_size_14.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_dummy_en_14.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_payload_en_14.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_payload_dir_14.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_payload_swap_en_14.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_read_pipeline_mode_14.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_upload_14.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_busy_14.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[14].add_hdl_path_slice(
          "u_reg.u_cmd_info_14_valid_14.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[15] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_15"));
      cmd_info[15].configure(.blk_parent(this));
      cmd_info[15].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[15]),
                          .offset(32'hb8));
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_opcode_15.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_addr_mode_15.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_addr_swap_en_15.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_mbyte_en_15.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_dummy_size_15.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_dummy_en_15.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_payload_en_15.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_payload_dir_15.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_payload_swap_en_15.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_read_pipeline_mode_15.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_upload_15.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_busy_15.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[15].add_hdl_path_slice(
          "u_reg.u_cmd_info_15_valid_15.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[16] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_16"));
      cmd_info[16].configure(.blk_parent(this));
      cmd_info[16].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[16]),
                          .offset(32'hbc));
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_opcode_16.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_addr_mode_16.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_addr_swap_en_16.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_mbyte_en_16.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_dummy_size_16.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_dummy_en_16.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_payload_en_16.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_payload_dir_16.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_payload_swap_en_16.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_read_pipeline_mode_16.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_upload_16.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_busy_16.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[16].add_hdl_path_slice(
          "u_reg.u_cmd_info_16_valid_16.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[17] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_17"));
      cmd_info[17].configure(.blk_parent(this));
      cmd_info[17].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[17]),
                          .offset(32'hc0));
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_opcode_17.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_addr_mode_17.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_addr_swap_en_17.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_mbyte_en_17.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_dummy_size_17.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_dummy_en_17.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_payload_en_17.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_payload_dir_17.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_payload_swap_en_17.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_read_pipeline_mode_17.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_upload_17.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_busy_17.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[17].add_hdl_path_slice(
          "u_reg.u_cmd_info_17_valid_17.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[18] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_18"));
      cmd_info[18].configure(.blk_parent(this));
      cmd_info[18].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[18]),
                          .offset(32'hc4));
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_opcode_18.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_addr_mode_18.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_addr_swap_en_18.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_mbyte_en_18.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_dummy_size_18.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_dummy_en_18.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_payload_en_18.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_payload_dir_18.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_payload_swap_en_18.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_read_pipeline_mode_18.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_upload_18.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_busy_18.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[18].add_hdl_path_slice(
          "u_reg.u_cmd_info_18_valid_18.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[19] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_19"));
      cmd_info[19].configure(.blk_parent(this));
      cmd_info[19].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[19]),
                          .offset(32'hc8));
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_opcode_19.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_addr_mode_19.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_addr_swap_en_19.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_mbyte_en_19.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_dummy_size_19.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_dummy_en_19.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_payload_en_19.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_payload_dir_19.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_payload_swap_en_19.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_read_pipeline_mode_19.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_upload_19.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_busy_19.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[19].add_hdl_path_slice(
          "u_reg.u_cmd_info_19_valid_19.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[20] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_20"));
      cmd_info[20].configure(.blk_parent(this));
      cmd_info[20].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[20]),
                          .offset(32'hcc));
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_opcode_20.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_addr_mode_20.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_addr_swap_en_20.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_mbyte_en_20.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_dummy_size_20.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_dummy_en_20.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_payload_en_20.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_payload_dir_20.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_payload_swap_en_20.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_read_pipeline_mode_20.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_upload_20.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_busy_20.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[20].add_hdl_path_slice(
          "u_reg.u_cmd_info_20_valid_20.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[21] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_21"));
      cmd_info[21].configure(.blk_parent(this));
      cmd_info[21].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[21]),
                          .offset(32'hd0));
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_opcode_21.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_addr_mode_21.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_addr_swap_en_21.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_mbyte_en_21.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_dummy_size_21.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_dummy_en_21.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_payload_en_21.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_payload_dir_21.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_payload_swap_en_21.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_read_pipeline_mode_21.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_upload_21.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_busy_21.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[21].add_hdl_path_slice(
          "u_reg.u_cmd_info_21_valid_21.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[22] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_22"));
      cmd_info[22].configure(.blk_parent(this));
      cmd_info[22].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[22]),
                          .offset(32'hd4));
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_opcode_22.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_addr_mode_22.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_addr_swap_en_22.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_mbyte_en_22.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_dummy_size_22.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_dummy_en_22.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_payload_en_22.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_payload_dir_22.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_payload_swap_en_22.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_read_pipeline_mode_22.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_upload_22.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_busy_22.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[22].add_hdl_path_slice(
          "u_reg.u_cmd_info_22_valid_22.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info[23] =
          (spi_device_reg_cmd_info::
           type_id::create("cmd_info_23"));
      cmd_info[23].configure(.blk_parent(this));
      cmd_info[23].build(csr_excl);
      default_map.add_reg(.rg(cmd_info[23]),
                          .offset(32'hd8));
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_opcode_23.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_addr_mode_23.q",
          8, 2, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_addr_swap_en_23.q",
          10, 1, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_mbyte_en_23.q",
          11, 1, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_dummy_size_23.q",
          12, 3, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_dummy_en_23.q",
          15, 1, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_payload_en_23.q",
          16, 4, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_payload_dir_23.q",
          20, 1, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_payload_swap_en_23.q",
          21, 1, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_read_pipeline_mode_23.q",
          22, 2, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_upload_23.q",
          24, 1, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_busy_23.q",
          25, 1, 0, "BkdrRegPathRtl");
      cmd_info[23].add_hdl_path_slice(
          "u_reg.u_cmd_info_23_valid_23.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info_en4b =
          (spi_device_reg_cmd_info_en4b::
           type_id::create("cmd_info_en4b"));
      cmd_info_en4b.configure(.blk_parent(this));
      cmd_info_en4b.build(csr_excl);
      default_map.add_reg(.rg(cmd_info_en4b),
                          .offset(32'hdc));
      cmd_info_en4b.add_hdl_path_slice(
          "u_reg.u_cmd_info_en4b_opcode.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info_en4b.add_hdl_path_slice(
          "u_reg.u_cmd_info_en4b_valid.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info_ex4b =
          (spi_device_reg_cmd_info_ex4b::
           type_id::create("cmd_info_ex4b"));
      cmd_info_ex4b.configure(.blk_parent(this));
      cmd_info_ex4b.build(csr_excl);
      default_map.add_reg(.rg(cmd_info_ex4b),
                          .offset(32'he0));
      cmd_info_ex4b.add_hdl_path_slice(
          "u_reg.u_cmd_info_ex4b_opcode.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info_ex4b.add_hdl_path_slice(
          "u_reg.u_cmd_info_ex4b_valid.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info_wren =
          (spi_device_reg_cmd_info_wren::
           type_id::create("cmd_info_wren"));
      cmd_info_wren.configure(.blk_parent(this));
      cmd_info_wren.build(csr_excl);
      default_map.add_reg(.rg(cmd_info_wren),
                          .offset(32'he4));
      cmd_info_wren.add_hdl_path_slice(
          "u_reg.u_cmd_info_wren_opcode.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info_wren.add_hdl_path_slice(
          "u_reg.u_cmd_info_wren_valid.q",
          31, 1, 0, "BkdrRegPathRtl");

      cmd_info_wrdi =
          (spi_device_reg_cmd_info_wrdi::
           type_id::create("cmd_info_wrdi"));
      cmd_info_wrdi.configure(.blk_parent(this));
      cmd_info_wrdi.build(csr_excl);
      default_map.add_reg(.rg(cmd_info_wrdi),
                          .offset(32'he8));
      cmd_info_wrdi.add_hdl_path_slice(
          "u_reg.u_cmd_info_wrdi_opcode.q",
          0, 8, 0, "BkdrRegPathRtl");
      cmd_info_wrdi.add_hdl_path_slice(
          "u_reg.u_cmd_info_wrdi_valid.q",
          31, 1, 0, "BkdrRegPathRtl");

      tpm_cap =
          (spi_device_reg_tpm_cap::
           type_id::create("tpm_cap"));
      tpm_cap.configure(.blk_parent(this));
      tpm_cap.build(csr_excl);
      default_map.add_reg(.rg(tpm_cap),
                          .offset(32'h800));
      tpm_cap.add_hdl_path_slice(
          "u_reg.u_tpm_cap_rev.q",
          0, 8, 0, "BkdrRegPathRtl");
      tpm_cap.add_hdl_path_slice(
          "u_reg.u_tpm_cap_locality.q",
          8, 1, 0, "BkdrRegPathRtl");
      tpm_cap.add_hdl_path_slice(
          "u_reg.u_tpm_cap_max_wr_size.q",
          16, 3, 0, "BkdrRegPathRtl");
      tpm_cap.add_hdl_path_slice(
          "u_reg.u_tpm_cap_max_rd_size.q",
          20, 3, 0, "BkdrRegPathRtl");

      tpm_cfg =
          (spi_device_reg_tpm_cfg::
           type_id::create("tpm_cfg"));
      tpm_cfg.configure(.blk_parent(this));
      tpm_cfg.build(csr_excl);
      default_map.add_reg(.rg(tpm_cfg),
                          .offset(32'h804));
      tpm_cfg.add_hdl_path_slice(
          "u_reg.u_tpm_cfg_en.q",
          0, 1, 0, "BkdrRegPathRtl");
      tpm_cfg.add_hdl_path_slice(
          "u_reg.u_tpm_cfg_tpm_mode.q",
          1, 1, 0, "BkdrRegPathRtl");
      tpm_cfg.add_hdl_path_slice(
          "u_reg.u_tpm_cfg_hw_reg_dis.q",
          2, 1, 0, "BkdrRegPathRtl");
      tpm_cfg.add_hdl_path_slice(
          "u_reg.u_tpm_cfg_tpm_reg_chk_dis.q",
          3, 1, 0, "BkdrRegPathRtl");
      tpm_cfg.add_hdl_path_slice(
          "u_reg.u_tpm_cfg_invalid_locality.q",
          4, 1, 0, "BkdrRegPathRtl");

      tpm_status =
          (spi_device_reg_tpm_status::
           type_id::create("tpm_status"));
      tpm_status.configure(.blk_parent(this));
      tpm_status.build(csr_excl);
      default_map.add_reg(.rg(tpm_status),
                          .offset(32'h808));
      tpm_status.add_hdl_path_slice(
          "u_reg.u_tpm_status_cmdaddr_notempty.qs",
          0, 1, 0, "BkdrRegPathRtl");
      tpm_status.add_hdl_path_slice(
          "u_reg.u_tpm_status_wrfifo_pending.qs",
          1, 1, 0, "BkdrRegPathRtl");
      tpm_status.add_hdl_path_slice(
          "u_reg.u_tpm_status_rdfifo_aborted.qs",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(tpm_status.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      tpm_access_0 =
          (spi_device_reg_tpm_access_0::
           type_id::create("tpm_access_0"));
      tpm_access_0.configure(.blk_parent(this));
      tpm_access_0.build(csr_excl);
      default_map.add_reg(.rg(tpm_access_0),
                          .offset(32'h80c));
      tpm_access_0.add_hdl_path_slice(
          "u_reg.u_tpm_access_0_access_0.q",
          0, 8, 0, "BkdrRegPathRtl");
      tpm_access_0.add_hdl_path_slice(
          "u_reg.u_tpm_access_0_access_1.q",
          8, 8, 0, "BkdrRegPathRtl");
      tpm_access_0.add_hdl_path_slice(
          "u_reg.u_tpm_access_0_access_2.q",
          16, 8, 0, "BkdrRegPathRtl");
      tpm_access_0.add_hdl_path_slice(
          "u_reg.u_tpm_access_0_access_3.q",
          24, 8, 0, "BkdrRegPathRtl");

      tpm_access_1 =
          (spi_device_reg_tpm_access_1::
           type_id::create("tpm_access_1"));
      tpm_access_1.configure(.blk_parent(this));
      tpm_access_1.build(csr_excl);
      default_map.add_reg(.rg(tpm_access_1),
                          .offset(32'h810));
      tpm_access_1.add_hdl_path_slice(
          "u_reg.u_tpm_access_1.q",
          0, 8, 0, "BkdrRegPathRtl");

      tpm_sts =
          (spi_device_reg_tpm_sts::
           type_id::create("tpm_sts"));
      tpm_sts.configure(.blk_parent(this));
      tpm_sts.build(csr_excl);
      default_map.add_reg(.rg(tpm_sts),
                          .offset(32'h814));
      tpm_sts.add_hdl_path_slice(
          "u_reg.u_tpm_sts.q",
          0, 32, 0, "BkdrRegPathRtl");

      tpm_intf_capability =
          (spi_device_reg_tpm_intf_capability::
           type_id::create("tpm_intf_capability"));
      tpm_intf_capability.configure(.blk_parent(this));
      tpm_intf_capability.build(csr_excl);
      default_map.add_reg(.rg(tpm_intf_capability),
                          .offset(32'h818));
      tpm_intf_capability.add_hdl_path_slice(
          "u_reg.u_tpm_intf_capability.q",
          0, 32, 0, "BkdrRegPathRtl");

      tpm_int_enable =
          (spi_device_reg_tpm_int_enable::
           type_id::create("tpm_int_enable"));
      tpm_int_enable.configure(.blk_parent(this));
      tpm_int_enable.build(csr_excl);
      default_map.add_reg(.rg(tpm_int_enable),
                          .offset(32'h81c));
      tpm_int_enable.add_hdl_path_slice(
          "u_reg.u_tpm_int_enable.q",
          0, 32, 0, "BkdrRegPathRtl");

      tpm_int_vector =
          (spi_device_reg_tpm_int_vector::
           type_id::create("tpm_int_vector"));
      tpm_int_vector.configure(.blk_parent(this));
      tpm_int_vector.build(csr_excl);
      default_map.add_reg(.rg(tpm_int_vector),
                          .offset(32'h820));
      tpm_int_vector.add_hdl_path_slice(
          "u_reg.u_tpm_int_vector.q",
          0, 8, 0, "BkdrRegPathRtl");

      tpm_int_status =
          (spi_device_reg_tpm_int_status::
           type_id::create("tpm_int_status"));
      tpm_int_status.configure(.blk_parent(this));
      tpm_int_status.build(csr_excl);
      default_map.add_reg(.rg(tpm_int_status),
                          .offset(32'h824));
      tpm_int_status.add_hdl_path_slice(
          "u_reg.u_tpm_int_status.q",
          0, 32, 0, "BkdrRegPathRtl");

      tpm_did_vid =
          (spi_device_reg_tpm_did_vid::
           type_id::create("tpm_did_vid"));
      tpm_did_vid.configure(.blk_parent(this));
      tpm_did_vid.build(csr_excl);
      default_map.add_reg(.rg(tpm_did_vid),
                          .offset(32'h828));
      tpm_did_vid.add_hdl_path_slice(
          "u_reg.u_tpm_did_vid_vid.q",
          0, 16, 0, "BkdrRegPathRtl");
      tpm_did_vid.add_hdl_path_slice(
          "u_reg.u_tpm_did_vid_did.q",
          16, 16, 0, "BkdrRegPathRtl");

      tpm_rid =
          (spi_device_reg_tpm_rid::
           type_id::create("tpm_rid"));
      tpm_rid.configure(.blk_parent(this));
      tpm_rid.build(csr_excl);
      default_map.add_reg(.rg(tpm_rid),
                          .offset(32'h82c));
      tpm_rid.add_hdl_path_slice(
          "u_reg.u_tpm_rid.q",
          0, 8, 0, "BkdrRegPathRtl");

      tpm_cmd_addr =
          (spi_device_reg_tpm_cmd_addr::
           type_id::create("tpm_cmd_addr"));
      tpm_cmd_addr.configure(.blk_parent(this));
      tpm_cmd_addr.build(csr_excl);
      default_map.add_reg(.rg(tpm_cmd_addr),
                          .offset(32'h830));
      tpm_cmd_addr.add_hdl_path_slice(
          "u_reg.u_tpm_cmd_addr_addr.qs",
          0, 24, 0, "BkdrRegPathRtl");
      tpm_cmd_addr.add_hdl_path_slice(
          "u_reg.u_tpm_cmd_addr_cmd.qs",
          24, 8, 0, "BkdrRegPathRtl");

      tpm_read_fifo =
          (spi_device_reg_tpm_read_fifo::
           type_id::create("tpm_read_fifo"));
      tpm_read_fifo.configure(.blk_parent(this));
      tpm_read_fifo.build(csr_excl);
      default_map.add_reg(.rg(tpm_read_fifo),
                          .offset(32'h834));
      tpm_read_fifo.add_hdl_path_slice(
          "u_reg.u_tpm_read_fifo.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(tpm_read_fifo.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);

      // create memories
      egress_buffer =
          spi_device_mem_egress_buffer::type_id::create("egress_buffer");
      egress_buffer.configure(.parent(this));
      default_map.add_mem(.mem(egress_buffer),
                          .offset(32'h1000),
                          .rights("WO"));
      ingress_buffer =
          spi_device_mem_ingress_buffer::type_id::create("ingress_buffer");
      ingress_buffer.configure(.parent(this));
      default_map.add_mem(.mem(ingress_buffer),
                          .offset(32'h1e00),
                          .rights("RO"));


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : spi_device_reg_block

endpackage

