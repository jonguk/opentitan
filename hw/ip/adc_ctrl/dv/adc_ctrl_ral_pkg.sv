// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package adc_ctrl_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class adc_ctrl_reg_intr_state;
  typedef class adc_ctrl_reg_intr_enable;
  typedef class adc_ctrl_reg_intr_test;
  typedef class adc_ctrl_reg_alert_test;
  typedef class adc_ctrl_reg_adc_en_ctl;
  typedef class adc_ctrl_reg_adc_pd_ctl;
  typedef class adc_ctrl_reg_adc_lp_sample_ctl;
  typedef class adc_ctrl_reg_adc_sample_ctl;
  typedef class adc_ctrl_reg_adc_fsm_rst;
  typedef class adc_ctrl_reg_adc_chn0_filter_ctl;
  typedef class adc_ctrl_reg_adc_chn1_filter_ctl;
  typedef class adc_ctrl_reg_adc_chn_val;
  typedef class adc_ctrl_reg_adc_wakeup_ctl;
  typedef class adc_ctrl_reg_filter_status;
  typedef class adc_ctrl_reg_adc_intr_ctl;
  typedef class adc_ctrl_reg_adc_intr_status;
  typedef class adc_ctrl_reg_adc_fsm_state;
  typedef class adc_ctrl_reg_block;

  class adc_ctrl_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field match_pending;

    `uvm_object_utils(adc_ctrl_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      match_pending =
          (dv_base_reg_field::
           type_id::create("match_pending"));
      match_pending.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      match_pending.set_original_access("RO");
    endfunction : build
  endclass : adc_ctrl_reg_intr_state

  class adc_ctrl_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field match_pending;

    `uvm_object_utils(adc_ctrl_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      match_pending =
          (dv_base_reg_field::
           type_id::create("match_pending"));
      match_pending.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      match_pending.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_intr_enable

  class adc_ctrl_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field match_pending;

    `uvm_object_utils(adc_ctrl_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      match_pending =
          (dv_base_reg_field::
           type_id::create("match_pending"));
      match_pending.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      match_pending.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : adc_ctrl_reg_intr_test

  class adc_ctrl_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(adc_ctrl_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : adc_ctrl_reg_alert_test

  class adc_ctrl_reg_adc_en_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field adc_enable;
    rand dv_base_reg_field oneshot_mode;

    `uvm_object_utils(adc_ctrl_reg_adc_en_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      adc_enable =
          (dv_base_reg_field::
           type_id::create("adc_enable"));
      adc_enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adc_enable.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(adc_enable.get_full_name(), CsrExclWrite, CsrNonInitTests);
      oneshot_mode =
          (dv_base_reg_field::
           type_id::create("oneshot_mode"));
      oneshot_mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      oneshot_mode.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_en_ctl

  class adc_ctrl_reg_adc_pd_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field lp_mode;
    rand dv_base_reg_field pwrup_time;
    rand dv_base_reg_field wakeup_time;

    `uvm_object_utils(adc_ctrl_reg_adc_pd_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      lp_mode =
          (dv_base_reg_field::
           type_id::create("lp_mode"));
      lp_mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      lp_mode.set_original_access("RW");
      pwrup_time =
          (dv_base_reg_field::
           type_id::create("pwrup_time"));
      pwrup_time.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrup_time.set_original_access("RW");
      wakeup_time =
          (dv_base_reg_field::
           type_id::create("wakeup_time"));
      wakeup_time.configure(
        .parent(this),
        .size(24),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h640),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wakeup_time.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_pd_ctl

  class adc_ctrl_reg_adc_lp_sample_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field lp_sample_cnt;

    `uvm_object_utils(adc_ctrl_reg_adc_lp_sample_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      lp_sample_cnt =
          (dv_base_reg_field::
           type_id::create("lp_sample_cnt"));
      lp_sample_cnt.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h4),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      lp_sample_cnt.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_lp_sample_ctl

  class adc_ctrl_reg_adc_sample_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field np_sample_cnt;

    `uvm_object_utils(adc_ctrl_reg_adc_sample_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      np_sample_cnt =
          (dv_base_reg_field::
           type_id::create("np_sample_cnt"));
      np_sample_cnt.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h9b),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      np_sample_cnt.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_sample_ctl

  class adc_ctrl_reg_adc_fsm_rst extends dv_base_reg;
    // fields
    rand dv_base_reg_field rst_en;

    `uvm_object_utils(adc_ctrl_reg_adc_fsm_rst)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      rst_en =
          (dv_base_reg_field::
           type_id::create("rst_en"));
      rst_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rst_en.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_fsm_rst

  class adc_ctrl_reg_adc_chn0_filter_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field min_v;
    rand dv_base_reg_field cond;
    rand dv_base_reg_field max_v;
    rand dv_base_reg_field en;

    `uvm_object_utils(adc_ctrl_reg_adc_chn0_filter_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      min_v =
          (dv_base_reg_field::
           type_id::create("min_v"));
      min_v.configure(
        .parent(this),
        .size(10),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      min_v.set_original_access("RW");
      cond =
          (dv_base_reg_field::
           type_id::create("cond"));
      cond.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cond.set_original_access("RW");
      max_v =
          (dv_base_reg_field::
           type_id::create("max_v"));
      max_v.configure(
        .parent(this),
        .size(10),
        .lsb_pos(18),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      max_v.set_original_access("RW");
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_chn0_filter_ctl

  class adc_ctrl_reg_adc_chn1_filter_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field min_v;
    rand dv_base_reg_field cond;
    rand dv_base_reg_field max_v;
    rand dv_base_reg_field en;

    `uvm_object_utils(adc_ctrl_reg_adc_chn1_filter_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      min_v =
          (dv_base_reg_field::
           type_id::create("min_v"));
      min_v.configure(
        .parent(this),
        .size(10),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      min_v.set_original_access("RW");
      cond =
          (dv_base_reg_field::
           type_id::create("cond"));
      cond.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cond.set_original_access("RW");
      max_v =
          (dv_base_reg_field::
           type_id::create("max_v"));
      max_v.configure(
        .parent(this),
        .size(10),
        .lsb_pos(18),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      max_v.set_original_access("RW");
      en =
          (dv_base_reg_field::
           type_id::create("en"));
      en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      en.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_chn1_filter_ctl

  class adc_ctrl_reg_adc_chn_val extends dv_base_reg;
    // fields
    rand dv_base_reg_field adc_chn_value_ext;
    rand dv_base_reg_field adc_chn_value;
    rand dv_base_reg_field adc_chn_value_intr_ext;
    rand dv_base_reg_field adc_chn_value_intr;

    `uvm_object_utils(adc_ctrl_reg_adc_chn_val)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      adc_chn_value_ext =
          (dv_base_reg_field::
           type_id::create("adc_chn_value_ext"));
      adc_chn_value_ext.configure(
        .parent(this),
        .size(2),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adc_chn_value_ext.set_original_access("RO");
      adc_chn_value =
          (dv_base_reg_field::
           type_id::create("adc_chn_value"));
      adc_chn_value.configure(
        .parent(this),
        .size(10),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adc_chn_value.set_original_access("RO");
      adc_chn_value_intr_ext =
          (dv_base_reg_field::
           type_id::create("adc_chn_value_intr_ext"));
      adc_chn_value_intr_ext.configure(
        .parent(this),
        .size(2),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adc_chn_value_intr_ext.set_original_access("RO");
      adc_chn_value_intr =
          (dv_base_reg_field::
           type_id::create("adc_chn_value_intr"));
      adc_chn_value_intr.configure(
        .parent(this),
        .size(10),
        .lsb_pos(18),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adc_chn_value_intr.set_original_access("RO");
    endfunction : build
  endclass : adc_ctrl_reg_adc_chn_val

  class adc_ctrl_reg_adc_wakeup_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field match_en;
    rand dv_base_reg_field trans_en;

    `uvm_object_utils(adc_ctrl_reg_adc_wakeup_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      match_en =
          (dv_base_reg_field::
           type_id::create("match_en"));
      match_en.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      match_en.set_original_access("RW");
      trans_en =
          (dv_base_reg_field::
           type_id::create("trans_en"));
      trans_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      trans_en.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_wakeup_ctl

  class adc_ctrl_reg_filter_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field match;
    rand dv_base_reg_field trans;

    `uvm_object_utils(adc_ctrl_reg_filter_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      match =
          (dv_base_reg_field::
           type_id::create("match"));
      match.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      match.set_original_access("W1C");
      trans =
          (dv_base_reg_field::
           type_id::create("trans"));
      trans.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      trans.set_original_access("W1C");
    endfunction : build
  endclass : adc_ctrl_reg_filter_status

  class adc_ctrl_reg_adc_intr_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field match_en;
    rand dv_base_reg_field trans_en;
    rand dv_base_reg_field oneshot_en;

    `uvm_object_utils(adc_ctrl_reg_adc_intr_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      match_en =
          (dv_base_reg_field::
           type_id::create("match_en"));
      match_en.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      match_en.set_original_access("RW");
      trans_en =
          (dv_base_reg_field::
           type_id::create("trans_en"));
      trans_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      trans_en.set_original_access("RW");
      oneshot_en =
          (dv_base_reg_field::
           type_id::create("oneshot_en"));
      oneshot_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      oneshot_en.set_original_access("RW");
    endfunction : build
  endclass : adc_ctrl_reg_adc_intr_ctl

  class adc_ctrl_reg_adc_intr_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field match;
    rand dv_base_reg_field trans;
    rand dv_base_reg_field oneshot;

    `uvm_object_utils(adc_ctrl_reg_adc_intr_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      match =
          (dv_base_reg_field::
           type_id::create("match"));
      match.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      match.set_original_access("W1C");
      trans =
          (dv_base_reg_field::
           type_id::create("trans"));
      trans.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      trans.set_original_access("W1C");
      oneshot =
          (dv_base_reg_field::
           type_id::create("oneshot"));
      oneshot.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      oneshot.set_original_access("W1C");
    endfunction : build
  endclass : adc_ctrl_reg_adc_intr_status

  class adc_ctrl_reg_adc_fsm_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field state;

    `uvm_object_utils(adc_ctrl_reg_adc_fsm_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      state =
          (dv_base_reg_field::
           type_id::create("state"));
      state.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      state.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : adc_ctrl_reg_adc_fsm_state

  class adc_ctrl_reg_block extends dv_base_reg_block;
    // registers
    rand adc_ctrl_reg_intr_state intr_state;
    rand adc_ctrl_reg_intr_enable intr_enable;
    rand adc_ctrl_reg_intr_test intr_test;
    rand adc_ctrl_reg_alert_test alert_test;
    rand adc_ctrl_reg_adc_en_ctl adc_en_ctl;
    rand adc_ctrl_reg_adc_pd_ctl adc_pd_ctl;
    rand adc_ctrl_reg_adc_lp_sample_ctl adc_lp_sample_ctl;
    rand adc_ctrl_reg_adc_sample_ctl adc_sample_ctl;
    rand adc_ctrl_reg_adc_fsm_rst adc_fsm_rst;
    rand adc_ctrl_reg_adc_chn0_filter_ctl adc_chn0_filter_ctl[8];
    rand adc_ctrl_reg_adc_chn1_filter_ctl adc_chn1_filter_ctl[8];
    rand adc_ctrl_reg_adc_chn_val adc_chn_val[2];
    rand adc_ctrl_reg_adc_wakeup_ctl adc_wakeup_ctl;
    rand adc_ctrl_reg_filter_status filter_status;
    rand adc_ctrl_reg_adc_intr_ctl adc_intr_ctl;
    rand adc_ctrl_reg_adc_intr_status adc_intr_status;
    rand adc_ctrl_reg_adc_fsm_state adc_fsm_state;

    `uvm_object_utils(adc_ctrl_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (adc_ctrl_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (adc_ctrl_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable.q",
          0, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (adc_ctrl_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (adc_ctrl_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      adc_en_ctl =
          (adc_ctrl_reg_adc_en_ctl::
           type_id::create("adc_en_ctl"));
      adc_en_ctl.configure(.blk_parent(this));
      adc_en_ctl.build(csr_excl);
      default_map.add_reg(.rg(adc_en_ctl),
                          .offset(32'h10));
      adc_en_ctl.add_hdl_path_slice(
          "u_reg.u_adc_en_ctl_adc_enable.q",
          0, 1, 0, "BkdrRegPathRtl");
      adc_en_ctl.add_hdl_path_slice(
          "u_reg.u_adc_en_ctl_oneshot_mode.q",
          1, 1, 0, "BkdrRegPathRtl");

      adc_pd_ctl =
          (adc_ctrl_reg_adc_pd_ctl::
           type_id::create("adc_pd_ctl"));
      adc_pd_ctl.configure(.blk_parent(this));
      adc_pd_ctl.build(csr_excl);
      default_map.add_reg(.rg(adc_pd_ctl),
                          .offset(32'h14));
      adc_pd_ctl.add_hdl_path_slice(
          "u_reg.u_adc_pd_ctl_lp_mode.q",
          0, 1, 0, "BkdrRegPathRtl");
      adc_pd_ctl.add_hdl_path_slice(
          "u_reg.u_adc_pd_ctl_pwrup_time.q",
          4, 4, 0, "BkdrRegPathRtl");
      adc_pd_ctl.add_hdl_path_slice(
          "u_reg.u_adc_pd_ctl_wakeup_time.q",
          8, 24, 0, "BkdrRegPathRtl");

      adc_lp_sample_ctl =
          (adc_ctrl_reg_adc_lp_sample_ctl::
           type_id::create("adc_lp_sample_ctl"));
      adc_lp_sample_ctl.configure(.blk_parent(this));
      adc_lp_sample_ctl.build(csr_excl);
      default_map.add_reg(.rg(adc_lp_sample_ctl),
                          .offset(32'h18));
      adc_lp_sample_ctl.add_hdl_path_slice(
          "u_reg.u_adc_lp_sample_ctl.q",
          0, 8, 0, "BkdrRegPathRtl");

      adc_sample_ctl =
          (adc_ctrl_reg_adc_sample_ctl::
           type_id::create("adc_sample_ctl"));
      adc_sample_ctl.configure(.blk_parent(this));
      adc_sample_ctl.build(csr_excl);
      default_map.add_reg(.rg(adc_sample_ctl),
                          .offset(32'h1c));
      adc_sample_ctl.add_hdl_path_slice(
          "u_reg.u_adc_sample_ctl.q",
          0, 16, 0, "BkdrRegPathRtl");

      adc_fsm_rst =
          (adc_ctrl_reg_adc_fsm_rst::
           type_id::create("adc_fsm_rst"));
      adc_fsm_rst.configure(.blk_parent(this));
      adc_fsm_rst.build(csr_excl);
      default_map.add_reg(.rg(adc_fsm_rst),
                          .offset(32'h20));
      adc_fsm_rst.add_hdl_path_slice(
          "u_reg.u_adc_fsm_rst.q",
          0, 1, 0, "BkdrRegPathRtl");

      adc_chn0_filter_ctl[0] =
          (adc_ctrl_reg_adc_chn0_filter_ctl::
           type_id::create("adc_chn0_filter_ctl_0"));
      adc_chn0_filter_ctl[0].configure(.blk_parent(this));
      adc_chn0_filter_ctl[0].build(csr_excl);
      default_map.add_reg(.rg(adc_chn0_filter_ctl[0]),
                          .offset(32'h24));
      adc_chn0_filter_ctl[0].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_0_min_v_0.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[0].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_0_cond_0.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[0].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_0_max_v_0.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[0].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_0_en_0.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn0_filter_ctl[1] =
          (adc_ctrl_reg_adc_chn0_filter_ctl::
           type_id::create("adc_chn0_filter_ctl_1"));
      adc_chn0_filter_ctl[1].configure(.blk_parent(this));
      adc_chn0_filter_ctl[1].build(csr_excl);
      default_map.add_reg(.rg(adc_chn0_filter_ctl[1]),
                          .offset(32'h28));
      adc_chn0_filter_ctl[1].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_1_min_v_1.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[1].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_1_cond_1.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[1].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_1_max_v_1.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[1].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_1_en_1.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn0_filter_ctl[2] =
          (adc_ctrl_reg_adc_chn0_filter_ctl::
           type_id::create("adc_chn0_filter_ctl_2"));
      adc_chn0_filter_ctl[2].configure(.blk_parent(this));
      adc_chn0_filter_ctl[2].build(csr_excl);
      default_map.add_reg(.rg(adc_chn0_filter_ctl[2]),
                          .offset(32'h2c));
      adc_chn0_filter_ctl[2].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_2_min_v_2.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[2].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_2_cond_2.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[2].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_2_max_v_2.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[2].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_2_en_2.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn0_filter_ctl[3] =
          (adc_ctrl_reg_adc_chn0_filter_ctl::
           type_id::create("adc_chn0_filter_ctl_3"));
      adc_chn0_filter_ctl[3].configure(.blk_parent(this));
      adc_chn0_filter_ctl[3].build(csr_excl);
      default_map.add_reg(.rg(adc_chn0_filter_ctl[3]),
                          .offset(32'h30));
      adc_chn0_filter_ctl[3].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_3_min_v_3.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[3].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_3_cond_3.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[3].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_3_max_v_3.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[3].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_3_en_3.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn0_filter_ctl[4] =
          (adc_ctrl_reg_adc_chn0_filter_ctl::
           type_id::create("adc_chn0_filter_ctl_4"));
      adc_chn0_filter_ctl[4].configure(.blk_parent(this));
      adc_chn0_filter_ctl[4].build(csr_excl);
      default_map.add_reg(.rg(adc_chn0_filter_ctl[4]),
                          .offset(32'h34));
      adc_chn0_filter_ctl[4].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_4_min_v_4.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[4].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_4_cond_4.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[4].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_4_max_v_4.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[4].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_4_en_4.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn0_filter_ctl[5] =
          (adc_ctrl_reg_adc_chn0_filter_ctl::
           type_id::create("adc_chn0_filter_ctl_5"));
      adc_chn0_filter_ctl[5].configure(.blk_parent(this));
      adc_chn0_filter_ctl[5].build(csr_excl);
      default_map.add_reg(.rg(adc_chn0_filter_ctl[5]),
                          .offset(32'h38));
      adc_chn0_filter_ctl[5].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_5_min_v_5.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[5].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_5_cond_5.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[5].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_5_max_v_5.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[5].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_5_en_5.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn0_filter_ctl[6] =
          (adc_ctrl_reg_adc_chn0_filter_ctl::
           type_id::create("adc_chn0_filter_ctl_6"));
      adc_chn0_filter_ctl[6].configure(.blk_parent(this));
      adc_chn0_filter_ctl[6].build(csr_excl);
      default_map.add_reg(.rg(adc_chn0_filter_ctl[6]),
                          .offset(32'h3c));
      adc_chn0_filter_ctl[6].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_6_min_v_6.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[6].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_6_cond_6.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[6].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_6_max_v_6.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[6].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_6_en_6.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn0_filter_ctl[7] =
          (adc_ctrl_reg_adc_chn0_filter_ctl::
           type_id::create("adc_chn0_filter_ctl_7"));
      adc_chn0_filter_ctl[7].configure(.blk_parent(this));
      adc_chn0_filter_ctl[7].build(csr_excl);
      default_map.add_reg(.rg(adc_chn0_filter_ctl[7]),
                          .offset(32'h40));
      adc_chn0_filter_ctl[7].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_7_min_v_7.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[7].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_7_cond_7.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[7].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_7_max_v_7.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn0_filter_ctl[7].add_hdl_path_slice(
          "u_reg.u_adc_chn0_filter_ctl_7_en_7.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn1_filter_ctl[0] =
          (adc_ctrl_reg_adc_chn1_filter_ctl::
           type_id::create("adc_chn1_filter_ctl_0"));
      adc_chn1_filter_ctl[0].configure(.blk_parent(this));
      adc_chn1_filter_ctl[0].build(csr_excl);
      default_map.add_reg(.rg(adc_chn1_filter_ctl[0]),
                          .offset(32'h44));
      adc_chn1_filter_ctl[0].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_0_min_v_0.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[0].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_0_cond_0.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[0].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_0_max_v_0.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[0].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_0_en_0.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn1_filter_ctl[1] =
          (adc_ctrl_reg_adc_chn1_filter_ctl::
           type_id::create("adc_chn1_filter_ctl_1"));
      adc_chn1_filter_ctl[1].configure(.blk_parent(this));
      adc_chn1_filter_ctl[1].build(csr_excl);
      default_map.add_reg(.rg(adc_chn1_filter_ctl[1]),
                          .offset(32'h48));
      adc_chn1_filter_ctl[1].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_1_min_v_1.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[1].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_1_cond_1.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[1].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_1_max_v_1.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[1].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_1_en_1.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn1_filter_ctl[2] =
          (adc_ctrl_reg_adc_chn1_filter_ctl::
           type_id::create("adc_chn1_filter_ctl_2"));
      adc_chn1_filter_ctl[2].configure(.blk_parent(this));
      adc_chn1_filter_ctl[2].build(csr_excl);
      default_map.add_reg(.rg(adc_chn1_filter_ctl[2]),
                          .offset(32'h4c));
      adc_chn1_filter_ctl[2].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_2_min_v_2.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[2].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_2_cond_2.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[2].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_2_max_v_2.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[2].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_2_en_2.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn1_filter_ctl[3] =
          (adc_ctrl_reg_adc_chn1_filter_ctl::
           type_id::create("adc_chn1_filter_ctl_3"));
      adc_chn1_filter_ctl[3].configure(.blk_parent(this));
      adc_chn1_filter_ctl[3].build(csr_excl);
      default_map.add_reg(.rg(adc_chn1_filter_ctl[3]),
                          .offset(32'h50));
      adc_chn1_filter_ctl[3].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_3_min_v_3.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[3].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_3_cond_3.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[3].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_3_max_v_3.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[3].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_3_en_3.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn1_filter_ctl[4] =
          (adc_ctrl_reg_adc_chn1_filter_ctl::
           type_id::create("adc_chn1_filter_ctl_4"));
      adc_chn1_filter_ctl[4].configure(.blk_parent(this));
      adc_chn1_filter_ctl[4].build(csr_excl);
      default_map.add_reg(.rg(adc_chn1_filter_ctl[4]),
                          .offset(32'h54));
      adc_chn1_filter_ctl[4].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_4_min_v_4.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[4].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_4_cond_4.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[4].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_4_max_v_4.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[4].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_4_en_4.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn1_filter_ctl[5] =
          (adc_ctrl_reg_adc_chn1_filter_ctl::
           type_id::create("adc_chn1_filter_ctl_5"));
      adc_chn1_filter_ctl[5].configure(.blk_parent(this));
      adc_chn1_filter_ctl[5].build(csr_excl);
      default_map.add_reg(.rg(adc_chn1_filter_ctl[5]),
                          .offset(32'h58));
      adc_chn1_filter_ctl[5].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_5_min_v_5.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[5].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_5_cond_5.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[5].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_5_max_v_5.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[5].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_5_en_5.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn1_filter_ctl[6] =
          (adc_ctrl_reg_adc_chn1_filter_ctl::
           type_id::create("adc_chn1_filter_ctl_6"));
      adc_chn1_filter_ctl[6].configure(.blk_parent(this));
      adc_chn1_filter_ctl[6].build(csr_excl);
      default_map.add_reg(.rg(adc_chn1_filter_ctl[6]),
                          .offset(32'h5c));
      adc_chn1_filter_ctl[6].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_6_min_v_6.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[6].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_6_cond_6.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[6].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_6_max_v_6.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[6].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_6_en_6.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn1_filter_ctl[7] =
          (adc_ctrl_reg_adc_chn1_filter_ctl::
           type_id::create("adc_chn1_filter_ctl_7"));
      adc_chn1_filter_ctl[7].configure(.blk_parent(this));
      adc_chn1_filter_ctl[7].build(csr_excl);
      default_map.add_reg(.rg(adc_chn1_filter_ctl[7]),
                          .offset(32'h60));
      adc_chn1_filter_ctl[7].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_7_min_v_7.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[7].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_7_cond_7.q",
          12, 1, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[7].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_7_max_v_7.q",
          18, 10, 0, "BkdrRegPathRtl");
      adc_chn1_filter_ctl[7].add_hdl_path_slice(
          "u_reg.u_adc_chn1_filter_ctl_7_en_7.q",
          31, 1, 0, "BkdrRegPathRtl");

      adc_chn_val[0] =
          (adc_ctrl_reg_adc_chn_val::
           type_id::create("adc_chn_val_0"));
      adc_chn_val[0].configure(.blk_parent(this));
      adc_chn_val[0].build(csr_excl);
      default_map.add_reg(.rg(adc_chn_val[0]),
                          .offset(32'h64));
      adc_chn_val[0].add_hdl_path_slice(
          "u_reg.u_adc_chn_val_0_adc_chn_value_ext_0.q",
          0, 2, 0, "BkdrRegPathRtl");
      adc_chn_val[0].add_hdl_path_slice(
          "u_reg.u_adc_chn_val_0_adc_chn_value_0.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn_val[0].add_hdl_path_slice(
          "u_reg.u_adc_chn_val_0_adc_chn_value_intr_ext_0.q",
          16, 2, 0, "BkdrRegPathRtl");
      adc_chn_val[0].add_hdl_path_slice(
          "u_reg.u_adc_chn_val_0_adc_chn_value_intr_0.q",
          18, 10, 0, "BkdrRegPathRtl");

      adc_chn_val[1] =
          (adc_ctrl_reg_adc_chn_val::
           type_id::create("adc_chn_val_1"));
      adc_chn_val[1].configure(.blk_parent(this));
      adc_chn_val[1].build(csr_excl);
      default_map.add_reg(.rg(adc_chn_val[1]),
                          .offset(32'h68));
      adc_chn_val[1].add_hdl_path_slice(
          "u_reg.u_adc_chn_val_1_adc_chn_value_ext_1.q",
          0, 2, 0, "BkdrRegPathRtl");
      adc_chn_val[1].add_hdl_path_slice(
          "u_reg.u_adc_chn_val_1_adc_chn_value_1.q",
          2, 10, 0, "BkdrRegPathRtl");
      adc_chn_val[1].add_hdl_path_slice(
          "u_reg.u_adc_chn_val_1_adc_chn_value_intr_ext_1.q",
          16, 2, 0, "BkdrRegPathRtl");
      adc_chn_val[1].add_hdl_path_slice(
          "u_reg.u_adc_chn_val_1_adc_chn_value_intr_1.q",
          18, 10, 0, "BkdrRegPathRtl");

      adc_wakeup_ctl =
          (adc_ctrl_reg_adc_wakeup_ctl::
           type_id::create("adc_wakeup_ctl"));
      adc_wakeup_ctl.configure(.blk_parent(this));
      adc_wakeup_ctl.build(csr_excl);
      default_map.add_reg(.rg(adc_wakeup_ctl),
                          .offset(32'h6c));
      adc_wakeup_ctl.add_hdl_path_slice(
          "u_reg.u_adc_wakeup_ctl_match_en.q",
          0, 8, 0, "BkdrRegPathRtl");
      adc_wakeup_ctl.add_hdl_path_slice(
          "u_reg.u_adc_wakeup_ctl_trans_en.q",
          8, 1, 0, "BkdrRegPathRtl");

      filter_status =
          (adc_ctrl_reg_filter_status::
           type_id::create("filter_status"));
      filter_status.configure(.blk_parent(this));
      filter_status.build(csr_excl);
      default_map.add_reg(.rg(filter_status),
                          .offset(32'h70));
      filter_status.add_hdl_path_slice(
          "u_reg.u_filter_status_match.q",
          0, 8, 0, "BkdrRegPathRtl");
      filter_status.add_hdl_path_slice(
          "u_reg.u_filter_status_trans.q",
          8, 1, 0, "BkdrRegPathRtl");

      adc_intr_ctl =
          (adc_ctrl_reg_adc_intr_ctl::
           type_id::create("adc_intr_ctl"));
      adc_intr_ctl.configure(.blk_parent(this));
      adc_intr_ctl.build(csr_excl);
      default_map.add_reg(.rg(adc_intr_ctl),
                          .offset(32'h74));
      adc_intr_ctl.add_hdl_path_slice(
          "u_reg.u_adc_intr_ctl_match_en.q",
          0, 8, 0, "BkdrRegPathRtl");
      adc_intr_ctl.add_hdl_path_slice(
          "u_reg.u_adc_intr_ctl_trans_en.q",
          8, 1, 0, "BkdrRegPathRtl");
      adc_intr_ctl.add_hdl_path_slice(
          "u_reg.u_adc_intr_ctl_oneshot_en.q",
          9, 1, 0, "BkdrRegPathRtl");

      adc_intr_status =
          (adc_ctrl_reg_adc_intr_status::
           type_id::create("adc_intr_status"));
      adc_intr_status.configure(.blk_parent(this));
      adc_intr_status.build(csr_excl);
      default_map.add_reg(.rg(adc_intr_status),
                          .offset(32'h78));
      adc_intr_status.add_hdl_path_slice(
          "u_reg.u_adc_intr_status_match.q",
          0, 8, 0, "BkdrRegPathRtl");
      adc_intr_status.add_hdl_path_slice(
          "u_reg.u_adc_intr_status_trans.q",
          8, 1, 0, "BkdrRegPathRtl");
      adc_intr_status.add_hdl_path_slice(
          "u_reg.u_adc_intr_status_oneshot.q",
          9, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(adc_intr_status.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      adc_fsm_state =
          (adc_ctrl_reg_adc_fsm_state::
           type_id::create("adc_fsm_state"));
      adc_fsm_state.configure(.blk_parent(this));
      adc_fsm_state.build(csr_excl);
      default_map.add_reg(.rg(adc_fsm_state),
                          .offset(32'h7c));
      adc_fsm_state.add_hdl_path_slice(
          "u_reg.u_adc_fsm_state.qs",
          0, 5, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(adc_fsm_state.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : adc_ctrl_reg_block

endpackage

