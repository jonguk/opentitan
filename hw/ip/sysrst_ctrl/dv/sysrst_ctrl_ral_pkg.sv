// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package sysrst_ctrl_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class sysrst_ctrl_reg_intr_state;
  typedef class sysrst_ctrl_reg_intr_enable;
  typedef class sysrst_ctrl_reg_intr_test;
  typedef class sysrst_ctrl_reg_alert_test;
  typedef class sysrst_ctrl_reg_regwen;
  typedef class sysrst_ctrl_reg_ec_rst_ctl;
  typedef class sysrst_ctrl_reg_ulp_ac_debounce_ctl;
  typedef class sysrst_ctrl_reg_ulp_lid_debounce_ctl;
  typedef class sysrst_ctrl_reg_ulp_pwrb_debounce_ctl;
  typedef class sysrst_ctrl_reg_ulp_ctl;
  typedef class sysrst_ctrl_reg_ulp_status;
  typedef class sysrst_ctrl_reg_wkup_status;
  typedef class sysrst_ctrl_reg_key_invert_ctl;
  typedef class sysrst_ctrl_reg_pin_allowed_ctl;
  typedef class sysrst_ctrl_reg_pin_out_ctl;
  typedef class sysrst_ctrl_reg_pin_out_value;
  typedef class sysrst_ctrl_reg_pin_in_value;
  typedef class sysrst_ctrl_reg_key_intr_ctl;
  typedef class sysrst_ctrl_reg_key_intr_debounce_ctl;
  typedef class sysrst_ctrl_reg_auto_block_debounce_ctl;
  typedef class sysrst_ctrl_reg_auto_block_out_ctl;
  typedef class sysrst_ctrl_reg_com_pre_sel_ctl;
  typedef class sysrst_ctrl_reg_com_pre_det_ctl;
  typedef class sysrst_ctrl_reg_com_sel_ctl;
  typedef class sysrst_ctrl_reg_com_det_ctl;
  typedef class sysrst_ctrl_reg_com_out_ctl;
  typedef class sysrst_ctrl_reg_combo_intr_status;
  typedef class sysrst_ctrl_reg_key_intr_status;
  typedef class sysrst_ctrl_reg_block;

  class sysrst_ctrl_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field event_detected;

    `uvm_object_utils(sysrst_ctrl_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      event_detected =
          (dv_base_reg_field::
           type_id::create("event_detected"));
      event_detected.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      event_detected.set_original_access("RO");
    endfunction : build
  endclass : sysrst_ctrl_reg_intr_state

  class sysrst_ctrl_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field event_detected;

    `uvm_object_utils(sysrst_ctrl_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      event_detected =
          (dv_base_reg_field::
           type_id::create("event_detected"));
      event_detected.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      event_detected.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_intr_enable

  class sysrst_ctrl_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field event_detected;

    `uvm_object_utils(sysrst_ctrl_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      event_detected =
          (dv_base_reg_field::
           type_id::create("event_detected"));
      event_detected.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      event_detected.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : sysrst_ctrl_reg_intr_test

  class sysrst_ctrl_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(sysrst_ctrl_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : sysrst_ctrl_reg_alert_test

  class sysrst_ctrl_reg_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field write_en;

    `uvm_object_utils(sysrst_ctrl_reg_regwen)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      write_en =
          (dv_base_reg_field::
           type_id::create("write_en"));
      write_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      write_en.set_original_access("W0C");
    endfunction : build
  endclass : sysrst_ctrl_reg_regwen

  class sysrst_ctrl_reg_ec_rst_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field ec_rst_pulse;

    `uvm_object_utils(sysrst_ctrl_reg_ec_rst_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ec_rst_pulse =
          (dv_base_reg_field::
           type_id::create("ec_rst_pulse"));
      ec_rst_pulse.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7d0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_pulse.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_ec_rst_ctl

  class sysrst_ctrl_reg_ulp_ac_debounce_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field ulp_ac_debounce_timer;

    `uvm_object_utils(sysrst_ctrl_reg_ulp_ac_debounce_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ulp_ac_debounce_timer =
          (dv_base_reg_field::
           type_id::create("ulp_ac_debounce_timer"));
      ulp_ac_debounce_timer.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1f40),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ulp_ac_debounce_timer.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_ulp_ac_debounce_ctl

  class sysrst_ctrl_reg_ulp_lid_debounce_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field ulp_lid_debounce_timer;

    `uvm_object_utils(sysrst_ctrl_reg_ulp_lid_debounce_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ulp_lid_debounce_timer =
          (dv_base_reg_field::
           type_id::create("ulp_lid_debounce_timer"));
      ulp_lid_debounce_timer.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1f40),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ulp_lid_debounce_timer.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_ulp_lid_debounce_ctl

  class sysrst_ctrl_reg_ulp_pwrb_debounce_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field ulp_pwrb_debounce_timer;

    `uvm_object_utils(sysrst_ctrl_reg_ulp_pwrb_debounce_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ulp_pwrb_debounce_timer =
          (dv_base_reg_field::
           type_id::create("ulp_pwrb_debounce_timer"));
      ulp_pwrb_debounce_timer.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1f40),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ulp_pwrb_debounce_timer.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_ulp_pwrb_debounce_ctl

  class sysrst_ctrl_reg_ulp_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field ulp_enable;

    `uvm_object_utils(sysrst_ctrl_reg_ulp_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ulp_enable =
          (dv_base_reg_field::
           type_id::create("ulp_enable"));
      ulp_enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ulp_enable.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_ulp_ctl

  class sysrst_ctrl_reg_ulp_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field ulp_wakeup;

    `uvm_object_utils(sysrst_ctrl_reg_ulp_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ulp_wakeup =
          (dv_base_reg_field::
           type_id::create("ulp_wakeup"));
      ulp_wakeup.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ulp_wakeup.set_original_access("W1C");
    endfunction : build
  endclass : sysrst_ctrl_reg_ulp_status

  class sysrst_ctrl_reg_wkup_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field wakeup_sts;

    `uvm_object_utils(sysrst_ctrl_reg_wkup_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      wakeup_sts =
          (dv_base_reg_field::
           type_id::create("wakeup_sts"));
      wakeup_sts.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wakeup_sts.set_original_access("W1C");
    endfunction : build
  endclass : sysrst_ctrl_reg_wkup_status

  class sysrst_ctrl_reg_key_invert_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field key0_in;
    rand dv_base_reg_field key0_out;
    rand dv_base_reg_field key1_in;
    rand dv_base_reg_field key1_out;
    rand dv_base_reg_field key2_in;
    rand dv_base_reg_field key2_out;
    rand dv_base_reg_field pwrb_in;
    rand dv_base_reg_field pwrb_out;
    rand dv_base_reg_field ac_present;
    rand dv_base_reg_field bat_disable;
    rand dv_base_reg_field lid_open;
    rand dv_base_reg_field z3_wakeup;

    `uvm_object_utils(sysrst_ctrl_reg_key_invert_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key0_in =
          (dv_base_reg_field::
           type_id::create("key0_in"));
      key0_in.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_in.set_original_access("RW");
      key0_out =
          (dv_base_reg_field::
           type_id::create("key0_out"));
      key0_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_out.set_original_access("RW");
      key1_in =
          (dv_base_reg_field::
           type_id::create("key1_in"));
      key1_in.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_in.set_original_access("RW");
      key1_out =
          (dv_base_reg_field::
           type_id::create("key1_out"));
      key1_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_out.set_original_access("RW");
      key2_in =
          (dv_base_reg_field::
           type_id::create("key2_in"));
      key2_in.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_in.set_original_access("RW");
      key2_out =
          (dv_base_reg_field::
           type_id::create("key2_out"));
      key2_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_out.set_original_access("RW");
      pwrb_in =
          (dv_base_reg_field::
           type_id::create("pwrb_in"));
      pwrb_in.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_in.set_original_access("RW");
      pwrb_out =
          (dv_base_reg_field::
           type_id::create("pwrb_out"));
      pwrb_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_out.set_original_access("RW");
      ac_present =
          (dv_base_reg_field::
           type_id::create("ac_present"));
      ac_present.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ac_present.set_original_access("RW");
      bat_disable =
          (dv_base_reg_field::
           type_id::create("bat_disable"));
      bat_disable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bat_disable.set_original_access("RW");
      lid_open =
          (dv_base_reg_field::
           type_id::create("lid_open"));
      lid_open.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      lid_open.set_original_access("RW");
      z3_wakeup =
          (dv_base_reg_field::
           type_id::create("z3_wakeup"));
      z3_wakeup.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      z3_wakeup.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_key_invert_ctl

  class sysrst_ctrl_reg_pin_allowed_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field bat_disable_0;
    rand dv_base_reg_field ec_rst_l_0;
    rand dv_base_reg_field pwrb_out_0;
    rand dv_base_reg_field key0_out_0;
    rand dv_base_reg_field key1_out_0;
    rand dv_base_reg_field key2_out_0;
    rand dv_base_reg_field z3_wakeup_0;
    rand dv_base_reg_field flash_wp_l_0;
    rand dv_base_reg_field bat_disable_1;
    rand dv_base_reg_field ec_rst_l_1;
    rand dv_base_reg_field pwrb_out_1;
    rand dv_base_reg_field key0_out_1;
    rand dv_base_reg_field key1_out_1;
    rand dv_base_reg_field key2_out_1;
    rand dv_base_reg_field z3_wakeup_1;
    rand dv_base_reg_field flash_wp_l_1;

    `uvm_object_utils(sysrst_ctrl_reg_pin_allowed_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      bat_disable_0 =
          (dv_base_reg_field::
           type_id::create("bat_disable_0"));
      bat_disable_0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bat_disable_0.set_original_access("RW");
      ec_rst_l_0 =
          (dv_base_reg_field::
           type_id::create("ec_rst_l_0"));
      ec_rst_l_0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l_0.set_original_access("RW");
      pwrb_out_0 =
          (dv_base_reg_field::
           type_id::create("pwrb_out_0"));
      pwrb_out_0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_out_0.set_original_access("RW");
      key0_out_0 =
          (dv_base_reg_field::
           type_id::create("key0_out_0"));
      key0_out_0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_out_0.set_original_access("RW");
      key1_out_0 =
          (dv_base_reg_field::
           type_id::create("key1_out_0"));
      key1_out_0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_out_0.set_original_access("RW");
      key2_out_0 =
          (dv_base_reg_field::
           type_id::create("key2_out_0"));
      key2_out_0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_out_0.set_original_access("RW");
      z3_wakeup_0 =
          (dv_base_reg_field::
           type_id::create("z3_wakeup_0"));
      z3_wakeup_0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      z3_wakeup_0.set_original_access("RW");
      flash_wp_l_0 =
          (dv_base_reg_field::
           type_id::create("flash_wp_l_0"));
      flash_wp_l_0.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l_0.set_original_access("RW");
      bat_disable_1 =
          (dv_base_reg_field::
           type_id::create("bat_disable_1"));
      bat_disable_1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bat_disable_1.set_original_access("RW");
      ec_rst_l_1 =
          (dv_base_reg_field::
           type_id::create("ec_rst_l_1"));
      ec_rst_l_1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l_1.set_original_access("RW");
      pwrb_out_1 =
          (dv_base_reg_field::
           type_id::create("pwrb_out_1"));
      pwrb_out_1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_out_1.set_original_access("RW");
      key0_out_1 =
          (dv_base_reg_field::
           type_id::create("key0_out_1"));
      key0_out_1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_out_1.set_original_access("RW");
      key1_out_1 =
          (dv_base_reg_field::
           type_id::create("key1_out_1"));
      key1_out_1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_out_1.set_original_access("RW");
      key2_out_1 =
          (dv_base_reg_field::
           type_id::create("key2_out_1"));
      key2_out_1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_out_1.set_original_access("RW");
      z3_wakeup_1 =
          (dv_base_reg_field::
           type_id::create("z3_wakeup_1"));
      z3_wakeup_1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      z3_wakeup_1.set_original_access("RW");
      flash_wp_l_1 =
          (dv_base_reg_field::
           type_id::create("flash_wp_l_1"));
      flash_wp_l_1.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l_1.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_pin_allowed_ctl

  class sysrst_ctrl_reg_pin_out_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field bat_disable;
    rand dv_base_reg_field ec_rst_l;
    rand dv_base_reg_field pwrb_out;
    rand dv_base_reg_field key0_out;
    rand dv_base_reg_field key1_out;
    rand dv_base_reg_field key2_out;
    rand dv_base_reg_field z3_wakeup;
    rand dv_base_reg_field flash_wp_l;

    `uvm_object_utils(sysrst_ctrl_reg_pin_out_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      bat_disable =
          (dv_base_reg_field::
           type_id::create("bat_disable"));
      bat_disable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bat_disable.set_original_access("RW");
      ec_rst_l =
          (dv_base_reg_field::
           type_id::create("ec_rst_l"));
      ec_rst_l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l.set_original_access("RW");
      pwrb_out =
          (dv_base_reg_field::
           type_id::create("pwrb_out"));
      pwrb_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_out.set_original_access("RW");
      key0_out =
          (dv_base_reg_field::
           type_id::create("key0_out"));
      key0_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_out.set_original_access("RW");
      key1_out =
          (dv_base_reg_field::
           type_id::create("key1_out"));
      key1_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_out.set_original_access("RW");
      key2_out =
          (dv_base_reg_field::
           type_id::create("key2_out"));
      key2_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_out.set_original_access("RW");
      z3_wakeup =
          (dv_base_reg_field::
           type_id::create("z3_wakeup"));
      z3_wakeup.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      z3_wakeup.set_original_access("RW");
      flash_wp_l =
          (dv_base_reg_field::
           type_id::create("flash_wp_l"));
      flash_wp_l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_pin_out_ctl

  class sysrst_ctrl_reg_pin_out_value extends dv_base_reg;
    // fields
    rand dv_base_reg_field bat_disable;
    rand dv_base_reg_field ec_rst_l;
    rand dv_base_reg_field pwrb_out;
    rand dv_base_reg_field key0_out;
    rand dv_base_reg_field key1_out;
    rand dv_base_reg_field key2_out;
    rand dv_base_reg_field z3_wakeup;
    rand dv_base_reg_field flash_wp_l;

    `uvm_object_utils(sysrst_ctrl_reg_pin_out_value)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      bat_disable =
          (dv_base_reg_field::
           type_id::create("bat_disable"));
      bat_disable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bat_disable.set_original_access("RW");
      ec_rst_l =
          (dv_base_reg_field::
           type_id::create("ec_rst_l"));
      ec_rst_l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l.set_original_access("RW");
      pwrb_out =
          (dv_base_reg_field::
           type_id::create("pwrb_out"));
      pwrb_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_out.set_original_access("RW");
      key0_out =
          (dv_base_reg_field::
           type_id::create("key0_out"));
      key0_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_out.set_original_access("RW");
      key1_out =
          (dv_base_reg_field::
           type_id::create("key1_out"));
      key1_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_out.set_original_access("RW");
      key2_out =
          (dv_base_reg_field::
           type_id::create("key2_out"));
      key2_out.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_out.set_original_access("RW");
      z3_wakeup =
          (dv_base_reg_field::
           type_id::create("z3_wakeup"));
      z3_wakeup.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      z3_wakeup.set_original_access("RW");
      flash_wp_l =
          (dv_base_reg_field::
           type_id::create("flash_wp_l"));
      flash_wp_l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_pin_out_value

  class sysrst_ctrl_reg_pin_in_value extends dv_base_reg;
    // fields
    rand dv_base_reg_field pwrb_in;
    rand dv_base_reg_field key0_in;
    rand dv_base_reg_field key1_in;
    rand dv_base_reg_field key2_in;
    rand dv_base_reg_field lid_open;
    rand dv_base_reg_field ac_present;
    rand dv_base_reg_field ec_rst_l;
    rand dv_base_reg_field flash_wp_l;

    `uvm_object_utils(sysrst_ctrl_reg_pin_in_value)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      pwrb_in =
          (dv_base_reg_field::
           type_id::create("pwrb_in"));
      pwrb_in.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_in.set_original_access("RO");
      key0_in =
          (dv_base_reg_field::
           type_id::create("key0_in"));
      key0_in.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_in.set_original_access("RO");
      key1_in =
          (dv_base_reg_field::
           type_id::create("key1_in"));
      key1_in.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_in.set_original_access("RO");
      key2_in =
          (dv_base_reg_field::
           type_id::create("key2_in"));
      key2_in.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_in.set_original_access("RO");
      lid_open =
          (dv_base_reg_field::
           type_id::create("lid_open"));
      lid_open.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      lid_open.set_original_access("RO");
      ac_present =
          (dv_base_reg_field::
           type_id::create("ac_present"));
      ac_present.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ac_present.set_original_access("RO");
      ec_rst_l =
          (dv_base_reg_field::
           type_id::create("ec_rst_l"));
      ec_rst_l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l.set_original_access("RO");
      flash_wp_l =
          (dv_base_reg_field::
           type_id::create("flash_wp_l"));
      flash_wp_l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l.set_original_access("RO");
    endfunction : build
  endclass : sysrst_ctrl_reg_pin_in_value

  class sysrst_ctrl_reg_key_intr_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field pwrb_in_h2l;
    rand dv_base_reg_field key0_in_h2l;
    rand dv_base_reg_field key1_in_h2l;
    rand dv_base_reg_field key2_in_h2l;
    rand dv_base_reg_field ac_present_h2l;
    rand dv_base_reg_field ec_rst_l_h2l;
    rand dv_base_reg_field flash_wp_l_h2l;
    rand dv_base_reg_field pwrb_in_l2h;
    rand dv_base_reg_field key0_in_l2h;
    rand dv_base_reg_field key1_in_l2h;
    rand dv_base_reg_field key2_in_l2h;
    rand dv_base_reg_field ac_present_l2h;
    rand dv_base_reg_field ec_rst_l_l2h;
    rand dv_base_reg_field flash_wp_l_l2h;

    `uvm_object_utils(sysrst_ctrl_reg_key_intr_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      pwrb_in_h2l =
          (dv_base_reg_field::
           type_id::create("pwrb_in_h2l"));
      pwrb_in_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_in_h2l.set_original_access("RW");
      key0_in_h2l =
          (dv_base_reg_field::
           type_id::create("key0_in_h2l"));
      key0_in_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_in_h2l.set_original_access("RW");
      key1_in_h2l =
          (dv_base_reg_field::
           type_id::create("key1_in_h2l"));
      key1_in_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_in_h2l.set_original_access("RW");
      key2_in_h2l =
          (dv_base_reg_field::
           type_id::create("key2_in_h2l"));
      key2_in_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_in_h2l.set_original_access("RW");
      ac_present_h2l =
          (dv_base_reg_field::
           type_id::create("ac_present_h2l"));
      ac_present_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ac_present_h2l.set_original_access("RW");
      ec_rst_l_h2l =
          (dv_base_reg_field::
           type_id::create("ec_rst_l_h2l"));
      ec_rst_l_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l_h2l.set_original_access("RW");
      flash_wp_l_h2l =
          (dv_base_reg_field::
           type_id::create("flash_wp_l_h2l"));
      flash_wp_l_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l_h2l.set_original_access("RW");
      pwrb_in_l2h =
          (dv_base_reg_field::
           type_id::create("pwrb_in_l2h"));
      pwrb_in_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_in_l2h.set_original_access("RW");
      key0_in_l2h =
          (dv_base_reg_field::
           type_id::create("key0_in_l2h"));
      key0_in_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_in_l2h.set_original_access("RW");
      key1_in_l2h =
          (dv_base_reg_field::
           type_id::create("key1_in_l2h"));
      key1_in_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_in_l2h.set_original_access("RW");
      key2_in_l2h =
          (dv_base_reg_field::
           type_id::create("key2_in_l2h"));
      key2_in_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_in_l2h.set_original_access("RW");
      ac_present_l2h =
          (dv_base_reg_field::
           type_id::create("ac_present_l2h"));
      ac_present_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ac_present_l2h.set_original_access("RW");
      ec_rst_l_l2h =
          (dv_base_reg_field::
           type_id::create("ec_rst_l_l2h"));
      ec_rst_l_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l_l2h.set_original_access("RW");
      flash_wp_l_l2h =
          (dv_base_reg_field::
           type_id::create("flash_wp_l_l2h"));
      flash_wp_l_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l_l2h.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_key_intr_ctl

  class sysrst_ctrl_reg_key_intr_debounce_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field debounce_timer;

    `uvm_object_utils(sysrst_ctrl_reg_key_intr_debounce_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      debounce_timer =
          (dv_base_reg_field::
           type_id::create("debounce_timer"));
      debounce_timer.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7d0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      debounce_timer.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_key_intr_debounce_ctl

  class sysrst_ctrl_reg_auto_block_debounce_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field debounce_timer;
    rand dv_base_reg_field auto_block_enable;

    `uvm_object_utils(sysrst_ctrl_reg_auto_block_debounce_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      debounce_timer =
          (dv_base_reg_field::
           type_id::create("debounce_timer"));
      debounce_timer.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h7d0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      debounce_timer.set_original_access("RW");
      auto_block_enable =
          (dv_base_reg_field::
           type_id::create("auto_block_enable"));
      auto_block_enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auto_block_enable.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_auto_block_debounce_ctl

  class sysrst_ctrl_reg_auto_block_out_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field key0_out_sel;
    rand dv_base_reg_field key1_out_sel;
    rand dv_base_reg_field key2_out_sel;
    rand dv_base_reg_field key0_out_value;
    rand dv_base_reg_field key1_out_value;
    rand dv_base_reg_field key2_out_value;

    `uvm_object_utils(sysrst_ctrl_reg_auto_block_out_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key0_out_sel =
          (dv_base_reg_field::
           type_id::create("key0_out_sel"));
      key0_out_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_out_sel.set_original_access("RW");
      key1_out_sel =
          (dv_base_reg_field::
           type_id::create("key1_out_sel"));
      key1_out_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_out_sel.set_original_access("RW");
      key2_out_sel =
          (dv_base_reg_field::
           type_id::create("key2_out_sel"));
      key2_out_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_out_sel.set_original_access("RW");
      key0_out_value =
          (dv_base_reg_field::
           type_id::create("key0_out_value"));
      key0_out_value.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_out_value.set_original_access("RW");
      key1_out_value =
          (dv_base_reg_field::
           type_id::create("key1_out_value"));
      key1_out_value.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_out_value.set_original_access("RW");
      key2_out_value =
          (dv_base_reg_field::
           type_id::create("key2_out_value"));
      key2_out_value.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_out_value.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_auto_block_out_ctl

  class sysrst_ctrl_reg_com_pre_sel_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field key0_in_sel;
    rand dv_base_reg_field key1_in_sel;
    rand dv_base_reg_field key2_in_sel;
    rand dv_base_reg_field pwrb_in_sel;
    rand dv_base_reg_field ac_present_sel;

    `uvm_object_utils(sysrst_ctrl_reg_com_pre_sel_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key0_in_sel =
          (dv_base_reg_field::
           type_id::create("key0_in_sel"));
      key0_in_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_in_sel.set_original_access("RW");
      key1_in_sel =
          (dv_base_reg_field::
           type_id::create("key1_in_sel"));
      key1_in_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_in_sel.set_original_access("RW");
      key2_in_sel =
          (dv_base_reg_field::
           type_id::create("key2_in_sel"));
      key2_in_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_in_sel.set_original_access("RW");
      pwrb_in_sel =
          (dv_base_reg_field::
           type_id::create("pwrb_in_sel"));
      pwrb_in_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_in_sel.set_original_access("RW");
      ac_present_sel =
          (dv_base_reg_field::
           type_id::create("ac_present_sel"));
      ac_present_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ac_present_sel.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_com_pre_sel_ctl

  class sysrst_ctrl_reg_com_pre_det_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field precondition_timer;

    `uvm_object_utils(sysrst_ctrl_reg_com_pre_det_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      precondition_timer =
          (dv_base_reg_field::
           type_id::create("precondition_timer_0"));
      precondition_timer.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      precondition_timer.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_com_pre_det_ctl

  class sysrst_ctrl_reg_com_sel_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field key0_in_sel;
    rand dv_base_reg_field key1_in_sel;
    rand dv_base_reg_field key2_in_sel;
    rand dv_base_reg_field pwrb_in_sel;
    rand dv_base_reg_field ac_present_sel;

    `uvm_object_utils(sysrst_ctrl_reg_com_sel_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key0_in_sel =
          (dv_base_reg_field::
           type_id::create("key0_in_sel"));
      key0_in_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_in_sel.set_original_access("RW");
      key1_in_sel =
          (dv_base_reg_field::
           type_id::create("key1_in_sel"));
      key1_in_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_in_sel.set_original_access("RW");
      key2_in_sel =
          (dv_base_reg_field::
           type_id::create("key2_in_sel"));
      key2_in_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_in_sel.set_original_access("RW");
      pwrb_in_sel =
          (dv_base_reg_field::
           type_id::create("pwrb_in_sel"));
      pwrb_in_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_in_sel.set_original_access("RW");
      ac_present_sel =
          (dv_base_reg_field::
           type_id::create("ac_present_sel"));
      ac_present_sel.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ac_present_sel.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_com_sel_ctl

  class sysrst_ctrl_reg_com_det_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field detection_timer;

    `uvm_object_utils(sysrst_ctrl_reg_com_det_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      detection_timer =
          (dv_base_reg_field::
           type_id::create("detection_timer_0"));
      detection_timer.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      detection_timer.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_com_det_ctl

  class sysrst_ctrl_reg_com_out_ctl extends dv_base_reg;
    // fields
    rand dv_base_reg_field bat_disable;
    rand dv_base_reg_field interrupt;
    rand dv_base_reg_field ec_rst;
    rand dv_base_reg_field rst_req;

    `uvm_object_utils(sysrst_ctrl_reg_com_out_ctl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      bat_disable =
          (dv_base_reg_field::
           type_id::create("bat_disable"));
      bat_disable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bat_disable.set_original_access("RW");
      interrupt =
          (dv_base_reg_field::
           type_id::create("interrupt"));
      interrupt.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      interrupt.set_original_access("RW");
      ec_rst =
          (dv_base_reg_field::
           type_id::create("ec_rst"));
      ec_rst.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst.set_original_access("RW");
      rst_req =
          (dv_base_reg_field::
           type_id::create("rst_req"));
      rst_req.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rst_req.set_original_access("RW");
    endfunction : build
  endclass : sysrst_ctrl_reg_com_out_ctl

  class sysrst_ctrl_reg_combo_intr_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field combo0_h2l;
    rand dv_base_reg_field combo1_h2l;
    rand dv_base_reg_field combo2_h2l;
    rand dv_base_reg_field combo3_h2l;

    `uvm_object_utils(sysrst_ctrl_reg_combo_intr_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      combo0_h2l =
          (dv_base_reg_field::
           type_id::create("combo0_h2l"));
      combo0_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      combo0_h2l.set_original_access("W1C");
      combo1_h2l =
          (dv_base_reg_field::
           type_id::create("combo1_h2l"));
      combo1_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      combo1_h2l.set_original_access("W1C");
      combo2_h2l =
          (dv_base_reg_field::
           type_id::create("combo2_h2l"));
      combo2_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      combo2_h2l.set_original_access("W1C");
      combo3_h2l =
          (dv_base_reg_field::
           type_id::create("combo3_h2l"));
      combo3_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      combo3_h2l.set_original_access("W1C");
    endfunction : build
  endclass : sysrst_ctrl_reg_combo_intr_status

  class sysrst_ctrl_reg_key_intr_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field pwrb_h2l;
    rand dv_base_reg_field key0_in_h2l;
    rand dv_base_reg_field key1_in_h2l;
    rand dv_base_reg_field key2_in_h2l;
    rand dv_base_reg_field ac_present_h2l;
    rand dv_base_reg_field ec_rst_l_h2l;
    rand dv_base_reg_field flash_wp_l_h2l;
    rand dv_base_reg_field pwrb_l2h;
    rand dv_base_reg_field key0_in_l2h;
    rand dv_base_reg_field key1_in_l2h;
    rand dv_base_reg_field key2_in_l2h;
    rand dv_base_reg_field ac_present_l2h;
    rand dv_base_reg_field ec_rst_l_l2h;
    rand dv_base_reg_field flash_wp_l_l2h;

    `uvm_object_utils(sysrst_ctrl_reg_key_intr_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      pwrb_h2l =
          (dv_base_reg_field::
           type_id::create("pwrb_h2l"));
      pwrb_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_h2l.set_original_access("W1C");
      key0_in_h2l =
          (dv_base_reg_field::
           type_id::create("key0_in_h2l"));
      key0_in_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_in_h2l.set_original_access("W1C");
      key1_in_h2l =
          (dv_base_reg_field::
           type_id::create("key1_in_h2l"));
      key1_in_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_in_h2l.set_original_access("W1C");
      key2_in_h2l =
          (dv_base_reg_field::
           type_id::create("key2_in_h2l"));
      key2_in_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_in_h2l.set_original_access("W1C");
      ac_present_h2l =
          (dv_base_reg_field::
           type_id::create("ac_present_h2l"));
      ac_present_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ac_present_h2l.set_original_access("W1C");
      ec_rst_l_h2l =
          (dv_base_reg_field::
           type_id::create("ec_rst_l_h2l"));
      ec_rst_l_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l_h2l.set_original_access("W1C");
      flash_wp_l_h2l =
          (dv_base_reg_field::
           type_id::create("flash_wp_l_h2l"));
      flash_wp_l_h2l.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l_h2l.set_original_access("W1C");
      pwrb_l2h =
          (dv_base_reg_field::
           type_id::create("pwrb_l2h"));
      pwrb_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pwrb_l2h.set_original_access("W1C");
      key0_in_l2h =
          (dv_base_reg_field::
           type_id::create("key0_in_l2h"));
      key0_in_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key0_in_l2h.set_original_access("W1C");
      key1_in_l2h =
          (dv_base_reg_field::
           type_id::create("key1_in_l2h"));
      key1_in_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key1_in_l2h.set_original_access("W1C");
      key2_in_l2h =
          (dv_base_reg_field::
           type_id::create("key2_in_l2h"));
      key2_in_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key2_in_l2h.set_original_access("W1C");
      ac_present_l2h =
          (dv_base_reg_field::
           type_id::create("ac_present_l2h"));
      ac_present_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ac_present_l2h.set_original_access("W1C");
      ec_rst_l_l2h =
          (dv_base_reg_field::
           type_id::create("ec_rst_l_l2h"));
      ec_rst_l_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ec_rst_l_l2h.set_original_access("W1C");
      flash_wp_l_l2h =
          (dv_base_reg_field::
           type_id::create("flash_wp_l_l2h"));
      flash_wp_l_l2h.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flash_wp_l_l2h.set_original_access("W1C");
    endfunction : build
  endclass : sysrst_ctrl_reg_key_intr_status

  class sysrst_ctrl_reg_block extends dv_base_reg_block;
    // registers
    rand sysrst_ctrl_reg_intr_state intr_state;
    rand sysrst_ctrl_reg_intr_enable intr_enable;
    rand sysrst_ctrl_reg_intr_test intr_test;
    rand sysrst_ctrl_reg_alert_test alert_test;
    rand sysrst_ctrl_reg_regwen regwen;
    rand sysrst_ctrl_reg_ec_rst_ctl ec_rst_ctl;
    rand sysrst_ctrl_reg_ulp_ac_debounce_ctl ulp_ac_debounce_ctl;
    rand sysrst_ctrl_reg_ulp_lid_debounce_ctl ulp_lid_debounce_ctl;
    rand sysrst_ctrl_reg_ulp_pwrb_debounce_ctl ulp_pwrb_debounce_ctl;
    rand sysrst_ctrl_reg_ulp_ctl ulp_ctl;
    rand sysrst_ctrl_reg_ulp_status ulp_status;
    rand sysrst_ctrl_reg_wkup_status wkup_status;
    rand sysrst_ctrl_reg_key_invert_ctl key_invert_ctl;
    rand sysrst_ctrl_reg_pin_allowed_ctl pin_allowed_ctl;
    rand sysrst_ctrl_reg_pin_out_ctl pin_out_ctl;
    rand sysrst_ctrl_reg_pin_out_value pin_out_value;
    rand sysrst_ctrl_reg_pin_in_value pin_in_value;
    rand sysrst_ctrl_reg_key_intr_ctl key_intr_ctl;
    rand sysrst_ctrl_reg_key_intr_debounce_ctl key_intr_debounce_ctl;
    rand sysrst_ctrl_reg_auto_block_debounce_ctl auto_block_debounce_ctl;
    rand sysrst_ctrl_reg_auto_block_out_ctl auto_block_out_ctl;
    rand sysrst_ctrl_reg_com_pre_sel_ctl com_pre_sel_ctl[4];
    rand sysrst_ctrl_reg_com_pre_det_ctl com_pre_det_ctl[4];
    rand sysrst_ctrl_reg_com_sel_ctl com_sel_ctl[4];
    rand sysrst_ctrl_reg_com_det_ctl com_det_ctl[4];
    rand sysrst_ctrl_reg_com_out_ctl com_out_ctl[4];
    rand sysrst_ctrl_reg_combo_intr_status combo_intr_status;
    rand sysrst_ctrl_reg_key_intr_status key_intr_status;

    `uvm_object_utils(sysrst_ctrl_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (sysrst_ctrl_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (sysrst_ctrl_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable.q",
          0, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (sysrst_ctrl_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (sysrst_ctrl_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      regwen =
          (sysrst_ctrl_reg_regwen::
           type_id::create("regwen"));
      regwen.configure(.blk_parent(this));
      regwen.build(csr_excl);
      default_map.add_reg(.rg(regwen),
                          .offset(32'h10));
      regwen.add_hdl_path_slice(
          "u_reg.u_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      ec_rst_ctl =
          (sysrst_ctrl_reg_ec_rst_ctl::
           type_id::create("ec_rst_ctl"));
      ec_rst_ctl.configure(.blk_parent(this));
      ec_rst_ctl.build(csr_excl);
      default_map.add_reg(.rg(ec_rst_ctl),
                          .offset(32'h14));
      ec_rst_ctl.add_hdl_path_slice(
          "u_reg.u_ec_rst_ctl.q",
          0, 16, 0, "BkdrRegPathRtl");

      ulp_ac_debounce_ctl =
          (sysrst_ctrl_reg_ulp_ac_debounce_ctl::
           type_id::create("ulp_ac_debounce_ctl"));
      ulp_ac_debounce_ctl.configure(.blk_parent(this));
      ulp_ac_debounce_ctl.build(csr_excl);
      default_map.add_reg(.rg(ulp_ac_debounce_ctl),
                          .offset(32'h18));
      ulp_ac_debounce_ctl.add_hdl_path_slice(
          "u_reg.u_ulp_ac_debounce_ctl.q",
          0, 16, 0, "BkdrRegPathRtl");

      ulp_lid_debounce_ctl =
          (sysrst_ctrl_reg_ulp_lid_debounce_ctl::
           type_id::create("ulp_lid_debounce_ctl"));
      ulp_lid_debounce_ctl.configure(.blk_parent(this));
      ulp_lid_debounce_ctl.build(csr_excl);
      default_map.add_reg(.rg(ulp_lid_debounce_ctl),
                          .offset(32'h1c));
      ulp_lid_debounce_ctl.add_hdl_path_slice(
          "u_reg.u_ulp_lid_debounce_ctl.q",
          0, 16, 0, "BkdrRegPathRtl");

      ulp_pwrb_debounce_ctl =
          (sysrst_ctrl_reg_ulp_pwrb_debounce_ctl::
           type_id::create("ulp_pwrb_debounce_ctl"));
      ulp_pwrb_debounce_ctl.configure(.blk_parent(this));
      ulp_pwrb_debounce_ctl.build(csr_excl);
      default_map.add_reg(.rg(ulp_pwrb_debounce_ctl),
                          .offset(32'h20));
      ulp_pwrb_debounce_ctl.add_hdl_path_slice(
          "u_reg.u_ulp_pwrb_debounce_ctl.q",
          0, 16, 0, "BkdrRegPathRtl");

      ulp_ctl =
          (sysrst_ctrl_reg_ulp_ctl::
           type_id::create("ulp_ctl"));
      ulp_ctl.configure(.blk_parent(this));
      ulp_ctl.build(csr_excl);
      default_map.add_reg(.rg(ulp_ctl),
                          .offset(32'h24));
      ulp_ctl.add_hdl_path_slice(
          "u_reg.u_ulp_ctl.q",
          0, 1, 0, "BkdrRegPathRtl");

      ulp_status =
          (sysrst_ctrl_reg_ulp_status::
           type_id::create("ulp_status"));
      ulp_status.configure(.blk_parent(this));
      ulp_status.build(csr_excl);
      default_map.add_reg(.rg(ulp_status),
                          .offset(32'h28));
      ulp_status.add_hdl_path_slice(
          "u_reg.u_ulp_status.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(ulp_status.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      wkup_status =
          (sysrst_ctrl_reg_wkup_status::
           type_id::create("wkup_status"));
      wkup_status.configure(.blk_parent(this));
      wkup_status.build(csr_excl);
      default_map.add_reg(.rg(wkup_status),
                          .offset(32'h2c));
      wkup_status.add_hdl_path_slice(
          "u_reg.u_wkup_status.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(wkup_status.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      key_invert_ctl =
          (sysrst_ctrl_reg_key_invert_ctl::
           type_id::create("key_invert_ctl"));
      key_invert_ctl.configure(.blk_parent(this));
      key_invert_ctl.build(csr_excl);
      default_map.add_reg(.rg(key_invert_ctl),
                          .offset(32'h30));
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_key0_in.q",
          0, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_key0_out.q",
          1, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_key1_in.q",
          2, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_key1_out.q",
          3, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_key2_in.q",
          4, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_key2_out.q",
          5, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_pwrb_in.q",
          6, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_pwrb_out.q",
          7, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_ac_present.q",
          8, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_bat_disable.q",
          9, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_lid_open.q",
          10, 1, 0, "BkdrRegPathRtl");
      key_invert_ctl.add_hdl_path_slice(
          "u_reg.u_key_invert_ctl_z3_wakeup.q",
          11, 1, 0, "BkdrRegPathRtl");

      pin_allowed_ctl =
          (sysrst_ctrl_reg_pin_allowed_ctl::
           type_id::create("pin_allowed_ctl"));
      pin_allowed_ctl.configure(.blk_parent(this));
      pin_allowed_ctl.build(csr_excl);
      default_map.add_reg(.rg(pin_allowed_ctl),
                          .offset(32'h34));
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_bat_disable_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_ec_rst_l_0.q",
          1, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_pwrb_out_0.q",
          2, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_key0_out_0.q",
          3, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_key1_out_0.q",
          4, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_key2_out_0.q",
          5, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_z3_wakeup_0.q",
          6, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_flash_wp_l_0.q",
          7, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_bat_disable_1.q",
          8, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_ec_rst_l_1.q",
          9, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_pwrb_out_1.q",
          10, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_key0_out_1.q",
          11, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_key1_out_1.q",
          12, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_key2_out_1.q",
          13, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_z3_wakeup_1.q",
          14, 1, 0, "BkdrRegPathRtl");
      pin_allowed_ctl.add_hdl_path_slice(
          "u_reg.u_pin_allowed_ctl_flash_wp_l_1.q",
          15, 1, 0, "BkdrRegPathRtl");

      pin_out_ctl =
          (sysrst_ctrl_reg_pin_out_ctl::
           type_id::create("pin_out_ctl"));
      pin_out_ctl.configure(.blk_parent(this));
      pin_out_ctl.build(csr_excl);
      default_map.add_reg(.rg(pin_out_ctl),
                          .offset(32'h38));
      pin_out_ctl.add_hdl_path_slice(
          "u_reg.u_pin_out_ctl_bat_disable.q",
          0, 1, 0, "BkdrRegPathRtl");
      pin_out_ctl.add_hdl_path_slice(
          "u_reg.u_pin_out_ctl_ec_rst_l.q",
          1, 1, 0, "BkdrRegPathRtl");
      pin_out_ctl.add_hdl_path_slice(
          "u_reg.u_pin_out_ctl_pwrb_out.q",
          2, 1, 0, "BkdrRegPathRtl");
      pin_out_ctl.add_hdl_path_slice(
          "u_reg.u_pin_out_ctl_key0_out.q",
          3, 1, 0, "BkdrRegPathRtl");
      pin_out_ctl.add_hdl_path_slice(
          "u_reg.u_pin_out_ctl_key1_out.q",
          4, 1, 0, "BkdrRegPathRtl");
      pin_out_ctl.add_hdl_path_slice(
          "u_reg.u_pin_out_ctl_key2_out.q",
          5, 1, 0, "BkdrRegPathRtl");
      pin_out_ctl.add_hdl_path_slice(
          "u_reg.u_pin_out_ctl_z3_wakeup.q",
          6, 1, 0, "BkdrRegPathRtl");
      pin_out_ctl.add_hdl_path_slice(
          "u_reg.u_pin_out_ctl_flash_wp_l.q",
          7, 1, 0, "BkdrRegPathRtl");

      pin_out_value =
          (sysrst_ctrl_reg_pin_out_value::
           type_id::create("pin_out_value"));
      pin_out_value.configure(.blk_parent(this));
      pin_out_value.build(csr_excl);
      default_map.add_reg(.rg(pin_out_value),
                          .offset(32'h3c));
      pin_out_value.add_hdl_path_slice(
          "u_reg.u_pin_out_value_bat_disable.q",
          0, 1, 0, "BkdrRegPathRtl");
      pin_out_value.add_hdl_path_slice(
          "u_reg.u_pin_out_value_ec_rst_l.q",
          1, 1, 0, "BkdrRegPathRtl");
      pin_out_value.add_hdl_path_slice(
          "u_reg.u_pin_out_value_pwrb_out.q",
          2, 1, 0, "BkdrRegPathRtl");
      pin_out_value.add_hdl_path_slice(
          "u_reg.u_pin_out_value_key0_out.q",
          3, 1, 0, "BkdrRegPathRtl");
      pin_out_value.add_hdl_path_slice(
          "u_reg.u_pin_out_value_key1_out.q",
          4, 1, 0, "BkdrRegPathRtl");
      pin_out_value.add_hdl_path_slice(
          "u_reg.u_pin_out_value_key2_out.q",
          5, 1, 0, "BkdrRegPathRtl");
      pin_out_value.add_hdl_path_slice(
          "u_reg.u_pin_out_value_z3_wakeup.q",
          6, 1, 0, "BkdrRegPathRtl");
      pin_out_value.add_hdl_path_slice(
          "u_reg.u_pin_out_value_flash_wp_l.q",
          7, 1, 0, "BkdrRegPathRtl");

      pin_in_value =
          (sysrst_ctrl_reg_pin_in_value::
           type_id::create("pin_in_value"));
      pin_in_value.configure(.blk_parent(this));
      pin_in_value.build(csr_excl);
      default_map.add_reg(.rg(pin_in_value),
                          .offset(32'h40));
      pin_in_value.add_hdl_path_slice(
          "u_reg.u_pin_in_value_pwrb_in.q",
          0, 1, 0, "BkdrRegPathRtl");
      pin_in_value.add_hdl_path_slice(
          "u_reg.u_pin_in_value_key0_in.q",
          1, 1, 0, "BkdrRegPathRtl");
      pin_in_value.add_hdl_path_slice(
          "u_reg.u_pin_in_value_key1_in.q",
          2, 1, 0, "BkdrRegPathRtl");
      pin_in_value.add_hdl_path_slice(
          "u_reg.u_pin_in_value_key2_in.q",
          3, 1, 0, "BkdrRegPathRtl");
      pin_in_value.add_hdl_path_slice(
          "u_reg.u_pin_in_value_lid_open.q",
          4, 1, 0, "BkdrRegPathRtl");
      pin_in_value.add_hdl_path_slice(
          "u_reg.u_pin_in_value_ac_present.q",
          5, 1, 0, "BkdrRegPathRtl");
      pin_in_value.add_hdl_path_slice(
          "u_reg.u_pin_in_value_ec_rst_l.q",
          6, 1, 0, "BkdrRegPathRtl");
      pin_in_value.add_hdl_path_slice(
          "u_reg.u_pin_in_value_flash_wp_l.q",
          7, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(pin_in_value.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      key_intr_ctl =
          (sysrst_ctrl_reg_key_intr_ctl::
           type_id::create("key_intr_ctl"));
      key_intr_ctl.configure(.blk_parent(this));
      key_intr_ctl.build(csr_excl);
      default_map.add_reg(.rg(key_intr_ctl),
                          .offset(32'h44));
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_pwrb_in_h2l.q",
          0, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_key0_in_h2l.q",
          1, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_key1_in_h2l.q",
          2, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_key2_in_h2l.q",
          3, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_ac_present_h2l.q",
          4, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_ec_rst_l_h2l.q",
          5, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_flash_wp_l_h2l.q",
          6, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_pwrb_in_l2h.q",
          7, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_key0_in_l2h.q",
          8, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_key1_in_l2h.q",
          9, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_key2_in_l2h.q",
          10, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_ac_present_l2h.q",
          11, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_ec_rst_l_l2h.q",
          12, 1, 0, "BkdrRegPathRtl");
      key_intr_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_ctl_flash_wp_l_l2h.q",
          13, 1, 0, "BkdrRegPathRtl");

      key_intr_debounce_ctl =
          (sysrst_ctrl_reg_key_intr_debounce_ctl::
           type_id::create("key_intr_debounce_ctl"));
      key_intr_debounce_ctl.configure(.blk_parent(this));
      key_intr_debounce_ctl.build(csr_excl);
      default_map.add_reg(.rg(key_intr_debounce_ctl),
                          .offset(32'h48));
      key_intr_debounce_ctl.add_hdl_path_slice(
          "u_reg.u_key_intr_debounce_ctl.q",
          0, 16, 0, "BkdrRegPathRtl");

      auto_block_debounce_ctl =
          (sysrst_ctrl_reg_auto_block_debounce_ctl::
           type_id::create("auto_block_debounce_ctl"));
      auto_block_debounce_ctl.configure(.blk_parent(this));
      auto_block_debounce_ctl.build(csr_excl);
      default_map.add_reg(.rg(auto_block_debounce_ctl),
                          .offset(32'h4c));
      auto_block_debounce_ctl.add_hdl_path_slice(
          "u_reg.u_auto_block_debounce_ctl_debounce_timer.q",
          0, 16, 0, "BkdrRegPathRtl");
      auto_block_debounce_ctl.add_hdl_path_slice(
          "u_reg.u_auto_block_debounce_ctl_auto_block_enable.q",
          16, 1, 0, "BkdrRegPathRtl");

      auto_block_out_ctl =
          (sysrst_ctrl_reg_auto_block_out_ctl::
           type_id::create("auto_block_out_ctl"));
      auto_block_out_ctl.configure(.blk_parent(this));
      auto_block_out_ctl.build(csr_excl);
      default_map.add_reg(.rg(auto_block_out_ctl),
                          .offset(32'h50));
      auto_block_out_ctl.add_hdl_path_slice(
          "u_reg.u_auto_block_out_ctl_key0_out_sel.q",
          0, 1, 0, "BkdrRegPathRtl");
      auto_block_out_ctl.add_hdl_path_slice(
          "u_reg.u_auto_block_out_ctl_key1_out_sel.q",
          1, 1, 0, "BkdrRegPathRtl");
      auto_block_out_ctl.add_hdl_path_slice(
          "u_reg.u_auto_block_out_ctl_key2_out_sel.q",
          2, 1, 0, "BkdrRegPathRtl");
      auto_block_out_ctl.add_hdl_path_slice(
          "u_reg.u_auto_block_out_ctl_key0_out_value.q",
          4, 1, 0, "BkdrRegPathRtl");
      auto_block_out_ctl.add_hdl_path_slice(
          "u_reg.u_auto_block_out_ctl_key1_out_value.q",
          5, 1, 0, "BkdrRegPathRtl");
      auto_block_out_ctl.add_hdl_path_slice(
          "u_reg.u_auto_block_out_ctl_key2_out_value.q",
          6, 1, 0, "BkdrRegPathRtl");

      com_pre_sel_ctl[0] =
          (sysrst_ctrl_reg_com_pre_sel_ctl::
           type_id::create("com_pre_sel_ctl_0"));
      com_pre_sel_ctl[0].configure(.blk_parent(this));
      com_pre_sel_ctl[0].build(csr_excl);
      default_map.add_reg(.rg(com_pre_sel_ctl[0]),
                          .offset(32'h54));
      com_pre_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_0_key0_in_sel_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_0_key1_in_sel_0.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_0_key2_in_sel_0.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_0_pwrb_in_sel_0.q",
          3, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_0_ac_present_sel_0.q",
          4, 1, 0, "BkdrRegPathRtl");

      com_pre_sel_ctl[1] =
          (sysrst_ctrl_reg_com_pre_sel_ctl::
           type_id::create("com_pre_sel_ctl_1"));
      com_pre_sel_ctl[1].configure(.blk_parent(this));
      com_pre_sel_ctl[1].build(csr_excl);
      default_map.add_reg(.rg(com_pre_sel_ctl[1]),
                          .offset(32'h58));
      com_pre_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_1_key0_in_sel_1.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_1_key1_in_sel_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_1_key2_in_sel_1.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_1_pwrb_in_sel_1.q",
          3, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_1_ac_present_sel_1.q",
          4, 1, 0, "BkdrRegPathRtl");

      com_pre_sel_ctl[2] =
          (sysrst_ctrl_reg_com_pre_sel_ctl::
           type_id::create("com_pre_sel_ctl_2"));
      com_pre_sel_ctl[2].configure(.blk_parent(this));
      com_pre_sel_ctl[2].build(csr_excl);
      default_map.add_reg(.rg(com_pre_sel_ctl[2]),
                          .offset(32'h5c));
      com_pre_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_2_key0_in_sel_2.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_2_key1_in_sel_2.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_2_key2_in_sel_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_2_pwrb_in_sel_2.q",
          3, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_2_ac_present_sel_2.q",
          4, 1, 0, "BkdrRegPathRtl");

      com_pre_sel_ctl[3] =
          (sysrst_ctrl_reg_com_pre_sel_ctl::
           type_id::create("com_pre_sel_ctl_3"));
      com_pre_sel_ctl[3].configure(.blk_parent(this));
      com_pre_sel_ctl[3].build(csr_excl);
      default_map.add_reg(.rg(com_pre_sel_ctl[3]),
                          .offset(32'h60));
      com_pre_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_3_key0_in_sel_3.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_3_key1_in_sel_3.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_3_key2_in_sel_3.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_3_pwrb_in_sel_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      com_pre_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_pre_sel_ctl_3_ac_present_sel_3.q",
          4, 1, 0, "BkdrRegPathRtl");

      com_pre_det_ctl[0] =
          (sysrst_ctrl_reg_com_pre_det_ctl::
           type_id::create("com_pre_det_ctl_0"));
      com_pre_det_ctl[0].configure(.blk_parent(this));
      com_pre_det_ctl[0].build(csr_excl);
      default_map.add_reg(.rg(com_pre_det_ctl[0]),
                          .offset(32'h64));
      com_pre_det_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_pre_det_ctl_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      com_pre_det_ctl[1] =
          (sysrst_ctrl_reg_com_pre_det_ctl::
           type_id::create("com_pre_det_ctl_1"));
      com_pre_det_ctl[1].configure(.blk_parent(this));
      com_pre_det_ctl[1].build(csr_excl);
      default_map.add_reg(.rg(com_pre_det_ctl[1]),
                          .offset(32'h68));
      com_pre_det_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_pre_det_ctl_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      com_pre_det_ctl[2] =
          (sysrst_ctrl_reg_com_pre_det_ctl::
           type_id::create("com_pre_det_ctl_2"));
      com_pre_det_ctl[2].configure(.blk_parent(this));
      com_pre_det_ctl[2].build(csr_excl);
      default_map.add_reg(.rg(com_pre_det_ctl[2]),
                          .offset(32'h6c));
      com_pre_det_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_pre_det_ctl_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      com_pre_det_ctl[3] =
          (sysrst_ctrl_reg_com_pre_det_ctl::
           type_id::create("com_pre_det_ctl_3"));
      com_pre_det_ctl[3].configure(.blk_parent(this));
      com_pre_det_ctl[3].build(csr_excl);
      default_map.add_reg(.rg(com_pre_det_ctl[3]),
                          .offset(32'h70));
      com_pre_det_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_pre_det_ctl_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      com_sel_ctl[0] =
          (sysrst_ctrl_reg_com_sel_ctl::
           type_id::create("com_sel_ctl_0"));
      com_sel_ctl[0].configure(.blk_parent(this));
      com_sel_ctl[0].build(csr_excl);
      default_map.add_reg(.rg(com_sel_ctl[0]),
                          .offset(32'h74));
      com_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_0_key0_in_sel_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_0_key1_in_sel_0.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_0_key2_in_sel_0.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_0_pwrb_in_sel_0.q",
          3, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_0_ac_present_sel_0.q",
          4, 1, 0, "BkdrRegPathRtl");

      com_sel_ctl[1] =
          (sysrst_ctrl_reg_com_sel_ctl::
           type_id::create("com_sel_ctl_1"));
      com_sel_ctl[1].configure(.blk_parent(this));
      com_sel_ctl[1].build(csr_excl);
      default_map.add_reg(.rg(com_sel_ctl[1]),
                          .offset(32'h78));
      com_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_1_key0_in_sel_1.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_1_key1_in_sel_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_1_key2_in_sel_1.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_1_pwrb_in_sel_1.q",
          3, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_1_ac_present_sel_1.q",
          4, 1, 0, "BkdrRegPathRtl");

      com_sel_ctl[2] =
          (sysrst_ctrl_reg_com_sel_ctl::
           type_id::create("com_sel_ctl_2"));
      com_sel_ctl[2].configure(.blk_parent(this));
      com_sel_ctl[2].build(csr_excl);
      default_map.add_reg(.rg(com_sel_ctl[2]),
                          .offset(32'h7c));
      com_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_2_key0_in_sel_2.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_2_key1_in_sel_2.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_2_key2_in_sel_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_2_pwrb_in_sel_2.q",
          3, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_2_ac_present_sel_2.q",
          4, 1, 0, "BkdrRegPathRtl");

      com_sel_ctl[3] =
          (sysrst_ctrl_reg_com_sel_ctl::
           type_id::create("com_sel_ctl_3"));
      com_sel_ctl[3].configure(.blk_parent(this));
      com_sel_ctl[3].build(csr_excl);
      default_map.add_reg(.rg(com_sel_ctl[3]),
                          .offset(32'h80));
      com_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_3_key0_in_sel_3.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_3_key1_in_sel_3.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_3_key2_in_sel_3.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_3_pwrb_in_sel_3.q",
          3, 1, 0, "BkdrRegPathRtl");
      com_sel_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_sel_ctl_3_ac_present_sel_3.q",
          4, 1, 0, "BkdrRegPathRtl");

      com_det_ctl[0] =
          (sysrst_ctrl_reg_com_det_ctl::
           type_id::create("com_det_ctl_0"));
      com_det_ctl[0].configure(.blk_parent(this));
      com_det_ctl[0].build(csr_excl);
      default_map.add_reg(.rg(com_det_ctl[0]),
                          .offset(32'h84));
      com_det_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_det_ctl_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      com_det_ctl[1] =
          (sysrst_ctrl_reg_com_det_ctl::
           type_id::create("com_det_ctl_1"));
      com_det_ctl[1].configure(.blk_parent(this));
      com_det_ctl[1].build(csr_excl);
      default_map.add_reg(.rg(com_det_ctl[1]),
                          .offset(32'h88));
      com_det_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_det_ctl_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      com_det_ctl[2] =
          (sysrst_ctrl_reg_com_det_ctl::
           type_id::create("com_det_ctl_2"));
      com_det_ctl[2].configure(.blk_parent(this));
      com_det_ctl[2].build(csr_excl);
      default_map.add_reg(.rg(com_det_ctl[2]),
                          .offset(32'h8c));
      com_det_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_det_ctl_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      com_det_ctl[3] =
          (sysrst_ctrl_reg_com_det_ctl::
           type_id::create("com_det_ctl_3"));
      com_det_ctl[3].configure(.blk_parent(this));
      com_det_ctl[3].build(csr_excl);
      default_map.add_reg(.rg(com_det_ctl[3]),
                          .offset(32'h90));
      com_det_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_det_ctl_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      com_out_ctl[0] =
          (sysrst_ctrl_reg_com_out_ctl::
           type_id::create("com_out_ctl_0"));
      com_out_ctl[0].configure(.blk_parent(this));
      com_out_ctl[0].build(csr_excl);
      default_map.add_reg(.rg(com_out_ctl[0]),
                          .offset(32'h94));
      com_out_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_0_bat_disable_0.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_0_interrupt_0.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_0_ec_rst_0.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[0].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_0_rst_req_0.q",
          3, 1, 0, "BkdrRegPathRtl");

      com_out_ctl[1] =
          (sysrst_ctrl_reg_com_out_ctl::
           type_id::create("com_out_ctl_1"));
      com_out_ctl[1].configure(.blk_parent(this));
      com_out_ctl[1].build(csr_excl);
      default_map.add_reg(.rg(com_out_ctl[1]),
                          .offset(32'h98));
      com_out_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_1_bat_disable_1.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_1_interrupt_1.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_1_ec_rst_1.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[1].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_1_rst_req_1.q",
          3, 1, 0, "BkdrRegPathRtl");

      com_out_ctl[2] =
          (sysrst_ctrl_reg_com_out_ctl::
           type_id::create("com_out_ctl_2"));
      com_out_ctl[2].configure(.blk_parent(this));
      com_out_ctl[2].build(csr_excl);
      default_map.add_reg(.rg(com_out_ctl[2]),
                          .offset(32'h9c));
      com_out_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_2_bat_disable_2.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_2_interrupt_2.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_2_ec_rst_2.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[2].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_2_rst_req_2.q",
          3, 1, 0, "BkdrRegPathRtl");

      com_out_ctl[3] =
          (sysrst_ctrl_reg_com_out_ctl::
           type_id::create("com_out_ctl_3"));
      com_out_ctl[3].configure(.blk_parent(this));
      com_out_ctl[3].build(csr_excl);
      default_map.add_reg(.rg(com_out_ctl[3]),
                          .offset(32'ha0));
      com_out_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_3_bat_disable_3.q",
          0, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_3_interrupt_3.q",
          1, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_3_ec_rst_3.q",
          2, 1, 0, "BkdrRegPathRtl");
      com_out_ctl[3].add_hdl_path_slice(
          "u_reg.u_com_out_ctl_3_rst_req_3.q",
          3, 1, 0, "BkdrRegPathRtl");

      combo_intr_status =
          (sysrst_ctrl_reg_combo_intr_status::
           type_id::create("combo_intr_status"));
      combo_intr_status.configure(.blk_parent(this));
      combo_intr_status.build(csr_excl);
      default_map.add_reg(.rg(combo_intr_status),
                          .offset(32'ha4));
      combo_intr_status.add_hdl_path_slice(
          "u_reg.u_combo_intr_status_combo0_h2l.q",
          0, 1, 0, "BkdrRegPathRtl");
      combo_intr_status.add_hdl_path_slice(
          "u_reg.u_combo_intr_status_combo1_h2l.q",
          1, 1, 0, "BkdrRegPathRtl");
      combo_intr_status.add_hdl_path_slice(
          "u_reg.u_combo_intr_status_combo2_h2l.q",
          2, 1, 0, "BkdrRegPathRtl");
      combo_intr_status.add_hdl_path_slice(
          "u_reg.u_combo_intr_status_combo3_h2l.q",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(combo_intr_status.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      key_intr_status =
          (sysrst_ctrl_reg_key_intr_status::
           type_id::create("key_intr_status"));
      key_intr_status.configure(.blk_parent(this));
      key_intr_status.build(csr_excl);
      default_map.add_reg(.rg(key_intr_status),
                          .offset(32'ha8));
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_pwrb_h2l.q",
          0, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_key0_in_h2l.q",
          1, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_key1_in_h2l.q",
          2, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_key2_in_h2l.q",
          3, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_ac_present_h2l.q",
          4, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_ec_rst_l_h2l.q",
          5, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_flash_wp_l_h2l.q",
          6, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_pwrb_l2h.q",
          7, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_key0_in_l2h.q",
          8, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_key1_in_l2h.q",
          9, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_key2_in_l2h.q",
          10, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_ac_present_l2h.q",
          11, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_ec_rst_l_l2h.q",
          12, 1, 0, "BkdrRegPathRtl");
      key_intr_status.add_hdl_path_slice(
          "u_reg.u_key_intr_status_flash_wp_l_l2h.q",
          13, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_intr_status.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      // assign locked reg to its regwen reg
      regwen.add_lockable_reg_or_fld(ec_rst_ctl);
      regwen.add_lockable_reg_or_fld(ulp_ac_debounce_ctl);
      regwen.add_lockable_reg_or_fld(ulp_lid_debounce_ctl);
      regwen.add_lockable_reg_or_fld(ulp_pwrb_debounce_ctl);
      regwen.add_lockable_reg_or_fld(key_invert_ctl);
      regwen.add_lockable_reg_or_fld(pin_allowed_ctl);
      regwen.add_lockable_reg_or_fld(key_intr_ctl);
      regwen.add_lockable_reg_or_fld(key_intr_debounce_ctl);
      regwen.add_lockable_reg_or_fld(auto_block_debounce_ctl);
      regwen.add_lockable_reg_or_fld(auto_block_out_ctl);
      regwen.add_lockable_reg_or_fld(com_pre_sel_ctl[0]);
      regwen.add_lockable_reg_or_fld(com_pre_sel_ctl[1]);
      regwen.add_lockable_reg_or_fld(com_pre_sel_ctl[2]);
      regwen.add_lockable_reg_or_fld(com_pre_sel_ctl[3]);
      regwen.add_lockable_reg_or_fld(com_pre_det_ctl[0]);
      regwen.add_lockable_reg_or_fld(com_pre_det_ctl[1]);
      regwen.add_lockable_reg_or_fld(com_pre_det_ctl[2]);
      regwen.add_lockable_reg_or_fld(com_pre_det_ctl[3]);
      regwen.add_lockable_reg_or_fld(com_sel_ctl[0]);
      regwen.add_lockable_reg_or_fld(com_sel_ctl[1]);
      regwen.add_lockable_reg_or_fld(com_sel_ctl[2]);
      regwen.add_lockable_reg_or_fld(com_sel_ctl[3]);
      regwen.add_lockable_reg_or_fld(com_det_ctl[0]);
      regwen.add_lockable_reg_or_fld(com_det_ctl[1]);
      regwen.add_lockable_reg_or_fld(com_det_ctl[2]);
      regwen.add_lockable_reg_or_fld(com_det_ctl[3]);
      regwen.add_lockable_reg_or_fld(com_out_ctl[0]);
      regwen.add_lockable_reg_or_fld(com_out_ctl[1]);
      regwen.add_lockable_reg_or_fld(com_out_ctl[2]);
      regwen.add_lockable_reg_or_fld(com_out_ctl[3]);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : sysrst_ctrl_reg_block

endpackage

