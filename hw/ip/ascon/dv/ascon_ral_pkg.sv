// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package ascon_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class ascon_reg_alert_test;
  typedef class ascon_reg_key_share0;
  typedef class ascon_reg_key_share1;
  typedef class ascon_reg_nonce_share0;
  typedef class ascon_reg_nonce_share1;
  typedef class ascon_reg_data_in_share0;
  typedef class ascon_reg_data_in_share1;
  typedef class ascon_reg_tag_in;
  typedef class ascon_reg_msg_out;
  typedef class ascon_reg_tag_out;
  typedef class ascon_reg_ctrl_shadowed;
  typedef class ascon_reg_ctrl_aux_shadowed;
  typedef class ascon_reg_ctrl_aux_regwen;
  typedef class ascon_reg_block_ctrl_shadowed;
  typedef class ascon_reg_trigger;
  typedef class ascon_reg_status;
  typedef class ascon_reg_output_valid;
  typedef class ascon_reg_fsm_state;
  typedef class ascon_reg_fsm_state_regren;
  typedef class ascon_reg_error;
  typedef class ascon_reg_block;

  class ascon_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field recov_ctrl_update_err;
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(ascon_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      recov_ctrl_update_err =
          (dv_base_reg_field::
           type_id::create("recov_ctrl_update_err"));
      recov_ctrl_update_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov_ctrl_update_err.set_original_access("WO");
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_alert_test

  class ascon_reg_key_share0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field key_share0;

    `uvm_object_utils(ascon_reg_key_share0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key_share0 =
          (dv_base_reg_field::
           type_id::create("key_share0_0"));
      key_share0.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_share0.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_key_share0

  class ascon_reg_key_share1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field key_share1;

    `uvm_object_utils(ascon_reg_key_share1)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key_share1 =
          (dv_base_reg_field::
           type_id::create("key_share1_0"));
      key_share1.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_share1.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_key_share1

  class ascon_reg_nonce_share0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field nonce;

    `uvm_object_utils(ascon_reg_nonce_share0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      nonce =
          (dv_base_reg_field::
           type_id::create("nonce_0"));
      nonce.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nonce.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_nonce_share0

  class ascon_reg_nonce_share1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field nonce;

    `uvm_object_utils(ascon_reg_nonce_share1)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      nonce =
          (dv_base_reg_field::
           type_id::create("nonce_0"));
      nonce.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      nonce.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_nonce_share1

  class ascon_reg_data_in_share0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field msg_in;

    `uvm_object_utils(ascon_reg_data_in_share0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      msg_in =
          (dv_base_reg_field::
           type_id::create("msg_in_0"));
      msg_in.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      msg_in.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_data_in_share0

  class ascon_reg_data_in_share1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field msg_in;

    `uvm_object_utils(ascon_reg_data_in_share1)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      msg_in =
          (dv_base_reg_field::
           type_id::create("msg_in_0"));
      msg_in.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      msg_in.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_data_in_share1

  class ascon_reg_tag_in extends dv_base_reg;
    // fields
    rand dv_base_reg_field tag_in;

    `uvm_object_utils(ascon_reg_tag_in)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tag_in =
          (dv_base_reg_field::
           type_id::create("tag_in_0"));
      tag_in.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tag_in.set_original_access("WO");
    endfunction : build
  endclass : ascon_reg_tag_in

  class ascon_reg_msg_out extends dv_base_reg;
    // fields
    rand dv_base_reg_field msg_out;

    `uvm_object_utils(ascon_reg_msg_out)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      msg_out =
          (dv_base_reg_field::
           type_id::create("msg_out_0"));
      msg_out.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      msg_out.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_msg_out

  class ascon_reg_tag_out extends dv_base_reg;
    // fields
    rand dv_base_reg_field tag_out;

    `uvm_object_utils(ascon_reg_tag_out)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      tag_out =
          (dv_base_reg_field::
           type_id::create("tag_out_0"));
      tag_out.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tag_out.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_tag_out

  class ascon_reg_ctrl_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field operation;
    rand dv_base_reg_field ascon_variant;
    rand dv_base_reg_field sideload_key;
    rand dv_base_reg_field masked_ad_input;
    rand dv_base_reg_field masked_msg_input;
    rand dv_base_reg_field no_msg;
    rand dv_base_reg_field no_ad;

    `uvm_object_utils(ascon_reg_ctrl_shadowed)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      operation =
          (dv_base_reg_field::
           type_id::create("operation"));
      operation.configure(
        .parent(this),
        .size(3),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      operation.set_original_access("RW");
      ascon_variant =
          (dv_base_reg_field::
           type_id::create("ascon_variant"));
      ascon_variant.configure(
        .parent(this),
        .size(2),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ascon_variant.set_original_access("RW");
      sideload_key =
          (dv_base_reg_field::
           type_id::create("sideload_key"));
      sideload_key.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sideload_key.set_original_access("RW");
      masked_ad_input =
          (dv_base_reg_field::
           type_id::create("masked_ad_input"));
      masked_ad_input.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      masked_ad_input.set_original_access("RW");
      masked_msg_input =
          (dv_base_reg_field::
           type_id::create("masked_msg_input"));
      masked_msg_input.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      masked_msg_input.set_original_access("RW");
      no_msg =
          (dv_base_reg_field::
           type_id::create("no_msg"));
      no_msg.configure(
        .parent(this),
        .size(4),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h6),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      no_msg.set_original_access("RW");
      no_ad =
          (dv_base_reg_field::
           type_id::create("no_ad"));
      no_ad.configure(
        .parent(this),
        .size(4),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      no_ad.set_original_access("RW");
    endfunction : build
  endclass : ascon_reg_ctrl_shadowed

  class ascon_reg_ctrl_aux_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field manual_start_trigger;
    rand dv_base_reg_field force_data_overwrite;

    `uvm_object_utils(ascon_reg_ctrl_aux_shadowed)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      manual_start_trigger =
          (dv_base_reg_field::
           type_id::create("manual_start_trigger"));
      manual_start_trigger.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      manual_start_trigger.set_original_access("RW");
      force_data_overwrite =
          (dv_base_reg_field::
           type_id::create("force_data_overwrite"));
      force_data_overwrite.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      force_data_overwrite.set_original_access("RW");
    endfunction : build
  endclass : ascon_reg_ctrl_aux_shadowed

  class ascon_reg_ctrl_aux_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field ctrl_aux_regwen;

    `uvm_object_utils(ascon_reg_ctrl_aux_regwen)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ctrl_aux_regwen =
          (dv_base_reg_field::
           type_id::create("ctrl_aux_regwen"));
      ctrl_aux_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ctrl_aux_regwen.set_original_access("W0C");
    endfunction : build
  endclass : ascon_reg_ctrl_aux_regwen

  class ascon_reg_block_ctrl_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field data_type_start;
    rand dv_base_reg_field data_type_last;
    rand dv_base_reg_field valid_bytes;

    `uvm_object_utils(ascon_reg_block_ctrl_shadowed)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data_type_start =
          (dv_base_reg_field::
           type_id::create("data_type_start"));
      data_type_start.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data_type_start.set_original_access("RW");
      data_type_last =
          (dv_base_reg_field::
           type_id::create("data_type_last"));
      data_type_last.configure(
        .parent(this),
        .size(12),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data_type_last.set_original_access("RW");
      valid_bytes =
          (dv_base_reg_field::
           type_id::create("valid_bytes"));
      valid_bytes.configure(
        .parent(this),
        .size(5),
        .lsb_pos(24),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1f),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      valid_bytes.set_original_access("RW");
    endfunction : build
  endclass : ascon_reg_block_ctrl_shadowed

  class ascon_reg_trigger extends dv_base_reg;
    // fields
    rand dv_base_reg_field start;
    rand dv_base_reg_field wipe;

    `uvm_object_utils(ascon_reg_trigger)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      start =
          (dv_base_reg_field::
           type_id::create("start"));
      start.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      start.set_original_access("RW");
      wipe =
          (dv_base_reg_field::
           type_id::create("wipe"));
      wipe.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wipe.set_original_access("RW");
    endfunction : build
  endclass : ascon_reg_trigger

  class ascon_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field idle;
    rand dv_base_reg_field stall;
    rand dv_base_reg_field wait_edn;
    rand dv_base_reg_field ascon_error;
    rand dv_base_reg_field alert_recov_ctrl_update_err;
    rand dv_base_reg_field alert_fatal_fault;

    `uvm_object_utils(ascon_reg_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      idle =
          (dv_base_reg_field::
           type_id::create("idle"));
      idle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      idle.set_original_access("RO");
      stall =
          (dv_base_reg_field::
           type_id::create("stall"));
      stall.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      stall.set_original_access("RO");
      wait_edn =
          (dv_base_reg_field::
           type_id::create("wait_edn"));
      wait_edn.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wait_edn.set_original_access("RO");
      ascon_error =
          (dv_base_reg_field::
           type_id::create("ascon_error"));
      ascon_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ascon_error.set_original_access("RO");
      alert_recov_ctrl_update_err =
          (dv_base_reg_field::
           type_id::create("alert_recov_ctrl_update_err"));
      alert_recov_ctrl_update_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      alert_recov_ctrl_update_err.set_original_access("RO");
      alert_fatal_fault =
          (dv_base_reg_field::
           type_id::create("alert_fatal_fault"));
      alert_fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      alert_fatal_fault.set_original_access("RO");
    endfunction : build
  endclass : ascon_reg_status

  class ascon_reg_output_valid extends dv_base_reg;
    // fields
    rand dv_base_reg_field msg_valid;
    rand dv_base_reg_field tag_valid;
    rand dv_base_reg_field tag_comparison_valid;

    `uvm_object_utils(ascon_reg_output_valid)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      msg_valid =
          (dv_base_reg_field::
           type_id::create("msg_valid"));
      msg_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      msg_valid.set_original_access("RO");
      tag_valid =
          (dv_base_reg_field::
           type_id::create("tag_valid"));
      tag_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tag_valid.set_original_access("RO");
      tag_comparison_valid =
          (dv_base_reg_field::
           type_id::create("tag_comparison_valid"));
      tag_comparison_valid.configure(
        .parent(this),
        .size(2),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      tag_comparison_valid.set_original_access("RO");
    endfunction : build
  endclass : ascon_reg_output_valid

  class ascon_reg_fsm_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field main_fsm;

    `uvm_object_utils(ascon_reg_fsm_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      main_fsm =
          (dv_base_reg_field::
           type_id::create("main_fsm"));
      main_fsm.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      main_fsm.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : ascon_reg_fsm_state

  class ascon_reg_fsm_state_regren extends dv_base_reg;
    // fields
    rand dv_base_reg_field fsm_state_regren;

    `uvm_object_utils(ascon_reg_fsm_state_regren)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fsm_state_regren =
          (dv_base_reg_field::
           type_id::create("fsm_state_regren"));
      fsm_state_regren.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fsm_state_regren.set_original_access("W0C");
    endfunction : build
  endclass : ascon_reg_fsm_state_regren

  class ascon_reg_error extends dv_base_reg;
    // fields
    rand dv_base_reg_field no_key;
    rand dv_base_reg_field no_nonce;
    rand dv_base_reg_field wrong_order;
    rand dv_base_reg_field flag_input_missmatch;

    `uvm_object_utils(ascon_reg_error)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      no_key =
          (dv_base_reg_field::
           type_id::create("no_key"));
      no_key.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      no_key.set_original_access("RO");
      no_nonce =
          (dv_base_reg_field::
           type_id::create("no_nonce"));
      no_nonce.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      no_nonce.set_original_access("RO");
      wrong_order =
          (dv_base_reg_field::
           type_id::create("wrong_order"));
      wrong_order.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wrong_order.set_original_access("RO");
      flag_input_missmatch =
          (dv_base_reg_field::
           type_id::create("flag_input_missmatch"));
      flag_input_missmatch.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      flag_input_missmatch.set_original_access("RO");
    endfunction : build
  endclass : ascon_reg_error

  class ascon_reg_block extends dv_base_reg_block;
    // registers
    rand ascon_reg_alert_test alert_test;
    rand ascon_reg_key_share0 key_share0[4];
    rand ascon_reg_key_share1 key_share1[4];
    rand ascon_reg_nonce_share0 nonce_share0[4];
    rand ascon_reg_nonce_share1 nonce_share1[4];
    rand ascon_reg_data_in_share0 data_in_share0[4];
    rand ascon_reg_data_in_share1 data_in_share1[4];
    rand ascon_reg_tag_in tag_in[4];
    rand ascon_reg_msg_out msg_out[4];
    rand ascon_reg_tag_out tag_out[4];
    rand ascon_reg_ctrl_shadowed ctrl_shadowed;
    rand ascon_reg_ctrl_aux_shadowed ctrl_aux_shadowed;
    rand ascon_reg_ctrl_aux_regwen ctrl_aux_regwen;
    rand ascon_reg_block_ctrl_shadowed block_ctrl_shadowed;
    rand ascon_reg_trigger trigger;
    rand ascon_reg_status status;
    rand ascon_reg_output_valid output_valid;
    rand ascon_reg_fsm_state fsm_state;
    rand ascon_reg_fsm_state_regren fsm_state_regren;
    rand ascon_reg_error error;

    `uvm_object_utils(ascon_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      alert_test =
          (ascon_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'h0));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_recov_ctrl_update_err.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_fault.qs",
          1, 1, 0, "BkdrRegPathRtl");

      key_share0[0] =
          (ascon_reg_key_share0::
           type_id::create("key_share0_0"));
      key_share0[0].configure(.blk_parent(this));
      key_share0[0].build(csr_excl);
      default_map.add_reg(.rg(key_share0[0]),
                          .offset(32'h4));
      key_share0[0].add_hdl_path_slice(
          "u_reg.u_key_share0_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[1] =
          (ascon_reg_key_share0::
           type_id::create("key_share0_1"));
      key_share0[1].configure(.blk_parent(this));
      key_share0[1].build(csr_excl);
      default_map.add_reg(.rg(key_share0[1]),
                          .offset(32'h8));
      key_share0[1].add_hdl_path_slice(
          "u_reg.u_key_share0_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[2] =
          (ascon_reg_key_share0::
           type_id::create("key_share0_2"));
      key_share0[2].configure(.blk_parent(this));
      key_share0[2].build(csr_excl);
      default_map.add_reg(.rg(key_share0[2]),
                          .offset(32'hc));
      key_share0[2].add_hdl_path_slice(
          "u_reg.u_key_share0_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share0[3] =
          (ascon_reg_key_share0::
           type_id::create("key_share0_3"));
      key_share0[3].configure(.blk_parent(this));
      key_share0[3].build(csr_excl);
      default_map.add_reg(.rg(key_share0[3]),
                          .offset(32'h10));
      key_share0[3].add_hdl_path_slice(
          "u_reg.u_key_share0_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[0] =
          (ascon_reg_key_share1::
           type_id::create("key_share1_0"));
      key_share1[0].configure(.blk_parent(this));
      key_share1[0].build(csr_excl);
      default_map.add_reg(.rg(key_share1[0]),
                          .offset(32'h14));
      key_share1[0].add_hdl_path_slice(
          "u_reg.u_key_share1_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[1] =
          (ascon_reg_key_share1::
           type_id::create("key_share1_1"));
      key_share1[1].configure(.blk_parent(this));
      key_share1[1].build(csr_excl);
      default_map.add_reg(.rg(key_share1[1]),
                          .offset(32'h18));
      key_share1[1].add_hdl_path_slice(
          "u_reg.u_key_share1_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[2] =
          (ascon_reg_key_share1::
           type_id::create("key_share1_2"));
      key_share1[2].configure(.blk_parent(this));
      key_share1[2].build(csr_excl);
      default_map.add_reg(.rg(key_share1[2]),
                          .offset(32'h1c));
      key_share1[2].add_hdl_path_slice(
          "u_reg.u_key_share1_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key_share1[3] =
          (ascon_reg_key_share1::
           type_id::create("key_share1_3"));
      key_share1[3].configure(.blk_parent(this));
      key_share1[3].build(csr_excl);
      default_map.add_reg(.rg(key_share1[3]),
                          .offset(32'h20));
      key_share1[3].add_hdl_path_slice(
          "u_reg.u_key_share1_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      nonce_share0[0] =
          (ascon_reg_nonce_share0::
           type_id::create("nonce_share0_0"));
      nonce_share0[0].configure(.blk_parent(this));
      nonce_share0[0].build(csr_excl);
      default_map.add_reg(.rg(nonce_share0[0]),
                          .offset(32'h24));
      nonce_share0[0].add_hdl_path_slice(
          "u_reg.u_nonce_share0_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      nonce_share0[1] =
          (ascon_reg_nonce_share0::
           type_id::create("nonce_share0_1"));
      nonce_share0[1].configure(.blk_parent(this));
      nonce_share0[1].build(csr_excl);
      default_map.add_reg(.rg(nonce_share0[1]),
                          .offset(32'h28));
      nonce_share0[1].add_hdl_path_slice(
          "u_reg.u_nonce_share0_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      nonce_share0[2] =
          (ascon_reg_nonce_share0::
           type_id::create("nonce_share0_2"));
      nonce_share0[2].configure(.blk_parent(this));
      nonce_share0[2].build(csr_excl);
      default_map.add_reg(.rg(nonce_share0[2]),
                          .offset(32'h2c));
      nonce_share0[2].add_hdl_path_slice(
          "u_reg.u_nonce_share0_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      nonce_share0[3] =
          (ascon_reg_nonce_share0::
           type_id::create("nonce_share0_3"));
      nonce_share0[3].configure(.blk_parent(this));
      nonce_share0[3].build(csr_excl);
      default_map.add_reg(.rg(nonce_share0[3]),
                          .offset(32'h30));
      nonce_share0[3].add_hdl_path_slice(
          "u_reg.u_nonce_share0_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      nonce_share1[0] =
          (ascon_reg_nonce_share1::
           type_id::create("nonce_share1_0"));
      nonce_share1[0].configure(.blk_parent(this));
      nonce_share1[0].build(csr_excl);
      default_map.add_reg(.rg(nonce_share1[0]),
                          .offset(32'h34));
      nonce_share1[0].add_hdl_path_slice(
          "u_reg.u_nonce_share1_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      nonce_share1[1] =
          (ascon_reg_nonce_share1::
           type_id::create("nonce_share1_1"));
      nonce_share1[1].configure(.blk_parent(this));
      nonce_share1[1].build(csr_excl);
      default_map.add_reg(.rg(nonce_share1[1]),
                          .offset(32'h38));
      nonce_share1[1].add_hdl_path_slice(
          "u_reg.u_nonce_share1_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      nonce_share1[2] =
          (ascon_reg_nonce_share1::
           type_id::create("nonce_share1_2"));
      nonce_share1[2].configure(.blk_parent(this));
      nonce_share1[2].build(csr_excl);
      default_map.add_reg(.rg(nonce_share1[2]),
                          .offset(32'h3c));
      nonce_share1[2].add_hdl_path_slice(
          "u_reg.u_nonce_share1_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      nonce_share1[3] =
          (ascon_reg_nonce_share1::
           type_id::create("nonce_share1_3"));
      nonce_share1[3].configure(.blk_parent(this));
      nonce_share1[3].build(csr_excl);
      default_map.add_reg(.rg(nonce_share1[3]),
                          .offset(32'h40));
      nonce_share1[3].add_hdl_path_slice(
          "u_reg.u_nonce_share1_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      data_in_share0[0] =
          (ascon_reg_data_in_share0::
           type_id::create("data_in_share0_0"));
      data_in_share0[0].configure(.blk_parent(this));
      data_in_share0[0].build(csr_excl);
      default_map.add_reg(.rg(data_in_share0[0]),
                          .offset(32'h44));
      data_in_share0[0].add_hdl_path_slice(
          "u_reg.u_data_in_share0_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      data_in_share0[1] =
          (ascon_reg_data_in_share0::
           type_id::create("data_in_share0_1"));
      data_in_share0[1].configure(.blk_parent(this));
      data_in_share0[1].build(csr_excl);
      default_map.add_reg(.rg(data_in_share0[1]),
                          .offset(32'h48));
      data_in_share0[1].add_hdl_path_slice(
          "u_reg.u_data_in_share0_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      data_in_share0[2] =
          (ascon_reg_data_in_share0::
           type_id::create("data_in_share0_2"));
      data_in_share0[2].configure(.blk_parent(this));
      data_in_share0[2].build(csr_excl);
      default_map.add_reg(.rg(data_in_share0[2]),
                          .offset(32'h4c));
      data_in_share0[2].add_hdl_path_slice(
          "u_reg.u_data_in_share0_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      data_in_share0[3] =
          (ascon_reg_data_in_share0::
           type_id::create("data_in_share0_3"));
      data_in_share0[3].configure(.blk_parent(this));
      data_in_share0[3].build(csr_excl);
      default_map.add_reg(.rg(data_in_share0[3]),
                          .offset(32'h50));
      data_in_share0[3].add_hdl_path_slice(
          "u_reg.u_data_in_share0_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      data_in_share1[0] =
          (ascon_reg_data_in_share1::
           type_id::create("data_in_share1_0"));
      data_in_share1[0].configure(.blk_parent(this));
      data_in_share1[0].build(csr_excl);
      default_map.add_reg(.rg(data_in_share1[0]),
                          .offset(32'h54));
      data_in_share1[0].add_hdl_path_slice(
          "u_reg.u_data_in_share1_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      data_in_share1[1] =
          (ascon_reg_data_in_share1::
           type_id::create("data_in_share1_1"));
      data_in_share1[1].configure(.blk_parent(this));
      data_in_share1[1].build(csr_excl);
      default_map.add_reg(.rg(data_in_share1[1]),
                          .offset(32'h58));
      data_in_share1[1].add_hdl_path_slice(
          "u_reg.u_data_in_share1_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      data_in_share1[2] =
          (ascon_reg_data_in_share1::
           type_id::create("data_in_share1_2"));
      data_in_share1[2].configure(.blk_parent(this));
      data_in_share1[2].build(csr_excl);
      default_map.add_reg(.rg(data_in_share1[2]),
                          .offset(32'h5c));
      data_in_share1[2].add_hdl_path_slice(
          "u_reg.u_data_in_share1_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      data_in_share1[3] =
          (ascon_reg_data_in_share1::
           type_id::create("data_in_share1_3"));
      data_in_share1[3].configure(.blk_parent(this));
      data_in_share1[3].build(csr_excl);
      default_map.add_reg(.rg(data_in_share1[3]),
                          .offset(32'h60));
      data_in_share1[3].add_hdl_path_slice(
          "u_reg.u_data_in_share1_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      tag_in[0] =
          (ascon_reg_tag_in::
           type_id::create("tag_in_0"));
      tag_in[0].configure(.blk_parent(this));
      tag_in[0].build(csr_excl);
      default_map.add_reg(.rg(tag_in[0]),
                          .offset(32'h64));
      tag_in[0].add_hdl_path_slice(
          "u_reg.u_tag_in_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      tag_in[1] =
          (ascon_reg_tag_in::
           type_id::create("tag_in_1"));
      tag_in[1].configure(.blk_parent(this));
      tag_in[1].build(csr_excl);
      default_map.add_reg(.rg(tag_in[1]),
                          .offset(32'h68));
      tag_in[1].add_hdl_path_slice(
          "u_reg.u_tag_in_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      tag_in[2] =
          (ascon_reg_tag_in::
           type_id::create("tag_in_2"));
      tag_in[2].configure(.blk_parent(this));
      tag_in[2].build(csr_excl);
      default_map.add_reg(.rg(tag_in[2]),
                          .offset(32'h6c));
      tag_in[2].add_hdl_path_slice(
          "u_reg.u_tag_in_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      tag_in[3] =
          (ascon_reg_tag_in::
           type_id::create("tag_in_3"));
      tag_in[3].configure(.blk_parent(this));
      tag_in[3].build(csr_excl);
      default_map.add_reg(.rg(tag_in[3]),
                          .offset(32'h70));
      tag_in[3].add_hdl_path_slice(
          "u_reg.u_tag_in_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      msg_out[0] =
          (ascon_reg_msg_out::
           type_id::create("msg_out_0"));
      msg_out[0].configure(.blk_parent(this));
      msg_out[0].build(csr_excl);
      default_map.add_reg(.rg(msg_out[0]),
                          .offset(32'h74));
      msg_out[0].add_hdl_path_slice(
          "u_reg.u_msg_out_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      msg_out[1] =
          (ascon_reg_msg_out::
           type_id::create("msg_out_1"));
      msg_out[1].configure(.blk_parent(this));
      msg_out[1].build(csr_excl);
      default_map.add_reg(.rg(msg_out[1]),
                          .offset(32'h78));
      msg_out[1].add_hdl_path_slice(
          "u_reg.u_msg_out_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      msg_out[2] =
          (ascon_reg_msg_out::
           type_id::create("msg_out_2"));
      msg_out[2].configure(.blk_parent(this));
      msg_out[2].build(csr_excl);
      default_map.add_reg(.rg(msg_out[2]),
                          .offset(32'h7c));
      msg_out[2].add_hdl_path_slice(
          "u_reg.u_msg_out_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      msg_out[3] =
          (ascon_reg_msg_out::
           type_id::create("msg_out_3"));
      msg_out[3].configure(.blk_parent(this));
      msg_out[3].build(csr_excl);
      default_map.add_reg(.rg(msg_out[3]),
                          .offset(32'h80));
      msg_out[3].add_hdl_path_slice(
          "u_reg.u_msg_out_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      tag_out[0] =
          (ascon_reg_tag_out::
           type_id::create("tag_out_0"));
      tag_out[0].configure(.blk_parent(this));
      tag_out[0].build(csr_excl);
      default_map.add_reg(.rg(tag_out[0]),
                          .offset(32'h84));
      tag_out[0].add_hdl_path_slice(
          "u_reg.u_tag_out_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      tag_out[1] =
          (ascon_reg_tag_out::
           type_id::create("tag_out_1"));
      tag_out[1].configure(.blk_parent(this));
      tag_out[1].build(csr_excl);
      default_map.add_reg(.rg(tag_out[1]),
                          .offset(32'h88));
      tag_out[1].add_hdl_path_slice(
          "u_reg.u_tag_out_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      tag_out[2] =
          (ascon_reg_tag_out::
           type_id::create("tag_out_2"));
      tag_out[2].configure(.blk_parent(this));
      tag_out[2].build(csr_excl);
      default_map.add_reg(.rg(tag_out[2]),
                          .offset(32'h8c));
      tag_out[2].add_hdl_path_slice(
          "u_reg.u_tag_out_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      tag_out[3] =
          (ascon_reg_tag_out::
           type_id::create("tag_out_3"));
      tag_out[3].configure(.blk_parent(this));
      tag_out[3].build(csr_excl);
      default_map.add_reg(.rg(tag_out[3]),
                          .offset(32'h90));
      tag_out[3].add_hdl_path_slice(
          "u_reg.u_tag_out_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      ctrl_shadowed =
          (ascon_reg_ctrl_shadowed::
           type_id::create("ctrl_shadowed"));
      ctrl_shadowed.configure(.blk_parent(this));
      ctrl_shadowed.build(csr_excl);
      default_map.add_reg(.rg(ctrl_shadowed),
                          .offset(32'h94));


      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_operation.committed_reg.q",
          0, 3, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_operation.shadow_reg.q",
          0, 3, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_ascon_variant.committed_reg.q",
          3, 2, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_ascon_variant.shadow_reg.q",
          3, 2, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_sideload_key.committed_reg.q",
          5, 1, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_sideload_key.shadow_reg.q",
          5, 1, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_masked_ad_input.committed_reg.q",
          6, 1, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_masked_ad_input.shadow_reg.q",
          6, 1, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_masked_msg_input.committed_reg.q",
          7, 1, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_masked_msg_input.shadow_reg.q",
          7, 1, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_no_msg.committed_reg.q",
          8, 4, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_no_msg.shadow_reg.q",
          8, 4, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_no_ad.committed_reg.q",
          12, 4, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_shadowed_no_ad.shadow_reg.q",
          12, 4, 0, "BkdrRegPathRtlShadow");

      ctrl_shadowed.set_is_shadowed();
      ctrl_aux_shadowed =
          (ascon_reg_ctrl_aux_shadowed::
           type_id::create("ctrl_aux_shadowed"));
      ctrl_aux_shadowed.configure(.blk_parent(this));
      ctrl_aux_shadowed.build(csr_excl);
      default_map.add_reg(.rg(ctrl_aux_shadowed),
                          .offset(32'h98));


      ctrl_aux_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_shadowed_manual_start_trigger.committed_reg.q",
          0, 1, 0, "BkdrRegPathRtl");
      ctrl_aux_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_shadowed_manual_start_trigger.shadow_reg.q",
          0, 1, 0, "BkdrRegPathRtlShadow");
      ctrl_aux_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_shadowed_force_data_overwrite.committed_reg.q",
          1, 1, 0, "BkdrRegPathRtl");
      ctrl_aux_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_shadowed_force_data_overwrite.shadow_reg.q",
          1, 1, 0, "BkdrRegPathRtlShadow");

      ctrl_aux_shadowed.set_is_shadowed();
      ctrl_aux_regwen =
          (ascon_reg_ctrl_aux_regwen::
           type_id::create("ctrl_aux_regwen"));
      ctrl_aux_regwen.configure(.blk_parent(this));
      ctrl_aux_regwen.build(csr_excl);
      default_map.add_reg(.rg(ctrl_aux_regwen),
                          .offset(32'h9c));
      ctrl_aux_regwen.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      block_ctrl_shadowed =
          (ascon_reg_block_ctrl_shadowed::
           type_id::create("block_ctrl_shadowed"));
      block_ctrl_shadowed.configure(.blk_parent(this));
      block_ctrl_shadowed.build(csr_excl);
      default_map.add_reg(.rg(block_ctrl_shadowed),
                          .offset(32'ha0));


      block_ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_block_ctrl_shadowed_data_type_start.committed_reg.q",
          0, 12, 0, "BkdrRegPathRtl");
      block_ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_block_ctrl_shadowed_data_type_start.shadow_reg.q",
          0, 12, 0, "BkdrRegPathRtlShadow");
      block_ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_block_ctrl_shadowed_data_type_last.committed_reg.q",
          12, 12, 0, "BkdrRegPathRtl");
      block_ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_block_ctrl_shadowed_data_type_last.shadow_reg.q",
          12, 12, 0, "BkdrRegPathRtlShadow");
      block_ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_block_ctrl_shadowed_valid_bytes.committed_reg.q",
          24, 5, 0, "BkdrRegPathRtl");
      block_ctrl_shadowed.add_hdl_path_slice(
          "u_reg.u_block_ctrl_shadowed_valid_bytes.shadow_reg.q",
          24, 5, 0, "BkdrRegPathRtlShadow");

      block_ctrl_shadowed.set_is_shadowed();
      trigger =
          (ascon_reg_trigger::
           type_id::create("trigger"));
      trigger.configure(.blk_parent(this));
      trigger.build(csr_excl);
      default_map.add_reg(.rg(trigger),
                          .offset(32'ha4));
      trigger.add_hdl_path_slice(
          "u_reg.u_trigger_start.q",
          0, 1, 0, "BkdrRegPathRtl");
      trigger.add_hdl_path_slice(
          "u_reg.u_trigger_wipe.q",
          1, 1, 0, "BkdrRegPathRtl");

      status =
          (ascon_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'ha8));
      status.add_hdl_path_slice(
          "u_reg.u_status_idle.q",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_stall.q",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_wait_edn.q",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_ascon_error.q",
          3, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_alert_recov_ctrl_update_err.q",
          4, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_alert_fatal_fault.q",
          5, 1, 0, "BkdrRegPathRtl");

      output_valid =
          (ascon_reg_output_valid::
           type_id::create("output_valid"));
      output_valid.configure(.blk_parent(this));
      output_valid.build(csr_excl);
      default_map.add_reg(.rg(output_valid),
                          .offset(32'hac));
      output_valid.add_hdl_path_slice(
          "u_reg.u_output_valid_msg_valid.q",
          0, 1, 0, "BkdrRegPathRtl");
      output_valid.add_hdl_path_slice(
          "u_reg.u_output_valid_tag_valid.q",
          1, 1, 0, "BkdrRegPathRtl");
      output_valid.add_hdl_path_slice(
          "u_reg.u_output_valid_tag_comparison_valid.q",
          2, 2, 0, "BkdrRegPathRtl");

      fsm_state =
          (ascon_reg_fsm_state::
           type_id::create("fsm_state"));
      fsm_state.configure(.blk_parent(this));
      fsm_state.build(csr_excl);
      default_map.add_reg(.rg(fsm_state),
                          .offset(32'hb0));
      fsm_state.add_hdl_path_slice(
          "u_reg.u_fsm_state.qs",
          0, 32, 0, "BkdrRegPathRtl");

      fsm_state_regren =
          (ascon_reg_fsm_state_regren::
           type_id::create("fsm_state_regren"));
      fsm_state_regren.configure(.blk_parent(this));
      fsm_state_regren.build(csr_excl);
      default_map.add_reg(.rg(fsm_state_regren),
                          .offset(32'hb4));
      fsm_state_regren.add_hdl_path_slice(
          "u_reg.u_fsm_state_regren.q",
          0, 1, 0, "BkdrRegPathRtl");

      error =
          (ascon_reg_error::
           type_id::create("error"));
      error.configure(.blk_parent(this));
      error.build(csr_excl);
      default_map.add_reg(.rg(error),
                          .offset(32'hb8));
      error.add_hdl_path_slice(
          "u_reg.u_error_no_key.q",
          0, 1, 0, "BkdrRegPathRtl");
      error.add_hdl_path_slice(
          "u_reg.u_error_no_nonce.q",
          1, 1, 0, "BkdrRegPathRtl");
      error.add_hdl_path_slice(
          "u_reg.u_error_wrong_order.q",
          2, 1, 0, "BkdrRegPathRtl");
      error.add_hdl_path_slice(
          "u_reg.u_error_flag_input_missmatch.q",
          3, 1, 0, "BkdrRegPathRtl");

      // assign locked reg to its regwen reg
      ctrl_aux_regwen.add_lockable_reg_or_fld(ctrl_aux_shadowed);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : ascon_reg_block

endpackage

