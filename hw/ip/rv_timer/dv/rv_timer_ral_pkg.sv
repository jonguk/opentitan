// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package rv_timer_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class rv_timer_reg_alert_test;
  typedef class rv_timer_reg_ctrl;
  typedef class rv_timer_reg_intr_enable0;
  typedef class rv_timer_reg_intr_state0;
  typedef class rv_timer_reg_intr_test0;
  typedef class rv_timer_reg_cfg0;
  typedef class rv_timer_reg_timer_v_lower0;
  typedef class rv_timer_reg_timer_v_upper0;
  typedef class rv_timer_reg_compare_lower0_0;
  typedef class rv_timer_reg_compare_upper0_0;
  typedef class rv_timer_reg_block;

  class rv_timer_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(rv_timer_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : rv_timer_reg_alert_test

  class rv_timer_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field active;

    `uvm_object_utils(rv_timer_reg_ctrl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      active =
          (dv_base_reg_field::
           type_id::create("active_0"));
      active.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      active.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(active.get_full_name(), CsrExclWrite, CsrNonInitTests);
    endfunction : build
  endclass : rv_timer_reg_ctrl

  class rv_timer_reg_intr_enable0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field ie;

    `uvm_object_utils(rv_timer_reg_intr_enable0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ie =
          (dv_base_reg_field::
           type_id::create("ie_0"));
      ie.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ie.set_original_access("RW");
    endfunction : build
  endclass : rv_timer_reg_intr_enable0

  class rv_timer_reg_intr_state0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field is;

    `uvm_object_utils(rv_timer_reg_intr_state0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      is =
          (dv_base_reg_field::
           type_id::create("is_0"));
      is.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      is.set_original_access("W1C");
      // create field tags
      csr_excl.add_excl(is.get_full_name(), CsrExclWriteCheck, CsrNonInitTests);
    endfunction : build
  endclass : rv_timer_reg_intr_state0

  class rv_timer_reg_intr_test0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field t;

    `uvm_object_utils(rv_timer_reg_intr_test0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      t =
          (dv_base_reg_field::
           type_id::create("t_0"));
      t.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      t.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(t.get_full_name(), CsrExclWrite, CsrNonInitTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : rv_timer_reg_intr_test0

  class rv_timer_reg_cfg0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field prescale;
    rand dv_base_reg_field step;

    `uvm_object_utils(rv_timer_reg_cfg0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      prescale =
          (dv_base_reg_field::
           type_id::create("prescale"));
      prescale.configure(
        .parent(this),
        .size(12),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      prescale.set_original_access("RW");
      step =
          (dv_base_reg_field::
           type_id::create("step"));
      step.configure(
        .parent(this),
        .size(8),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      step.set_original_access("RW");
    endfunction : build
  endclass : rv_timer_reg_cfg0

  class rv_timer_reg_timer_v_lower0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field v;

    `uvm_object_utils(rv_timer_reg_timer_v_lower0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      v =
          (dv_base_reg_field::
           type_id::create("v"));
      v.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      v.set_original_access("RW");
    endfunction : build
  endclass : rv_timer_reg_timer_v_lower0

  class rv_timer_reg_timer_v_upper0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field v;

    `uvm_object_utils(rv_timer_reg_timer_v_upper0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      v =
          (dv_base_reg_field::
           type_id::create("v"));
      v.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      v.set_original_access("RW");
    endfunction : build
  endclass : rv_timer_reg_timer_v_upper0

  class rv_timer_reg_compare_lower0_0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field v;

    `uvm_object_utils(rv_timer_reg_compare_lower0_0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      v =
          (dv_base_reg_field::
           type_id::create("v"));
      v.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'hffffffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      v.set_original_access("RW");
    endfunction : build
  endclass : rv_timer_reg_compare_lower0_0

  class rv_timer_reg_compare_upper0_0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field v;

    `uvm_object_utils(rv_timer_reg_compare_upper0_0)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      v =
          (dv_base_reg_field::
           type_id::create("v"));
      v.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'hffffffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      v.set_original_access("RW");
    endfunction : build
  endclass : rv_timer_reg_compare_upper0_0

  class rv_timer_reg_block extends dv_base_reg_block;
    // registers
    rand rv_timer_reg_alert_test alert_test;
    rand rv_timer_reg_ctrl ctrl[1];
    rand rv_timer_reg_intr_enable0 intr_enable0[1];
    rand rv_timer_reg_intr_state0 intr_state0[1];
    rand rv_timer_reg_intr_test0 intr_test0[1];
    rand rv_timer_reg_cfg0 cfg0;
    rand rv_timer_reg_timer_v_lower0 timer_v_lower0;
    rand rv_timer_reg_timer_v_upper0 timer_v_upper0;
    rand rv_timer_reg_compare_lower0_0 compare_lower0_0;
    rand rv_timer_reg_compare_upper0_0 compare_upper0_0;

    `uvm_object_utils(rv_timer_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      alert_test =
          (rv_timer_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'h0));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      ctrl[0] =
          (rv_timer_reg_ctrl::
           type_id::create("ctrl"));
      ctrl[0].configure(.blk_parent(this));
      ctrl[0].build(csr_excl);
      default_map.add_reg(.rg(ctrl[0]),
                          .offset(32'h4));
      ctrl[0].add_hdl_path_slice(
          "u_reg.u_ctrl.q",
          0, 1, 0, "BkdrRegPathRtl");

      intr_enable0[0] =
          (rv_timer_reg_intr_enable0::
           type_id::create("intr_enable0"));
      intr_enable0[0].configure(.blk_parent(this));
      intr_enable0[0].build(csr_excl);
      default_map.add_reg(.rg(intr_enable0[0]),
                          .offset(32'h100));
      intr_enable0[0].add_hdl_path_slice(
          "u_reg.u_intr_enable0.q",
          0, 1, 0, "BkdrRegPathRtl");

      intr_state0[0] =
          (rv_timer_reg_intr_state0::
           type_id::create("intr_state0"));
      intr_state0[0].configure(.blk_parent(this));
      intr_state0[0].build(csr_excl);
      default_map.add_reg(.rg(intr_state0[0]),
                          .offset(32'h104));
      intr_state0[0].add_hdl_path_slice(
          "u_reg.u_intr_state0.q",
          0, 1, 0, "BkdrRegPathRtl");

      intr_test0[0] =
          (rv_timer_reg_intr_test0::
           type_id::create("intr_test0"));
      intr_test0[0].configure(.blk_parent(this));
      intr_test0[0].build(csr_excl);
      default_map.add_reg(.rg(intr_test0[0]),
                          .offset(32'h108));
      intr_test0[0].add_hdl_path_slice(
          "u_reg.u_intr_test0.qs",
          0, 1, 0, "BkdrRegPathRtl");

      cfg0 =
          (rv_timer_reg_cfg0::
           type_id::create("cfg0"));
      cfg0.configure(.blk_parent(this));
      cfg0.build(csr_excl);
      default_map.add_reg(.rg(cfg0),
                          .offset(32'h10c));
      cfg0.add_hdl_path_slice(
          "u_reg.u_cfg0_prescale.q",
          0, 12, 0, "BkdrRegPathRtl");
      cfg0.add_hdl_path_slice(
          "u_reg.u_cfg0_step.q",
          16, 8, 0, "BkdrRegPathRtl");

      timer_v_lower0 =
          (rv_timer_reg_timer_v_lower0::
           type_id::create("timer_v_lower0"));
      timer_v_lower0.configure(.blk_parent(this));
      timer_v_lower0.build(csr_excl);
      default_map.add_reg(.rg(timer_v_lower0),
                          .offset(32'h110));
      timer_v_lower0.add_hdl_path_slice(
          "u_reg.u_timer_v_lower0.q",
          0, 32, 0, "BkdrRegPathRtl");

      timer_v_upper0 =
          (rv_timer_reg_timer_v_upper0::
           type_id::create("timer_v_upper0"));
      timer_v_upper0.configure(.blk_parent(this));
      timer_v_upper0.build(csr_excl);
      default_map.add_reg(.rg(timer_v_upper0),
                          .offset(32'h114));
      timer_v_upper0.add_hdl_path_slice(
          "u_reg.u_timer_v_upper0.q",
          0, 32, 0, "BkdrRegPathRtl");

      compare_lower0_0 =
          (rv_timer_reg_compare_lower0_0::
           type_id::create("compare_lower0_0"));
      compare_lower0_0.configure(.blk_parent(this));
      compare_lower0_0.build(csr_excl);
      default_map.add_reg(.rg(compare_lower0_0),
                          .offset(32'h118));
      compare_lower0_0.add_hdl_path_slice(
          "u_reg.u_compare_lower0_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      compare_upper0_0 =
          (rv_timer_reg_compare_upper0_0::
           type_id::create("compare_upper0_0"));
      compare_upper0_0.configure(.blk_parent(this));
      compare_upper0_0.build(csr_excl);
      default_map.add_reg(.rg(compare_upper0_0),
                          .offset(32'h11c));
      compare_upper0_0.add_hdl_path_slice(
          "u_reg.u_compare_upper0_0.q",
          0, 32, 0, "BkdrRegPathRtl");



      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : rv_timer_reg_block

endpackage

