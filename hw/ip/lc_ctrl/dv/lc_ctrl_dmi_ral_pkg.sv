// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package lc_ctrl_dmi_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class lc_ctrl_dmi_mem_dmi;
  typedef class lc_ctrl_dmi_reg_block;

  class lc_ctrl_dmi_mem_dmi extends dv_base_mem;

    `uvm_object_utils(lc_ctrl_dmi_mem_dmi)

    function new(string           name = "",
                 longint unsigned size = 1024,
                 int unsigned     n_bits = 32,
                 string           access = "RW",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
      set_data_intg_passthru(1);
    endfunction : new

  endclass : lc_ctrl_dmi_mem_dmi


  class lc_ctrl_dmi_reg_block extends dv_base_reg_block;
    // memories
    rand lc_ctrl_dmi_mem_dmi dmi;

    `uvm_object_utils(lc_ctrl_dmi_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end

      // create memories
      dmi =
          lc_ctrl_dmi_mem_dmi::type_id::create("dmi");
      dmi.configure(.parent(this));
      default_map.add_mem(.mem(dmi),
                          .offset(32'h0),
                          .rights("RW"));


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : lc_ctrl_dmi_reg_block

endpackage

