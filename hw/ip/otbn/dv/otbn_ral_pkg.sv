// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package otbn_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class otbn_reg_intr_state;
  typedef class otbn_reg_intr_enable;
  typedef class otbn_reg_intr_test;
  typedef class otbn_reg_alert_test;
  typedef class otbn_reg_cmd;
  typedef class otbn_reg_ctrl;
  typedef class otbn_reg_status;
  typedef class otbn_reg_err_bits;
  typedef class otbn_reg_fatal_alert_cause;
  typedef class otbn_reg_insn_cnt;
  typedef class otbn_reg_load_checksum;
  typedef class otbn_mem_imem;
  typedef class otbn_mem_dmem;
  typedef class otbn_reg_block;

  class otbn_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field done;

    `uvm_object_utils(otbn_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      done =
          (dv_base_reg_field::
           type_id::create("done"));
      done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done.set_original_access("W1C");
    endfunction : build
  endclass : otbn_reg_intr_state

  class otbn_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field done;

    `uvm_object_utils(otbn_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      done =
          (dv_base_reg_field::
           type_id::create("done"));
      done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done.set_original_access("RW");
    endfunction : build
  endclass : otbn_reg_intr_enable

  class otbn_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field done;

    `uvm_object_utils(otbn_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      done =
          (dv_base_reg_field::
           type_id::create("done"));
      done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      done.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : otbn_reg_intr_test

  class otbn_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal;
    rand dv_base_reg_field recov;

    `uvm_object_utils(otbn_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal =
          (dv_base_reg_field::
           type_id::create("fatal"));
      fatal.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal.set_original_access("WO");
      recov =
          (dv_base_reg_field::
           type_id::create("recov"));
      recov.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : otbn_reg_alert_test

  class otbn_reg_cmd extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmd;

    `uvm_object_utils(otbn_reg_cmd)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmd =
          (dv_base_reg_field::
           type_id::create("cmd"));
      cmd.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(cmd.get_full_name(), CsrExclWrite, CsrAllTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : otbn_reg_cmd

  class otbn_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field software_errs_fatal;

    `uvm_object_utils(otbn_reg_ctrl)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      software_errs_fatal =
          (dv_base_reg_field::
           type_id::create("software_errs_fatal"));
      software_errs_fatal.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      software_errs_fatal.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : otbn_reg_ctrl

  class otbn_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field status;

    `uvm_object_utils(otbn_reg_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      status =
          (dv_base_reg_field::
           type_id::create("status"));
      status.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h4),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      status.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(status.get_full_name(), CsrExclAll, CsrAllTests);
    endfunction : build
  endclass : otbn_reg_status

  class otbn_reg_err_bits extends dv_base_reg;
    // fields
    rand dv_base_reg_field bad_data_addr;
    rand dv_base_reg_field bad_insn_addr;
    rand dv_base_reg_field call_stack;
    rand dv_base_reg_field illegal_insn;
    rand dv_base_reg_field loop;
    rand dv_base_reg_field key_invalid;
    rand dv_base_reg_field rnd_rep_chk_fail;
    rand dv_base_reg_field rnd_fips_chk_fail;
    rand dv_base_reg_field imem_intg_violation;
    rand dv_base_reg_field dmem_intg_violation;
    rand dv_base_reg_field reg_intg_violation;
    rand dv_base_reg_field bus_intg_violation;
    rand dv_base_reg_field bad_internal_state;
    rand dv_base_reg_field illegal_bus_access;
    rand dv_base_reg_field lifecycle_escalation;
    rand dv_base_reg_field fatal_software;

    `uvm_object_utils(otbn_reg_err_bits)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      bad_data_addr =
          (dv_base_reg_field::
           type_id::create("bad_data_addr"));
      bad_data_addr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bad_data_addr.set_original_access("RW");
      bad_insn_addr =
          (dv_base_reg_field::
           type_id::create("bad_insn_addr"));
      bad_insn_addr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bad_insn_addr.set_original_access("RW");
      call_stack =
          (dv_base_reg_field::
           type_id::create("call_stack"));
      call_stack.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      call_stack.set_original_access("RW");
      illegal_insn =
          (dv_base_reg_field::
           type_id::create("illegal_insn"));
      illegal_insn.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      illegal_insn.set_original_access("RW");
      loop =
          (dv_base_reg_field::
           type_id::create("loop"));
      loop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      loop.set_original_access("RW");
      key_invalid =
          (dv_base_reg_field::
           type_id::create("key_invalid"));
      key_invalid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_invalid.set_original_access("RW");
      rnd_rep_chk_fail =
          (dv_base_reg_field::
           type_id::create("rnd_rep_chk_fail"));
      rnd_rep_chk_fail.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rnd_rep_chk_fail.set_original_access("RW");
      rnd_fips_chk_fail =
          (dv_base_reg_field::
           type_id::create("rnd_fips_chk_fail"));
      rnd_fips_chk_fail.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rnd_fips_chk_fail.set_original_access("RW");
      imem_intg_violation =
          (dv_base_reg_field::
           type_id::create("imem_intg_violation"));
      imem_intg_violation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      imem_intg_violation.set_original_access("RW");
      dmem_intg_violation =
          (dv_base_reg_field::
           type_id::create("dmem_intg_violation"));
      dmem_intg_violation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dmem_intg_violation.set_original_access("RW");
      reg_intg_violation =
          (dv_base_reg_field::
           type_id::create("reg_intg_violation"));
      reg_intg_violation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(18),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reg_intg_violation.set_original_access("RW");
      bus_intg_violation =
          (dv_base_reg_field::
           type_id::create("bus_intg_violation"));
      bus_intg_violation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(19),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_intg_violation.set_original_access("RW");
      bad_internal_state =
          (dv_base_reg_field::
           type_id::create("bad_internal_state"));
      bad_internal_state.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bad_internal_state.set_original_access("RW");
      illegal_bus_access =
          (dv_base_reg_field::
           type_id::create("illegal_bus_access"));
      illegal_bus_access.configure(
        .parent(this),
        .size(1),
        .lsb_pos(21),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      illegal_bus_access.set_original_access("RW");
      lifecycle_escalation =
          (dv_base_reg_field::
           type_id::create("lifecycle_escalation"));
      lifecycle_escalation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(22),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      lifecycle_escalation.set_original_access("RW");
      fatal_software =
          (dv_base_reg_field::
           type_id::create("fatal_software"));
      fatal_software.configure(
        .parent(this),
        .size(1),
        .lsb_pos(23),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_software.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : otbn_reg_err_bits

  class otbn_reg_fatal_alert_cause extends dv_base_reg;
    // fields
    rand dv_base_reg_field imem_intg_violation;
    rand dv_base_reg_field dmem_intg_violation;
    rand dv_base_reg_field reg_intg_violation;
    rand dv_base_reg_field bus_intg_violation;
    rand dv_base_reg_field bad_internal_state;
    rand dv_base_reg_field illegal_bus_access;
    rand dv_base_reg_field lifecycle_escalation;
    rand dv_base_reg_field fatal_software;

    `uvm_object_utils(otbn_reg_fatal_alert_cause)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      imem_intg_violation =
          (dv_base_reg_field::
           type_id::create("imem_intg_violation"));
      imem_intg_violation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      imem_intg_violation.set_original_access("RO");
      dmem_intg_violation =
          (dv_base_reg_field::
           type_id::create("dmem_intg_violation"));
      dmem_intg_violation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      dmem_intg_violation.set_original_access("RO");
      reg_intg_violation =
          (dv_base_reg_field::
           type_id::create("reg_intg_violation"));
      reg_intg_violation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reg_intg_violation.set_original_access("RO");
      bus_intg_violation =
          (dv_base_reg_field::
           type_id::create("bus_intg_violation"));
      bus_intg_violation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bus_intg_violation.set_original_access("RO");
      bad_internal_state =
          (dv_base_reg_field::
           type_id::create("bad_internal_state"));
      bad_internal_state.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bad_internal_state.set_original_access("RO");
      illegal_bus_access =
          (dv_base_reg_field::
           type_id::create("illegal_bus_access"));
      illegal_bus_access.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      illegal_bus_access.set_original_access("RO");
      lifecycle_escalation =
          (dv_base_reg_field::
           type_id::create("lifecycle_escalation"));
      lifecycle_escalation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      lifecycle_escalation.set_original_access("RO");
      fatal_software =
          (dv_base_reg_field::
           type_id::create("fatal_software"));
      fatal_software.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_software.set_original_access("RO");
    endfunction : build
  endclass : otbn_reg_fatal_alert_cause

  class otbn_reg_insn_cnt extends dv_base_reg;
    // fields
    rand dv_base_reg_field insn_cnt;

    `uvm_object_utils(otbn_reg_insn_cnt)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      insn_cnt =
          (dv_base_reg_field::
           type_id::create("insn_cnt"));
      insn_cnt.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      insn_cnt.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(insn_cnt.get_full_name(), CsrExclWrite, CsrAllTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : otbn_reg_insn_cnt

  class otbn_reg_load_checksum extends dv_base_reg;
    // fields
    rand dv_base_reg_field checksum;

    `uvm_object_utils(otbn_reg_load_checksum)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      checksum =
          (dv_base_reg_field::
           type_id::create("checksum"));
      checksum.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      checksum.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : otbn_reg_load_checksum

  class otbn_mem_imem extends dv_base_mem;

    `uvm_object_utils(otbn_mem_imem)

    function new(string           name = "",
                 longint unsigned size = 2048,
                 int unsigned     n_bits = 32,
                 string           access = "RW",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
      set_data_intg_passthru(1);
    endfunction : new

  endclass : otbn_mem_imem


  class otbn_mem_dmem extends dv_base_mem;

    `uvm_object_utils(otbn_mem_dmem)

    function new(string           name = "",
                 longint unsigned size = 768,
                 int unsigned     n_bits = 32,
                 string           access = "RW",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
      set_data_intg_passthru(1);
    endfunction : new

  endclass : otbn_mem_dmem


  class otbn_reg_block extends dv_base_reg_block;
    // registers
    rand otbn_reg_intr_state intr_state;
    rand otbn_reg_intr_enable intr_enable;
    rand otbn_reg_intr_test intr_test;
    rand otbn_reg_alert_test alert_test;
    rand otbn_reg_cmd cmd;
    rand otbn_reg_ctrl ctrl;
    rand otbn_reg_status status;
    rand otbn_reg_err_bits err_bits;
    rand otbn_reg_fatal_alert_cause fatal_alert_cause;
    rand otbn_reg_insn_cnt insn_cnt;
    rand otbn_reg_load_checksum load_checksum;
    // memories
    rand otbn_mem_imem imem;
    rand otbn_mem_dmem dmem;

    `uvm_object_utils(otbn_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (otbn_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (otbn_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable.q",
          0, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (otbn_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (otbn_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_recov.qs",
          1, 1, 0, "BkdrRegPathRtl");

      cmd =
          (otbn_reg_cmd::
           type_id::create("cmd"));
      cmd.configure(.blk_parent(this));
      cmd.build(csr_excl);
      default_map.add_reg(.rg(cmd),
                          .offset(32'h10));
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd.qs",
          0, 8, 0, "BkdrRegPathRtl");

      ctrl =
          (otbn_reg_ctrl::
           type_id::create("ctrl"));
      ctrl.configure(.blk_parent(this));
      ctrl.build(csr_excl);
      default_map.add_reg(.rg(ctrl),
                          .offset(32'h14));
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl.qs",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(ctrl.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      status =
          (otbn_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h18));
      status.add_hdl_path_slice(
          "u_reg.u_status.q",
          0, 8, 0, "BkdrRegPathRtl");

      err_bits =
          (otbn_reg_err_bits::
           type_id::create("err_bits"));
      err_bits.configure(.blk_parent(this));
      err_bits.build(csr_excl);
      default_map.add_reg(.rg(err_bits),
                          .offset(32'h1c));
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_bad_data_addr.qs",
          0, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_bad_insn_addr.qs",
          1, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_call_stack.qs",
          2, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_illegal_insn.qs",
          3, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_loop.qs",
          4, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_key_invalid.qs",
          5, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_rnd_rep_chk_fail.qs",
          6, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_rnd_fips_chk_fail.qs",
          7, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_imem_intg_violation.qs",
          16, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_dmem_intg_violation.qs",
          17, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_reg_intg_violation.qs",
          18, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_bus_intg_violation.qs",
          19, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_bad_internal_state.qs",
          20, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_illegal_bus_access.qs",
          21, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_lifecycle_escalation.qs",
          22, 1, 0, "BkdrRegPathRtl");
      err_bits.add_hdl_path_slice(
          "u_reg.u_err_bits_fatal_software.qs",
          23, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(err_bits.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      fatal_alert_cause =
          (otbn_reg_fatal_alert_cause::
           type_id::create("fatal_alert_cause"));
      fatal_alert_cause.configure(.blk_parent(this));
      fatal_alert_cause.build(csr_excl);
      default_map.add_reg(.rg(fatal_alert_cause),
                          .offset(32'h20));
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg.u_fatal_alert_cause_imem_intg_violation.q",
          0, 1, 0, "BkdrRegPathRtl");
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg.u_fatal_alert_cause_dmem_intg_violation.q",
          1, 1, 0, "BkdrRegPathRtl");
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg.u_fatal_alert_cause_reg_intg_violation.q",
          2, 1, 0, "BkdrRegPathRtl");
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg.u_fatal_alert_cause_bus_intg_violation.q",
          3, 1, 0, "BkdrRegPathRtl");
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg.u_fatal_alert_cause_bad_internal_state.q",
          4, 1, 0, "BkdrRegPathRtl");
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg.u_fatal_alert_cause_illegal_bus_access.q",
          5, 1, 0, "BkdrRegPathRtl");
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg.u_fatal_alert_cause_lifecycle_escalation.q",
          6, 1, 0, "BkdrRegPathRtl");
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg.u_fatal_alert_cause_fatal_software.q",
          7, 1, 0, "BkdrRegPathRtl");

      insn_cnt =
          (otbn_reg_insn_cnt::
           type_id::create("insn_cnt"));
      insn_cnt.configure(.blk_parent(this));
      insn_cnt.build(csr_excl);
      default_map.add_reg(.rg(insn_cnt),
                          .offset(32'h24));
      insn_cnt.add_hdl_path_slice(
          "u_reg.u_insn_cnt.qs",
          0, 32, 0, "BkdrRegPathRtl");

      load_checksum =
          (otbn_reg_load_checksum::
           type_id::create("load_checksum"));
      load_checksum.configure(.blk_parent(this));
      load_checksum.build(csr_excl);
      default_map.add_reg(.rg(load_checksum),
                          .offset(32'h28));
      load_checksum.add_hdl_path_slice(
          "u_reg.u_load_checksum.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(load_checksum.get_full_name(),
                        CsrExclAll, CsrAllTests);

      // create memories
      imem =
          otbn_mem_imem::type_id::create("imem");
      imem.configure(.parent(this));
      default_map.add_mem(.mem(imem),
                          .offset(32'h4000),
                          .rights("RW"));
      dmem =
          otbn_mem_dmem::type_id::create("dmem");
      dmem.configure(.parent(this));
      default_map.add_mem(.mem(dmem),
                          .offset(32'h8000),
                          .rights("RW"));


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : otbn_reg_block

endpackage

