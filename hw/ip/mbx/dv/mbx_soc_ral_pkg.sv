// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package mbx_soc_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class mbx_soc_reg_soc_control;
  typedef class mbx_soc_reg_soc_status;
  typedef class mbx_soc_reg_soc_doe_intr_msg_addr;
  typedef class mbx_soc_reg_soc_doe_intr_msg_data;
  typedef class mbx_soc_mem_wdata;
  typedef class mbx_soc_mem_rdata;
  typedef class mbx_soc_reg_block;

  class mbx_soc_reg_soc_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field abort;
    rand dv_base_reg_field doe_intr_en;
    rand dv_base_reg_field doe_async_msg_en;
    rand dv_base_reg_field go;

    `uvm_object_utils(mbx_soc_reg_soc_control)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      abort =
          (dv_base_reg_field::
           type_id::create("abort"));
      abort.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      abort.set_original_access("WO");
      doe_intr_en =
          (dv_base_reg_field::
           type_id::create("doe_intr_en"));
      doe_intr_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      doe_intr_en.set_original_access("RW");
      doe_async_msg_en =
          (dv_base_reg_field::
           type_id::create("doe_async_msg_en"));
      doe_async_msg_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      doe_async_msg_en.set_original_access("RW");
      go =
          (dv_base_reg_field::
           type_id::create("go"));
      go.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      go.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_soc_reg_soc_control

  class mbx_soc_reg_soc_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field busy;
    rand dv_base_reg_field doe_intr_status;
    rand dv_base_reg_field error;
    rand dv_base_reg_field doe_async_msg_status;
    rand dv_base_reg_field ready;

    `uvm_object_utils(mbx_soc_reg_soc_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      busy =
          (dv_base_reg_field::
           type_id::create("busy"));
      busy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      busy.set_original_access("RO");
      doe_intr_status =
          (dv_base_reg_field::
           type_id::create("doe_intr_status"));
      doe_intr_status.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      doe_intr_status.set_original_access("W1C");
      error =
          (dv_base_reg_field::
           type_id::create("error"));
      error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      error.set_original_access("RO");
      doe_async_msg_status =
          (dv_base_reg_field::
           type_id::create("doe_async_msg_status"));
      doe_async_msg_status.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      doe_async_msg_status.set_original_access("RO");
      ready =
          (dv_base_reg_field::
           type_id::create("ready"));
      ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ready.set_original_access("RO");
    endfunction : build
  endclass : mbx_soc_reg_soc_status

  class mbx_soc_reg_soc_doe_intr_msg_addr extends dv_base_reg;
    // fields
    rand dv_base_reg_field doe_intr_msg_addr;

    `uvm_object_utils(mbx_soc_reg_soc_doe_intr_msg_addr)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      doe_intr_msg_addr =
          (dv_base_reg_field::
           type_id::create("doe_intr_msg_addr"));
      doe_intr_msg_addr.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      doe_intr_msg_addr.set_original_access("RW");
    endfunction : build
  endclass : mbx_soc_reg_soc_doe_intr_msg_addr

  class mbx_soc_reg_soc_doe_intr_msg_data extends dv_base_reg;
    // fields
    rand dv_base_reg_field doe_intr_msg_data;

    `uvm_object_utils(mbx_soc_reg_soc_doe_intr_msg_data)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      doe_intr_msg_data =
          (dv_base_reg_field::
           type_id::create("doe_intr_msg_data"));
      doe_intr_msg_data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      doe_intr_msg_data.set_original_access("RW");
    endfunction : build
  endclass : mbx_soc_reg_soc_doe_intr_msg_data

  class mbx_soc_mem_wdata extends dv_base_mem;

    `uvm_object_utils(mbx_soc_mem_wdata)

    function new(string           name = "",
                 longint unsigned size = 1,
                 int unsigned     n_bits = 32,
                 string           access = "WO",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
    endfunction : new

  endclass : mbx_soc_mem_wdata


  class mbx_soc_mem_rdata extends dv_base_mem;

    `uvm_object_utils(mbx_soc_mem_rdata)

    function new(string           name = "",
                 longint unsigned size = 1,
                 int unsigned     n_bits = 32,
                 string           access = "RW",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
    endfunction : new

  endclass : mbx_soc_mem_rdata


  class mbx_soc_reg_block extends dv_base_reg_block;
    // registers
    rand mbx_soc_reg_soc_control soc_control;
    rand mbx_soc_reg_soc_status soc_status;
    rand mbx_soc_reg_soc_doe_intr_msg_addr soc_doe_intr_msg_addr;
    rand mbx_soc_reg_soc_doe_intr_msg_data soc_doe_intr_msg_data;
    // memories
    rand mbx_soc_mem_wdata wdata;
    rand mbx_soc_mem_rdata rdata;

    `uvm_object_utils(mbx_soc_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      soc_control =
          (mbx_soc_reg_soc_control::
           type_id::create("soc_control"));
      soc_control.configure(.blk_parent(this));
      soc_control.build(csr_excl);
      default_map.add_reg(.rg(soc_control),
                          .offset(32'h8));
      soc_control.add_hdl_path_slice(
          "u_reg_soc.u_soc_control_abort.qs",
          0, 1, 0, "BkdrRegPathRtl");
      soc_control.add_hdl_path_slice(
          "u_reg_soc.u_soc_control_doe_intr_en.qs",
          1, 1, 0, "BkdrRegPathRtl");
      soc_control.add_hdl_path_slice(
          "u_reg_soc.u_soc_control_doe_async_msg_en.qs",
          3, 1, 0, "BkdrRegPathRtl");
      soc_control.add_hdl_path_slice(
          "u_reg_soc.u_soc_control_go.qs",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(soc_control.get_full_name(),
                        CsrExclAll, CsrNonInitTests);
      soc_status =
          (mbx_soc_reg_soc_status::
           type_id::create("soc_status"));
      soc_status.configure(.blk_parent(this));
      soc_status.build(csr_excl);
      default_map.add_reg(.rg(soc_status),
                          .offset(32'hc));
      soc_status.add_hdl_path_slice(
          "u_reg_soc.u_soc_status_busy.q",
          0, 1, 0, "BkdrRegPathRtl");
      soc_status.add_hdl_path_slice(
          "u_reg_soc.u_soc_status_doe_intr_status.q",
          1, 1, 0, "BkdrRegPathRtl");
      soc_status.add_hdl_path_slice(
          "u_reg_soc.u_soc_status_error.q",
          2, 1, 0, "BkdrRegPathRtl");
      soc_status.add_hdl_path_slice(
          "u_reg_soc.u_soc_status_doe_async_msg_status.q",
          3, 1, 0, "BkdrRegPathRtl");
      soc_status.add_hdl_path_slice(
          "u_reg_soc.u_soc_status_ready.q",
          31, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(soc_status.get_full_name(),
                        CsrExclAll, CsrAllTests);
      soc_doe_intr_msg_addr =
          (mbx_soc_reg_soc_doe_intr_msg_addr::
           type_id::create("soc_doe_intr_msg_addr"));
      soc_doe_intr_msg_addr.configure(.blk_parent(this));
      soc_doe_intr_msg_addr.build(csr_excl);
      default_map.add_reg(.rg(soc_doe_intr_msg_addr),
                          .offset(32'h18));
      soc_doe_intr_msg_addr.add_hdl_path_slice(
          "u_reg_soc.u_soc_doe_intr_msg_addr.q",
          0, 32, 0, "BkdrRegPathRtl");

      soc_doe_intr_msg_data =
          (mbx_soc_reg_soc_doe_intr_msg_data::
           type_id::create("soc_doe_intr_msg_data"));
      soc_doe_intr_msg_data.configure(.blk_parent(this));
      soc_doe_intr_msg_data.build(csr_excl);
      default_map.add_reg(.rg(soc_doe_intr_msg_data),
                          .offset(32'h1c));
      soc_doe_intr_msg_data.add_hdl_path_slice(
          "u_reg_soc.u_soc_doe_intr_msg_data.q",
          0, 32, 0, "BkdrRegPathRtl");


      // create memories
      wdata =
          mbx_soc_mem_wdata::type_id::create("wdata");
      wdata.configure(.parent(this));
      default_map.add_mem(.mem(wdata),
                          .offset(32'h10),
                          .rights("WO"));
      rdata =
          mbx_soc_mem_rdata::type_id::create("rdata");
      rdata.configure(.parent(this));
      default_map.add_mem(.mem(rdata),
                          .offset(32'h14),
                          .rights("RW"));


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : mbx_soc_reg_block

endpackage

