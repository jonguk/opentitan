// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package mbx_core_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class mbx_core_reg_intr_state;
  typedef class mbx_core_reg_intr_enable;
  typedef class mbx_core_reg_intr_test;
  typedef class mbx_core_reg_alert_test;
  typedef class mbx_core_reg_control;
  typedef class mbx_core_reg_status;
  typedef class mbx_core_reg_address_range_regwen;
  typedef class mbx_core_reg_address_range_valid;
  typedef class mbx_core_reg_inbound_base_address;
  typedef class mbx_core_reg_inbound_limit_address;
  typedef class mbx_core_reg_inbound_write_ptr;
  typedef class mbx_core_reg_outbound_base_address;
  typedef class mbx_core_reg_outbound_limit_address;
  typedef class mbx_core_reg_outbound_read_ptr;
  typedef class mbx_core_reg_outbound_object_size;
  typedef class mbx_core_reg_doe_intr_msg_addr;
  typedef class mbx_core_reg_doe_intr_msg_data;
  typedef class mbx_core_reg_block;

  class mbx_core_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field mbx_ready;
    rand dv_base_reg_field mbx_abort;
    rand dv_base_reg_field mbx_error;

    `uvm_object_utils(mbx_core_reg_intr_state)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      mbx_ready =
          (dv_base_reg_field::
           type_id::create("mbx_ready"));
      mbx_ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_ready.set_original_access("W1C");
      mbx_abort =
          (dv_base_reg_field::
           type_id::create("mbx_abort"));
      mbx_abort.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_abort.set_original_access("W1C");
      mbx_error =
          (dv_base_reg_field::
           type_id::create("mbx_error"));
      mbx_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_error.set_original_access("W1C");
    endfunction : build
  endclass : mbx_core_reg_intr_state

  class mbx_core_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field mbx_ready;
    rand dv_base_reg_field mbx_abort;
    rand dv_base_reg_field mbx_error;

    `uvm_object_utils(mbx_core_reg_intr_enable)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      mbx_ready =
          (dv_base_reg_field::
           type_id::create("mbx_ready"));
      mbx_ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_ready.set_original_access("RW");
      mbx_abort =
          (dv_base_reg_field::
           type_id::create("mbx_abort"));
      mbx_abort.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_abort.set_original_access("RW");
      mbx_error =
          (dv_base_reg_field::
           type_id::create("mbx_error"));
      mbx_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_error.set_original_access("RW");
    endfunction : build
  endclass : mbx_core_reg_intr_enable

  class mbx_core_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field mbx_ready;
    rand dv_base_reg_field mbx_abort;
    rand dv_base_reg_field mbx_error;

    `uvm_object_utils(mbx_core_reg_intr_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      mbx_ready =
          (dv_base_reg_field::
           type_id::create("mbx_ready"));
      mbx_ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_ready.set_original_access("WO");
      mbx_abort =
          (dv_base_reg_field::
           type_id::create("mbx_abort"));
      mbx_abort.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_abort.set_original_access("WO");
      mbx_error =
          (dv_base_reg_field::
           type_id::create("mbx_error"));
      mbx_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mbx_error.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_core_reg_intr_test

  class mbx_core_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;
    rand dv_base_reg_field recov_fault;

    `uvm_object_utils(mbx_core_reg_alert_test)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      recov_fault =
          (dv_base_reg_field::
           type_id::create("recov_fault"));
      recov_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_core_reg_alert_test

  class mbx_core_reg_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field abort;
    rand dv_base_reg_field error;
    rand dv_base_reg_field sys_async_msg;

    `uvm_object_utils(mbx_core_reg_control)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      abort =
          (dv_base_reg_field::
           type_id::create("abort"));
      abort.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      abort.set_original_access("RW");
      error =
          (dv_base_reg_field::
           type_id::create("error"));
      error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      error.set_original_access("RW");
      sys_async_msg =
          (dv_base_reg_field::
           type_id::create("sys_async_msg"));
      sys_async_msg.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sys_async_msg.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_core_reg_control

  class mbx_core_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field busy;
    rand dv_base_reg_field sys_intr_state;
    rand dv_base_reg_field sys_intr_enable;
    rand dv_base_reg_field sys_async_enable;

    `uvm_object_utils(mbx_core_reg_status)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      busy =
          (dv_base_reg_field::
           type_id::create("busy"));
      busy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      busy.set_original_access("RO");
      sys_intr_state =
          (dv_base_reg_field::
           type_id::create("sys_intr_state"));
      sys_intr_state.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sys_intr_state.set_original_access("RO");
      sys_intr_enable =
          (dv_base_reg_field::
           type_id::create("sys_intr_enable"));
      sys_intr_enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sys_intr_enable.set_original_access("RO");
      sys_async_enable =
          (dv_base_reg_field::
           type_id::create("sys_async_enable"));
      sys_async_enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sys_async_enable.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_core_reg_status

  class mbx_core_reg_address_range_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field regwen;

    `uvm_object_utils(mbx_core_reg_address_range_regwen)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      regwen =
          (dv_base_reg_field::
           type_id::create("regwen"));
      regwen.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("W0C"),
        .volatile(0),
        .reset(32'h6),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      regwen.set_original_access("RW");
      regwen.set_mubi_width(4);
    endfunction : build
  endclass : mbx_core_reg_address_range_regwen

  class mbx_core_reg_address_range_valid extends dv_base_reg;
    // fields
    rand dv_base_reg_field range_valid;

    `uvm_object_utils(mbx_core_reg_address_range_valid)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      range_valid =
          (dv_base_reg_field::
           type_id::create("range_valid"));
      range_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      range_valid.set_original_access("RW");
    endfunction : build
  endclass : mbx_core_reg_address_range_valid

  class mbx_core_reg_inbound_base_address extends dv_base_reg;
    // fields
    rand dv_base_reg_field base_address;

    `uvm_object_utils(mbx_core_reg_inbound_base_address)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      base_address =
          (dv_base_reg_field::
           type_id::create("base_address"));
      base_address.configure(
        .parent(this),
        .size(30),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      base_address.set_original_access("RW");
    endfunction : build
  endclass : mbx_core_reg_inbound_base_address

  class mbx_core_reg_inbound_limit_address extends dv_base_reg;
    // fields
    rand dv_base_reg_field limit;

    `uvm_object_utils(mbx_core_reg_inbound_limit_address)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      limit =
          (dv_base_reg_field::
           type_id::create("limit"));
      limit.configure(
        .parent(this),
        .size(30),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      limit.set_original_access("RW");
    endfunction : build
  endclass : mbx_core_reg_inbound_limit_address

  class mbx_core_reg_inbound_write_ptr extends dv_base_reg;
    // fields
    rand dv_base_reg_field inbound_write_ptr;

    `uvm_object_utils(mbx_core_reg_inbound_write_ptr)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      inbound_write_ptr =
          (dv_base_reg_field::
           type_id::create("inbound_write_ptr"));
      inbound_write_ptr.configure(
        .parent(this),
        .size(30),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      inbound_write_ptr.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_core_reg_inbound_write_ptr

  class mbx_core_reg_outbound_base_address extends dv_base_reg;
    // fields
    rand dv_base_reg_field base_address;

    `uvm_object_utils(mbx_core_reg_outbound_base_address)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      base_address =
          (dv_base_reg_field::
           type_id::create("base_address"));
      base_address.configure(
        .parent(this),
        .size(30),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      base_address.set_original_access("RW");
    endfunction : build
  endclass : mbx_core_reg_outbound_base_address

  class mbx_core_reg_outbound_limit_address extends dv_base_reg;
    // fields
    rand dv_base_reg_field limit;

    `uvm_object_utils(mbx_core_reg_outbound_limit_address)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      limit =
          (dv_base_reg_field::
           type_id::create("limit"));
      limit.configure(
        .parent(this),
        .size(30),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      limit.set_original_access("RW");
    endfunction : build
  endclass : mbx_core_reg_outbound_limit_address

  class mbx_core_reg_outbound_read_ptr extends dv_base_reg;
    // fields
    rand dv_base_reg_field outbound_read_ptr;

    `uvm_object_utils(mbx_core_reg_outbound_read_ptr)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      outbound_read_ptr =
          (dv_base_reg_field::
           type_id::create("outbound_read_ptr"));
      outbound_read_ptr.configure(
        .parent(this),
        .size(30),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      outbound_read_ptr.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_core_reg_outbound_read_ptr

  class mbx_core_reg_outbound_object_size extends dv_base_reg;
    // fields
    rand dv_base_reg_field cnt;

    `uvm_object_utils(mbx_core_reg_outbound_object_size)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cnt =
          (dv_base_reg_field::
           type_id::create("cnt"));
      cnt.configure(
        .parent(this),
        .size(11),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cnt.set_original_access("RW");
    endfunction : build
  endclass : mbx_core_reg_outbound_object_size

  class mbx_core_reg_doe_intr_msg_addr extends dv_base_reg;
    // fields
    rand dv_base_reg_field doe_intr_msg_addr;

    `uvm_object_utils(mbx_core_reg_doe_intr_msg_addr)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      doe_intr_msg_addr =
          (dv_base_reg_field::
           type_id::create("doe_intr_msg_addr"));
      doe_intr_msg_addr.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      doe_intr_msg_addr.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_core_reg_doe_intr_msg_addr

  class mbx_core_reg_doe_intr_msg_data extends dv_base_reg;
    // fields
    rand dv_base_reg_field doe_intr_msg_data;

    `uvm_object_utils(mbx_core_reg_doe_intr_msg_data)

    function new(string       name = "",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      doe_intr_msg_data =
          (dv_base_reg_field::
           type_id::create("doe_intr_msg_data"));
      doe_intr_msg_data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      doe_intr_msg_data.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : mbx_core_reg_doe_intr_msg_data

  class mbx_core_reg_block extends dv_base_reg_block;
    // registers
    rand mbx_core_reg_intr_state intr_state;
    rand mbx_core_reg_intr_enable intr_enable;
    rand mbx_core_reg_intr_test intr_test;
    rand mbx_core_reg_alert_test alert_test;
    rand mbx_core_reg_control control;
    rand mbx_core_reg_status status;
    rand mbx_core_reg_address_range_regwen address_range_regwen;
    rand mbx_core_reg_address_range_valid address_range_valid;
    rand mbx_core_reg_inbound_base_address inbound_base_address;
    rand mbx_core_reg_inbound_limit_address inbound_limit_address;
    rand mbx_core_reg_inbound_write_ptr inbound_write_ptr;
    rand mbx_core_reg_outbound_base_address outbound_base_address;
    rand mbx_core_reg_outbound_limit_address outbound_limit_address;
    rand mbx_core_reg_outbound_read_ptr outbound_read_ptr;
    rand mbx_core_reg_outbound_object_size outbound_object_size;
    rand mbx_core_reg_doe_intr_msg_addr doe_intr_msg_addr;
    rand mbx_core_reg_doe_intr_msg_data doe_intr_msg_data;

    `uvm_object_utils(mbx_core_reg_block)

    function new(string name = "",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (mbx_core_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg_core.u_intr_state_mbx_ready.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg_core.u_intr_state_mbx_abort.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg_core.u_intr_state_mbx_error.q",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (mbx_core_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg_core.u_intr_enable_mbx_ready.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg_core.u_intr_enable_mbx_abort.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg_core.u_intr_enable_mbx_error.q",
          2, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (mbx_core_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg_core.u_intr_test_mbx_ready.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg_core.u_intr_test_mbx_abort.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg_core.u_intr_test_mbx_error.qs",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (mbx_core_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg_core.u_alert_test_fatal_fault.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg_core.u_alert_test_recov_fault.qs",
          1, 1, 0, "BkdrRegPathRtl");

      control =
          (mbx_core_reg_control::
           type_id::create("control"));
      control.configure(.blk_parent(this));
      control.build(csr_excl);
      default_map.add_reg(.rg(control),
                          .offset(32'h10));
      control.add_hdl_path_slice(
          "u_reg_core.u_control_abort.qs",
          0, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_reg_core.u_control_error.qs",
          1, 1, 0, "BkdrRegPathRtl");
      control.add_hdl_path_slice(
          "u_reg_core.u_control_sys_async_msg.qs",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(control.get_full_name(),
                        CsrExclAll, CsrAllTests);
      status =
          (mbx_core_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h14));
      status.add_hdl_path_slice(
          "u_reg_core.u_status_busy.qs",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_core.u_status_sys_intr_state.qs",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_core.u_status_sys_intr_enable.qs",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg_core.u_status_sys_async_enable.qs",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(status.get_full_name(),
                        CsrExclAll, CsrAllTests);
      address_range_regwen =
          (mbx_core_reg_address_range_regwen::
           type_id::create("address_range_regwen"));
      address_range_regwen.configure(.blk_parent(this));
      address_range_regwen.build(csr_excl);
      default_map.add_reg(.rg(address_range_regwen),
                          .offset(32'h18));
      address_range_regwen.add_hdl_path_slice(
          "u_reg_core.u_address_range_regwen.q",
          0, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(address_range_regwen.get_full_name(),
                        CsrExclAll, CsrNonInitTests);
      address_range_valid =
          (mbx_core_reg_address_range_valid::
           type_id::create("address_range_valid"));
      address_range_valid.configure(.blk_parent(this));
      address_range_valid.build(csr_excl);
      default_map.add_reg(.rg(address_range_valid),
                          .offset(32'h1c));
      address_range_valid.add_hdl_path_slice(
          "u_reg_core.u_address_range_valid.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(address_range_valid.get_full_name(),
                        CsrExclAll, CsrAllTests);
      inbound_base_address =
          (mbx_core_reg_inbound_base_address::
           type_id::create("inbound_base_address"));
      inbound_base_address.configure(.blk_parent(this));
      inbound_base_address.build(csr_excl);
      default_map.add_reg(.rg(inbound_base_address),
                          .offset(32'h20));
      inbound_base_address.add_hdl_path_slice(
          "u_reg_core.u_inbound_base_address.q",
          2, 30, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(inbound_base_address.get_full_name(),
                        CsrExclAll, CsrAllTests);
      inbound_limit_address =
          (mbx_core_reg_inbound_limit_address::
           type_id::create("inbound_limit_address"));
      inbound_limit_address.configure(.blk_parent(this));
      inbound_limit_address.build(csr_excl);
      default_map.add_reg(.rg(inbound_limit_address),
                          .offset(32'h24));
      inbound_limit_address.add_hdl_path_slice(
          "u_reg_core.u_inbound_limit_address.q",
          2, 30, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(inbound_limit_address.get_full_name(),
                        CsrExclAll, CsrAllTests);
      inbound_write_ptr =
          (mbx_core_reg_inbound_write_ptr::
           type_id::create("inbound_write_ptr"));
      inbound_write_ptr.configure(.blk_parent(this));
      inbound_write_ptr.build(csr_excl);
      default_map.add_reg(.rg(inbound_write_ptr),
                          .offset(32'h28));
      inbound_write_ptr.add_hdl_path_slice(
          "u_reg_core.u_inbound_write_ptr.qs",
          2, 30, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(inbound_write_ptr.get_full_name(),
                        CsrExclAll, CsrAllTests);
      outbound_base_address =
          (mbx_core_reg_outbound_base_address::
           type_id::create("outbound_base_address"));
      outbound_base_address.configure(.blk_parent(this));
      outbound_base_address.build(csr_excl);
      default_map.add_reg(.rg(outbound_base_address),
                          .offset(32'h2c));
      outbound_base_address.add_hdl_path_slice(
          "u_reg_core.u_outbound_base_address.q",
          2, 30, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(outbound_base_address.get_full_name(),
                        CsrExclAll, CsrAllTests);
      outbound_limit_address =
          (mbx_core_reg_outbound_limit_address::
           type_id::create("outbound_limit_address"));
      outbound_limit_address.configure(.blk_parent(this));
      outbound_limit_address.build(csr_excl);
      default_map.add_reg(.rg(outbound_limit_address),
                          .offset(32'h30));
      outbound_limit_address.add_hdl_path_slice(
          "u_reg_core.u_outbound_limit_address.q",
          2, 30, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(outbound_limit_address.get_full_name(),
                        CsrExclAll, CsrAllTests);
      outbound_read_ptr =
          (mbx_core_reg_outbound_read_ptr::
           type_id::create("outbound_read_ptr"));
      outbound_read_ptr.configure(.blk_parent(this));
      outbound_read_ptr.build(csr_excl);
      default_map.add_reg(.rg(outbound_read_ptr),
                          .offset(32'h34));
      outbound_read_ptr.add_hdl_path_slice(
          "u_reg_core.u_outbound_read_ptr.qs",
          2, 30, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(outbound_read_ptr.get_full_name(),
                        CsrExclAll, CsrAllTests);
      outbound_object_size =
          (mbx_core_reg_outbound_object_size::
           type_id::create("outbound_object_size"));
      outbound_object_size.configure(.blk_parent(this));
      outbound_object_size.build(csr_excl);
      default_map.add_reg(.rg(outbound_object_size),
                          .offset(32'h38));
      outbound_object_size.add_hdl_path_slice(
          "u_reg_core.u_outbound_object_size.q",
          0, 11, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(outbound_object_size.get_full_name(),
                        CsrExclAll, CsrAllTests);
      doe_intr_msg_addr =
          (mbx_core_reg_doe_intr_msg_addr::
           type_id::create("doe_intr_msg_addr"));
      doe_intr_msg_addr.configure(.blk_parent(this));
      doe_intr_msg_addr.build(csr_excl);
      default_map.add_reg(.rg(doe_intr_msg_addr),
                          .offset(32'h3c));
      doe_intr_msg_addr.add_hdl_path_slice(
          "u_reg_core.u_doe_intr_msg_addr.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(doe_intr_msg_addr.get_full_name(),
                        CsrExclAll, CsrAllTests);
      doe_intr_msg_data =
          (mbx_core_reg_doe_intr_msg_data::
           type_id::create("doe_intr_msg_data"));
      doe_intr_msg_data.configure(.blk_parent(this));
      doe_intr_msg_data.build(csr_excl);
      default_map.add_reg(.rg(doe_intr_msg_data),
                          .offset(32'h40));
      doe_intr_msg_data.add_hdl_path_slice(
          "u_reg_core.u_doe_intr_msg_data.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(doe_intr_msg_data.get_full_name(),
                        CsrExclAll, CsrAllTests);
      // assign locked reg to its regwen reg
      address_range_regwen.add_lockable_reg_or_fld(inbound_base_address);
      address_range_regwen.add_lockable_reg_or_fld(inbound_limit_address);
      address_range_regwen.add_lockable_reg_or_fld(outbound_base_address);
      address_range_regwen.add_lockable_reg_or_fld(outbound_limit_address);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : mbx_core_reg_block

endpackage

